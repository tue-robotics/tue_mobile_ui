!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__),
        module.l = !0, module.exports;
    }
    var installedModules = {};
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            configurable: !1,
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default;
        } : function() {
            return module;
        };
        return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 40);
}([ function(module, exports, __webpack_require__) {
    (function(angular) {
        __webpack_require__(41), module.exports = angular, module.exports = window.angular;
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    var ROSLIB = this.ROSLIB || {
        REVISION: "1.1.0"
    }, assign = __webpack_require__(2);
    assign(ROSLIB, __webpack_require__(74)), assign(ROSLIB, __webpack_require__(84)),
    assign(ROSLIB, __webpack_require__(87)), assign(ROSLIB, __webpack_require__(88)),
    assign(ROSLIB, __webpack_require__(90)), module.exports = ROSLIB;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function toObject(val) {
        if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(val);
    }
    /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
    var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
    module.exports = function() {
        try {
            if (!Object.assign) return !1;
            var test1 = new String("abc");
            if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
            for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
            if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
            }).join("")) return !1;
            var test3 = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
            }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
        } catch (err) {
            return !1;
        }
    }() ? Object.assign : function(target, source) {
        for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) hasOwnProperty.call(from, key) && (to[key] = from[key]);
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
            }
        }
        return to;
    };
}, function(module, exports, __webpack_require__) {
    (function(process) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !function(undefined) {
            function init() {
                this._events = {}, this._conf && configure.call(this, this._conf);
            }
            function configure(conf) {
                conf ? (this._conf = conf, conf.delimiter && (this.delimiter = conf.delimiter),
                this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners,
                conf.wildcard && (this.wildcard = conf.wildcard), conf.newListener && (this.newListener = conf.newListener),
                conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak), this.wildcard && (this.listenerTree = {})) : this._maxListeners = defaultMaxListeners;
            }
            function logPossibleMemoryLeak(count, eventName) {
                var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
                if (this.verboseMemoryLeak && (errorMsg += " Event name: " + eventName + "."), void 0 !== process && process.emitWarning) {
                    var e = new Error(errorMsg);
                    e.name = "MaxListenersExceededWarning", e.emitter = this, e.count = count, process.emitWarning(e);
                } else console.error(errorMsg), console.trace && console.trace();
            }
            function EventEmitter(conf) {
                this._events = {}, this.newListener = !1, this.verboseMemoryLeak = !1, configure.call(this, conf);
            }
            function searchListenerTree(handlers, type, tree, i) {
                if (!tree) return [];
                var leaf, len, branch, xTree, xxTree, isolatedBranch, endReached, listeners = [], typeLength = type.length, currentType = type[i], nextType = type[i + 1];
                if (i === typeLength && tree._listeners) {
                    if ("function" == typeof tree._listeners) return handlers && handlers.push(tree._listeners),
                    [ tree ];
                    for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) handlers && handlers.push(tree._listeners[leaf]);
                    return [ tree ];
                }
                if ("*" === currentType || "**" === currentType || tree[currentType]) {
                    if ("*" === currentType) {
                        for (branch in tree) "_listeners" !== branch && tree.hasOwnProperty(branch) && (listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1)));
                        return listeners;
                    }
                    if ("**" === currentType) {
                        endReached = i + 1 === typeLength || i + 2 === typeLength && "*" === nextType, endReached && tree._listeners && (listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength)));
                        for (branch in tree) "_listeners" !== branch && tree.hasOwnProperty(branch) && ("*" === branch || "**" === branch ? (tree[branch]._listeners && !endReached && (listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength))),
                        listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i))) : listeners = branch === nextType ? listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2)) : listeners.concat(searchListenerTree(handlers, type, tree[branch], i)));
                        return listeners;
                    }
                    listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
                }
                if (xTree = tree["*"], xTree && searchListenerTree(handlers, type, xTree, i + 1),
                xxTree = tree["**"]) if (i < typeLength) {
                    xxTree._listeners && searchListenerTree(handlers, type, xxTree, typeLength);
                    for (branch in xxTree) "_listeners" !== branch && xxTree.hasOwnProperty(branch) && (branch === nextType ? searchListenerTree(handlers, type, xxTree[branch], i + 2) : branch === currentType ? searchListenerTree(handlers, type, xxTree[branch], i + 1) : (isolatedBranch = {},
                    isolatedBranch[branch] = xxTree[branch], searchListenerTree(handlers, type, {
                        "**": isolatedBranch
                    }, i + 1)));
                } else xxTree._listeners ? searchListenerTree(handlers, type, xxTree, typeLength) : xxTree["*"] && xxTree["*"]._listeners && searchListenerTree(handlers, type, xxTree["*"], typeLength);
                return listeners;
            }
            function growListenerTree(type, listener) {
                type = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                for (var i = 0, len = type.length; i + 1 < len; i++) if ("**" === type[i] && "**" === type[i + 1]) return;
                for (var tree = this.listenerTree, name = type.shift(); name !== undefined; ) {
                    if (tree[name] || (tree[name] = {}), tree = tree[name], 0 === type.length) return tree._listeners ? ("function" == typeof tree._listeners && (tree._listeners = [ tree._listeners ]),
                    tree._listeners.push(listener), !tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners && (tree._listeners.warned = !0,
                    logPossibleMemoryLeak.call(this, tree._listeners.length, name))) : tree._listeners = listener,
                    !0;
                    name = type.shift();
                }
                return !0;
            }
            var isArray = Array.isArray ? Array.isArray : function(obj) {
                return "[object Array]" === Object.prototype.toString.call(obj);
            }, defaultMaxListeners = 10;
            EventEmitter.EventEmitter2 = EventEmitter, EventEmitter.prototype.delimiter = ".",
            EventEmitter.prototype.setMaxListeners = function(n) {
                n !== undefined && (this._maxListeners = n, this._conf || (this._conf = {}), this._conf.maxListeners = n);
            }, EventEmitter.prototype.event = "", EventEmitter.prototype.once = function(event, fn) {
                return this._once(event, fn, !1);
            }, EventEmitter.prototype.prependOnceListener = function(event, fn) {
                return this._once(event, fn, !0);
            }, EventEmitter.prototype._once = function(event, fn, prepend) {
                return this._many(event, 1, fn, prepend), this;
            }, EventEmitter.prototype.many = function(event, ttl, fn) {
                return this._many(event, ttl, fn, !1);
            }, EventEmitter.prototype.prependMany = function(event, ttl, fn) {
                return this._many(event, ttl, fn, !0);
            }, EventEmitter.prototype._many = function(event, ttl, fn, prepend) {
                function listener() {
                    return 0 == --ttl && self.off(event, listener), fn.apply(this, arguments);
                }
                var self = this;
                if ("function" != typeof fn) throw new Error("many only accepts instances of Function");
                return listener._origin = fn, this._on(event, listener, prepend), self;
            }, EventEmitter.prototype.emit = function() {
                this._events || init.call(this);
                var type = arguments[0];
                if ("newListener" === type && !this.newListener && !this._events.newListener) return !1;
                var args, l, i, j, handler, al = arguments.length;
                if (this._all && this._all.length) {
                    if (handler = this._all.slice(), al > 3) for (args = new Array(al), j = 0; j < al; j++) args[j] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        handler[i].call(this, type);
                        break;

                      case 2:
                        handler[i].call(this, type, arguments[1]);
                        break;

                      case 3:
                        handler[i].call(this, type, arguments[1], arguments[2]);
                        break;

                      default:
                        handler[i].apply(this, args);
                    }
                }
                if (this.wildcard) {
                    handler = [];
                    var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
                } else {
                    if ("function" == typeof (handler = this._events[type])) {
                        switch (this.event = type, al) {
                          case 1:
                            handler.call(this);
                            break;

                          case 2:
                            handler.call(this, arguments[1]);
                            break;

                          case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;

                          default:
                            for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                            handler.apply(this, args);
                        }
                        return !0;
                    }
                    handler && (handler = handler.slice());
                }
                if (handler && handler.length) {
                    if (al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        handler[i].call(this);
                        break;

                      case 2:
                        handler[i].call(this, arguments[1]);
                        break;

                      case 3:
                        handler[i].call(this, arguments[1], arguments[2]);
                        break;

                      default:
                        handler[i].apply(this, args);
                    }
                    return !0;
                }
                if (!this._all && "error" === type) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
                return !!this._all;
            }, EventEmitter.prototype.emitAsync = function() {
                this._events || init.call(this);
                var type = arguments[0];
                if ("newListener" === type && !this.newListener && !this._events.newListener) return Promise.resolve([ !1 ]);
                var args, l, i, j, handler, promises = [], al = arguments.length;
                if (this._all) {
                    if (al > 3) for (args = new Array(al), j = 1; j < al; j++) args[j] = arguments[j];
                    for (i = 0, l = this._all.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        promises.push(this._all[i].call(this, type));
                        break;

                      case 2:
                        promises.push(this._all[i].call(this, type, arguments[1]));
                        break;

                      case 3:
                        promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                        break;

                      default:
                        promises.push(this._all[i].apply(this, args));
                    }
                }
                if (this.wildcard) {
                    handler = [];
                    var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
                } else handler = this._events[type];
                if ("function" == typeof handler) switch (this.event = type, al) {
                  case 1:
                    promises.push(handler.call(this));
                    break;

                  case 2:
                    promises.push(handler.call(this, arguments[1]));
                    break;

                  case 3:
                    promises.push(handler.call(this, arguments[1], arguments[2]));
                    break;

                  default:
                    for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    promises.push(handler.apply(this, args));
                } else if (handler && handler.length) {
                    if (handler = handler.slice(), al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        promises.push(handler[i].call(this));
                        break;

                      case 2:
                        promises.push(handler[i].call(this, arguments[1]));
                        break;

                      case 3:
                        promises.push(handler[i].call(this, arguments[1], arguments[2]));
                        break;

                      default:
                        promises.push(handler[i].apply(this, args));
                    }
                } else if (!this._all && "error" === type) return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
                return Promise.all(promises);
            }, EventEmitter.prototype.on = function(type, listener) {
                return this._on(type, listener, !1);
            }, EventEmitter.prototype.prependListener = function(type, listener) {
                return this._on(type, listener, !0);
            }, EventEmitter.prototype.onAny = function(fn) {
                return this._onAny(fn, !1);
            }, EventEmitter.prototype.prependAny = function(fn) {
                return this._onAny(fn, !0);
            }, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prototype._onAny = function(fn, prepend) {
                if ("function" != typeof fn) throw new Error("onAny only accepts instances of Function");
                return this._all || (this._all = []), prepend ? this._all.unshift(fn) : this._all.push(fn),
                this;
            }, EventEmitter.prototype._on = function(type, listener, prepend) {
                if ("function" == typeof type) return this._onAny(type, listener), this;
                if ("function" != typeof listener) throw new Error("on only accepts instances of Function");
                return this._events || init.call(this), this.emit("newListener", type, listener),
                this.wildcard ? (growListenerTree.call(this, type, listener), this) : (this._events[type] ? ("function" == typeof this._events[type] && (this._events[type] = [ this._events[type] ]),
                prepend ? this._events[type].unshift(listener) : this._events[type].push(listener),
                !this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners && (this._events[type].warned = !0,
                logPossibleMemoryLeak.call(this, this._events[type].length, type))) : this._events[type] = listener,
                this);
            }, EventEmitter.prototype.off = function(type, listener) {
                function recursivelyGarbageCollect(root) {
                    if (root !== undefined) {
                        var keys = Object.keys(root);
                        for (var i in keys) {
                            var key = keys[i], obj = root[key];
                            obj instanceof Function || "object" != typeof obj || null === obj || (Object.keys(obj).length > 0 && recursivelyGarbageCollect(root[key]),
                            0 === Object.keys(obj).length && delete root[key]);
                        }
                    }
                }
                if ("function" != typeof listener) throw new Error("removeListener only takes instances of Function");
                var handlers, leafs = [];
                if (this.wildcard) {
                    var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
                } else {
                    if (!this._events[type]) return this;
                    handlers = this._events[type], leafs.push({
                        _listeners: handlers
                    });
                }
                for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
                    var leaf = leafs[iLeaf];
                    if (handlers = leaf._listeners, isArray(handlers)) {
                        for (var position = -1, i = 0, length = handlers.length; i < length; i++) if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                            position = i;
                            break;
                        }
                        if (position < 0) continue;
                        return this.wildcard ? leaf._listeners.splice(position, 1) : this._events[type].splice(position, 1),
                        0 === handlers.length && (this.wildcard ? delete leaf._listeners : delete this._events[type]),
                        this.emit("removeListener", type, listener), this;
                    }
                    (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) && (this.wildcard ? delete leaf._listeners : delete this._events[type],
                    this.emit("removeListener", type, listener));
                }
                return recursivelyGarbageCollect(this.listenerTree), this;
            }, EventEmitter.prototype.offAny = function(fn) {
                var fns, i = 0, l = 0;
                if (fn && this._all && this._all.length > 0) {
                    for (fns = this._all, i = 0, l = fns.length; i < l; i++) if (fn === fns[i]) return fns.splice(i, 1),
                    this.emit("removeListenerAny", fn), this;
                } else {
                    for (fns = this._all, i = 0, l = fns.length; i < l; i++) this.emit("removeListenerAny", fns[i]);
                    this._all = [];
                }
                return this;
            }, EventEmitter.prototype.removeListener = EventEmitter.prototype.off, EventEmitter.prototype.removeAllListeners = function(type) {
                if (0 === arguments.length) return !this._events || init.call(this), this;
                if (this.wildcard) for (var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice(), leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0), iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
                    var leaf = leafs[iLeaf];
                    leaf._listeners = null;
                } else this._events && (this._events[type] = null);
                return this;
            }, EventEmitter.prototype.listeners = function(type) {
                if (this.wildcard) {
                    var handlers = [], ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    return searchListenerTree.call(this, handlers, ns, this.listenerTree, 0), handlers;
                }
                return this._events || init.call(this), this._events[type] || (this._events[type] = []),
                isArray(this._events[type]) || (this._events[type] = [ this._events[type] ]), this._events[type];
            }, EventEmitter.prototype.eventNames = function() {
                return Object.keys(this._events);
            }, EventEmitter.prototype.listenerCount = function(type) {
                return this.listeners(type).length;
            }, EventEmitter.prototype.listenersAny = function() {
                return this._all ? this._all : [];
            }, (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return EventEmitter;
            }.call(exports, __webpack_require__, exports, module)) !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        }();
    }).call(exports, __webpack_require__(13));
}, function(module, exports) {
    function Vector3(options) {
        options = options || {}, this.x = options.x || 0, this.y = options.y || 0, this.z = options.z || 0;
    }
    Vector3.prototype.add = function(v) {
        this.x += v.x, this.y += v.y, this.z += v.z;
    }, Vector3.prototype.subtract = function(v) {
        this.x -= v.x, this.y -= v.y, this.z -= v.z;
    }, Vector3.prototype.multiplyQuaternion = function(q) {
        var ix = q.w * this.x + q.y * this.z - q.z * this.y, iy = q.w * this.y + q.z * this.x - q.x * this.z, iz = q.w * this.z + q.x * this.y - q.y * this.x, iw = -q.x * this.x - q.y * this.y - q.z * this.z;
        this.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y, this.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,
        this.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
    }, Vector3.prototype.clone = function() {
        return new Vector3(this);
    }, module.exports = Vector3;
}, function(module, exports, __webpack_require__) {
    (function(process, setImmediate) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !function(undefined) {
            function init() {
                this._events = {}, this._conf && configure.call(this, this._conf);
            }
            function configure(conf) {
                conf && (this._conf = conf, conf.delimiter && (this.delimiter = conf.delimiter),
                conf.maxListeners !== undefined && (this._maxListeners = conf.maxListeners), conf.wildcard && (this.wildcard = conf.wildcard),
                conf.newListener && (this._newListener = conf.newListener), conf.removeListener && (this._removeListener = conf.removeListener),
                conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak), conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors),
                this.wildcard && (this.listenerTree = {}));
            }
            function logPossibleMemoryLeak(count, eventName) {
                var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
                if (this.verboseMemoryLeak && (errorMsg += " Event name: " + eventName + "."), void 0 !== process && process.emitWarning) {
                    var e = new Error(errorMsg);
                    e.name = "MaxListenersExceededWarning", e.emitter = this, e.count = count, process.emitWarning(e);
                } else console.error(errorMsg), console.trace && console.trace();
            }
            function toObject(keys, values) {
                for (var key, obj = {}, len = keys.length, valuesCount = values ? value.length : 0, i = 0; i < len; i++) key = keys[i],
                obj[key] = i < valuesCount ? values[i] : undefined;
                return obj;
            }
            function TargetObserver(emitter, target, options) {
                this._emitter = emitter, this._target = target, this._listeners = {}, this._listenersCount = 0;
                var on, off;
                if ((options.on || options.off) && (on = options.on, off = options.off), target.addEventListener ? (on = target.addEventListener,
                off = target.removeEventListener) : target.addListener ? (on = target.addListener,
                off = target.removeListener) : target.on && (on = target.on, off = target.off),
                !on && !off) throw Error("target does not implement any known event API");
                if ("function" != typeof on) throw TypeError("on method must be a function");
                if ("function" != typeof off) throw TypeError("off method must be a function");
                this._on = on, this._off = off;
                var _observers = emitter._observers;
                _observers ? _observers.push(this) : emitter._observers = [ this ];
            }
            function resolveOptions(options, schema, reducers, allowUnknown) {
                function reject(reason) {
                    throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
                }
                var computedOptions = Object.assign({}, schema);
                if (!options) return computedOptions;
                if ("object" != typeof options) throw TypeError("options must be an object");
                for (var option, value, reducer, keys = Object.keys(options), length = keys.length, i = 0; i < length; i++) {
                    if (option = keys[i], !allowUnknown && !hasOwnProperty.call(schema, option)) throw Error('Unknown "' + option + '" option');
                    value = options[option], value !== undefined && (reducer = reducers[option], computedOptions[option] = reducer ? reducer(value, reject) : value);
                }
                return computedOptions;
            }
            function constructorReducer(value, reject) {
                return "function" == typeof value && value.hasOwnProperty("prototype") || reject("value must be a constructor"),
                value;
            }
            function makeTypeReducer(types) {
                var message = "value must be type of " + types.join("|"), len = types.length, firstType = types[0], secondType = types[1];
                return 1 === len ? function(v, reject) {
                    if (typeof v === firstType) return v;
                    reject(message);
                } : 2 === len ? function(v, reject) {
                    var kind = typeof v;
                    if (kind === firstType || kind === secondType) return v;
                    reject(message);
                } : function(v, reject) {
                    for (var kind = typeof v, i = len; i-- > 0; ) if (kind === types[i]) return v;
                    reject(message);
                };
            }
            function makeCancelablePromise(Promise, executor, options) {
                var isCancelable, callbacks, subscriptionClosed, timer = 0, promise = new Promise(function(resolve, reject, onCancel) {
                    function cleanup() {
                        callbacks && (callbacks = null), timer && (clearTimeout(timer), timer = 0);
                    }
                    options = resolveOptions(options, {
                        timeout: 0,
                        overload: !1
                    }, {
                        timeout: function(value, reject) {
                            return value *= 1, ("number" != typeof value || value < 0 || !Number.isFinite(value)) && reject("timeout must be a positive number"),
                            value;
                        }
                    }), isCancelable = !options.overload && "function" == typeof Promise.prototype.cancel && "function" == typeof onCancel;
                    var _resolve = function(value) {
                        cleanup(), resolve(value);
                    }, _reject = function(err) {
                        cleanup(), reject(err);
                    };
                    isCancelable ? executor(_resolve, _reject, onCancel) : (callbacks = [ function(reason) {
                        _reject(reason || Error("canceled"));
                    } ], executor(_resolve, _reject, function(cb) {
                        if (subscriptionClosed) throw Error("Unable to subscribe on cancel event asynchronously");
                        if ("function" != typeof cb) throw TypeError("onCancel callback must be a function");
                        callbacks.push(cb);
                    }), subscriptionClosed = !0), options.timeout > 0 && (timer = setTimeout(function() {
                        var reason = Error("timeout");
                        timer = 0, promise.cancel(reason), reject(reason);
                    }, options.timeout));
                });
                return isCancelable || (promise.cancel = function(reason) {
                    if (callbacks) {
                        for (var length = callbacks.length, i = 1; i < length; i++) callbacks[i](reason);
                        callbacks[0](reason), callbacks = null;
                    }
                }), promise;
            }
            function findTargetIndex(observer) {
                var observers = this._observers;
                if (!observers) return -1;
                for (var len = observers.length, i = 0; i < len; i++) if (observers[i]._target === observer) return i;
                return -1;
            }
            function searchListenerTree(handlers, type, tree, i, typeLength) {
                if (!tree) return null;
                if (0 === i) {
                    var kind = typeof type;
                    if ("string" === kind) {
                        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
                        if (-1 !== (n = type.indexOf(delimiter))) {
                            ns = new Array(5);
                            do {
                                ns[l++] = type.slice(j, n), j = n + dl;
                            } while (-1 !== (n = type.indexOf(delimiter, j)));
                            ns[l++] = type.slice(j), type = ns, typeLength = l;
                        } else type = [ type ], typeLength = 1;
                    } else "object" === kind ? typeLength = type.length : (type = [ type ], typeLength = 1);
                }
                var branch, xTree, xxTree, isolatedBranch, endReached, branches, _listeners, listeners = null, currentType = type[i], nextType = type[i + 1];
                if (i === typeLength && tree._listeners) return "function" == typeof tree._listeners ? (handlers && handlers.push(tree._listeners),
                [ tree ]) : (handlers && handlers.push.apply(handlers, tree._listeners), [ tree ]);
                if ("*" === currentType) {
                    for (branches = ownKeys(tree), n = branches.length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && (_listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength)) && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners);
                    return listeners;
                }
                if ("**" === currentType) {
                    for (endReached = i + 1 === typeLength || i + 2 === typeLength && "*" === nextType,
                    endReached && tree._listeners && (listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength)),
                    branches = ownKeys(tree), n = branches.length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && ("*" === branch || "**" === branch ? (tree[branch]._listeners && !endReached && (_listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength)) && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners),
                    _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength)) : _listeners = branch === nextType ? searchListenerTree(handlers, type, tree[branch], i + 2, typeLength) : searchListenerTree(handlers, type, tree[branch], i, typeLength),
                    _listeners && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners));
                    return listeners;
                }
                if (tree[currentType] && (listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength)),
                xTree = tree["*"], xTree && searchListenerTree(handlers, type, xTree, i + 1, typeLength),
                xxTree = tree["**"]) if (i < typeLength) for (xxTree._listeners && searchListenerTree(handlers, type, xxTree, typeLength, typeLength),
                branches = ownKeys(xxTree), n = branches.length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && (branch === nextType ? searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength) : branch === currentType ? searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength) : (isolatedBranch = {},
                isolatedBranch[branch] = xxTree[branch], searchListenerTree(handlers, type, {
                    "**": isolatedBranch
                }, i + 1, typeLength))); else xxTree._listeners ? searchListenerTree(handlers, type, xxTree, typeLength, typeLength) : xxTree["*"] && xxTree["*"]._listeners && searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
                return listeners;
            }
            function growListenerTree(type, listener) {
                var i, ns, len = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
                if ("string" == typeof type) if (-1 !== (i = type.indexOf(delimiter))) {
                    ns = new Array(5);
                    do {
                        ns[len++] = type.slice(j, i), j = i + dl;
                    } while (-1 !== (i = type.indexOf(delimiter, j)));
                    ns[len++] = type.slice(j);
                } else ns = [ type ], len = 1; else ns = type, len = type.length;
                if (len > 1) for (i = 0; i + 1 < len; i++) if ("**" === ns[i] && "**" === ns[i + 1]) return;
                var name, tree = this.listenerTree;
                for (i = 0; i < len; i++) if (name = ns[i], tree = tree[name] || (tree[name] = {}),
                i === len - 1) return tree._listeners ? ("function" == typeof tree._listeners && (tree._listeners = [ tree._listeners ]),
                tree._listeners.push(listener), !tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners && (tree._listeners.warned = !0,
                logPossibleMemoryLeak.call(this, tree._listeners.length, name))) : tree._listeners = listener,
                !0;
                return !0;
            }
            function collectTreeEvents(tree, events, root, asArray) {
                for (var branch, branchName, path, isArrayPath, branches = ownKeys(tree), i = branches.length, hasListeners = tree._listeners; i-- > 0; ) branchName = branches[i],
                branch = tree[branchName], path = "_listeners" === branchName ? root : root ? root.concat(branchName) : [ branchName ],
                isArrayPath = asArray || "symbol" == typeof branchName, hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter)),
                "object" == typeof branch && collectTreeEvents.call(this, branch, events, path, isArrayPath);
                return events;
            }
            function recursivelyGarbageCollect(root) {
                for (var obj, key, flag, keys = ownKeys(root), i = keys.length; i-- > 0; ) key = keys[i],
                (obj = root[key]) && (flag = !0, "_listeners" === key || recursivelyGarbageCollect(obj) || delete root[key]);
                return flag;
            }
            function Listener(emitter, event, listener) {
                this.emitter = emitter, this.event = event, this.listener = listener;
            }
            function setupListener(event, listener, options) {
                if (!0 === options) promisify = !0; else if (!1 === options) async = !0; else {
                    if (!options || "object" != typeof options) throw TypeError("options should be an object or true");
                    var async = options.async, promisify = options.promisify, nextTick = options.nextTick, objectify = options.objectify;
                }
                if (async || nextTick || promisify) {
                    var _listener = listener, _origin = listener._origin || listener;
                    if (nextTick && !nextTickSupported) throw Error("process.nextTick is not supported");
                    promisify === undefined && (promisify = "AsyncFunction" === listener.constructor.name),
                    listener = function() {
                        var args = arguments, context = this, event = this.event;
                        return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
                            _setImmediate(resolve);
                        }).then(function() {
                            return context.event = event, _listener.apply(context, args);
                        }) : (nextTick ? process.nextTick : _setImmediate)(function() {
                            context.event = event, _listener.apply(context, args);
                        });
                    }, listener._async = !0, listener._origin = _origin;
                }
                return [ listener, objectify ? new Listener(this, event, listener) : this ];
            }
            function EventEmitter(conf) {
                this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1,
                configure.call(this, conf);
            }
            function once(emitter, name, options) {
                return options = resolveOptions(options, {
                    Promise: Promise,
                    timeout: 0,
                    overload: !1
                }, {
                    Promise: constructorReducer
                }), makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
                    var handler;
                    if ("function" == typeof emitter.addEventListener) return handler = function() {
                        resolve(toArray.apply(null, arguments));
                    }, onCancel(function() {
                        emitter.removeEventListener(name, handler);
                    }), void emitter.addEventListener(name, handler, {
                        once: !0
                    });
                    var errorListener, eventListener = function() {
                        errorListener && emitter.removeListener("error", errorListener), resolve(toArray.apply(null, arguments));
                    };
                    "error" !== name && (errorListener = function(err) {
                        emitter.removeListener(name, eventListener), reject(err);
                    }, emitter.once("error", errorListener)), onCancel(function() {
                        errorListener && emitter.removeListener("error", errorListener), emitter.removeListener(name, eventListener);
                    }), emitter.once(name, eventListener);
                }, {
                    timeout: options.timeout,
                    overload: options.overload
                });
            }
            var hasOwnProperty = Object.hasOwnProperty, isArray = Array.isArray ? Array.isArray : function(obj) {
                return "[object Array]" === Object.prototype.toString.call(obj);
            }, nextTickSupported = "object" == typeof process && "function" == typeof process.nextTick, symbolsSupported = "function" == typeof Symbol, reflectSupported = "object" == typeof Reflect, setImmediateSupported = "function" == typeof setImmediate, _setImmediate = setImmediateSupported ? setImmediate : setTimeout, ownKeys = symbolsSupported ? reflectSupported && "function" == typeof Reflect.ownKeys ? Reflect.ownKeys : function(obj) {
                var arr = Object.getOwnPropertyNames(obj);
                return arr.push.apply(arr, Object.getOwnPropertySymbols(obj)), arr;
            } : Object.keys, toArray = function(a, b, c) {
                var n = arguments.length;
                switch (n) {
                  case 0:
                    return [];

                  case 1:
                    return [ a ];

                  case 2:
                    return [ a, b ];

                  case 3:
                    return [ a, b, c ];

                  default:
                    for (var arr = new Array(n); n--; ) arr[n] = arguments[n];
                    return arr;
                }
            };
            Object.assign(TargetObserver.prototype, {
                subscribe: function(event, localEvent, reducer) {
                    var observer = this, target = this._target, emitter = this._emitter, listeners = this._listeners, handler = function() {
                        var args = toArray.apply(null, arguments), eventObj = {
                            data: args,
                            name: localEvent,
                            original: event
                        };
                        if (reducer) {
                            return void (!1 !== reducer.call(target, eventObj) && emitter.emit.apply(emitter, [ eventObj.name ].concat(args)));
                        }
                        emitter.emit.apply(emitter, [ localEvent ].concat(args));
                    };
                    if (listeners[event]) throw Error("Event '" + event + "' is already listening");
                    this._listenersCount++, emitter._newListener && emitter._removeListener && !observer._onNewListener ? (this._onNewListener = function(_event) {
                        _event === localEvent && null === listeners[event] && (listeners[event] = handler,
                        observer._on.call(target, event, handler));
                    }, emitter.on("newListener", this._onNewListener), this._onRemoveListener = function(_event) {
                        _event === localEvent && !emitter.hasListeners(_event) && listeners[event] && (listeners[event] = null,
                        observer._off.call(target, event, handler));
                    }, listeners[event] = null, emitter.on("removeListener", this._onRemoveListener)) : (listeners[event] = handler,
                    observer._on.call(target, event, handler));
                },
                unsubscribe: function(event) {
                    function clearRefs() {
                        observer._onNewListener && (emitter.off("newListener", observer._onNewListener),
                        emitter.off("removeListener", observer._onRemoveListener), observer._onNewListener = null,
                        observer._onRemoveListener = null);
                        var index = findTargetIndex.call(emitter, observer);
                        emitter._observers.splice(index, 1);
                    }
                    var handler, events, i, observer = this, listeners = this._listeners, emitter = this._emitter, off = this._off, target = this._target;
                    if (event && "string" != typeof event) throw TypeError("event must be a string");
                    if (event) {
                        if (!(handler = listeners[event])) return;
                        off.call(target, event, handler), delete listeners[event], --this._listenersCount || clearRefs();
                    } else {
                        for (events = ownKeys(listeners), i = events.length; i-- > 0; ) event = events[i],
                        off.call(target, event, listeners[event]);
                        this._listeners = {}, this._listenersCount = 0, clearRefs();
                    }
                }
            });
            var functionReducer = makeTypeReducer([ "function" ]), objectFunctionReducer = makeTypeReducer([ "object", "function" ]);
            Listener.prototype.off = function() {
                return this.emitter.off(this.event, this.listener), this;
            }, EventEmitter.EventEmitter2 = EventEmitter, EventEmitter.prototype.listenTo = function(target, events, options) {
                function listen(events) {
                    if ("object" != typeof events) throw TypeError("events must be an object");
                    var observer, reducers = options.reducers, index = findTargetIndex.call(emitter, target);
                    observer = -1 === index ? new TargetObserver(emitter, target, options) : emitter._observers[index];
                    for (var event, keys = ownKeys(events), len = keys.length, isSingleReducer = "function" == typeof reducers, i = 0; i < len; i++) event = keys[i],
                    observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
                }
                if ("object" != typeof target) throw TypeError("target musts be an object");
                var emitter = this;
                return options = resolveOptions(options, {
                    on: undefined,
                    off: undefined,
                    reducers: undefined
                }, {
                    on: functionReducer,
                    off: functionReducer,
                    reducers: objectFunctionReducer
                }), listen(isArray(events) ? toObject(events) : "string" == typeof events ? toObject(events.split(/\s+/)) : events),
                this;
            }, EventEmitter.prototype.stopListeningTo = function(target, event) {
                var observers = this._observers;
                if (!observers) return !1;
                var observer, i = observers.length, matched = !1;
                if (target && "object" != typeof target) throw TypeError("target should be an object");
                for (;i-- > 0; ) observer = observers[i], target && observer._target !== target || (observer.unsubscribe(event),
                matched = !0);
                return matched;
            }, EventEmitter.prototype.delimiter = ".", EventEmitter.prototype.setMaxListeners = function(n) {
                n !== undefined && (this._maxListeners = n, this._conf || (this._conf = {}), this._conf.maxListeners = n);
            }, EventEmitter.prototype.getMaxListeners = function() {
                return this._maxListeners;
            }, EventEmitter.prototype.event = "", EventEmitter.prototype.once = function(event, fn, options) {
                return this._once(event, fn, !1, options);
            }, EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
                return this._once(event, fn, !0, options);
            }, EventEmitter.prototype._once = function(event, fn, prepend, options) {
                return this._many(event, 1, fn, prepend, options);
            }, EventEmitter.prototype.many = function(event, ttl, fn, options) {
                return this._many(event, ttl, fn, !1, options);
            }, EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
                return this._many(event, ttl, fn, !0, options);
            }, EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
                function listener() {
                    return 0 == --ttl && self.off(event, listener), fn.apply(this, arguments);
                }
                var self = this;
                if ("function" != typeof fn) throw new Error("many only accepts instances of Function");
                return listener._origin = fn, this._on(event, listener, prepend, options);
            }, EventEmitter.prototype.emit = function() {
                if (!this._events && !this._all) return !1;
                this._events || init.call(this);
                var ns, args, l, i, j, containsSymbol, type = arguments[0], wildcard = this.wildcard;
                if ("newListener" === type && !this._newListener && !this._events.newListener) return !1;
                if (wildcard && (ns = type, "newListener" !== type && "removeListener" !== type && "object" == typeof type)) {
                    if (l = type.length, symbolsSupported) for (i = 0; i < l; i++) if ("symbol" == typeof type[i]) {
                        containsSymbol = !0;
                        break;
                    }
                    containsSymbol || (type = type.join(this.delimiter));
                }
                var handler, al = arguments.length;
                if (this._all && this._all.length) for (handler = this._all.slice(), i = 0, l = handler.length; i < l; i++) switch (this.event = type,
                al) {
                  case 1:
                    handler[i].call(this, type);
                    break;

                  case 2:
                    handler[i].call(this, type, arguments[1]);
                    break;

                  case 3:
                    handler[i].call(this, type, arguments[1], arguments[2]);
                    break;

                  default:
                    handler[i].apply(this, arguments);
                }
                if (wildcard) handler = [], searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l); else {
                    if ("function" == typeof (handler = this._events[type])) {
                        switch (this.event = type, al) {
                          case 1:
                            handler.call(this);
                            break;

                          case 2:
                            handler.call(this, arguments[1]);
                            break;

                          case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;

                          default:
                            for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                            handler.apply(this, args);
                        }
                        return !0;
                    }
                    handler && (handler = handler.slice());
                }
                if (handler && handler.length) {
                    if (al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        handler[i].call(this);
                        break;

                      case 2:
                        handler[i].call(this, arguments[1]);
                        break;

                      case 3:
                        handler[i].call(this, arguments[1], arguments[2]);
                        break;

                      default:
                        handler[i].apply(this, args);
                    }
                    return !0;
                }
                if (!this.ignoreErrors && !this._all && "error" === type) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
                return !!this._all;
            }, EventEmitter.prototype.emitAsync = function() {
                if (!this._events && !this._all) return !1;
                this._events || init.call(this);
                var ns, containsSymbol, args, l, i, j, type = arguments[0], wildcard = this.wildcard;
                if ("newListener" === type && !this._newListener && !this._events.newListener) return Promise.resolve([ !1 ]);
                if (wildcard && (ns = type, "newListener" !== type && "removeListener" !== type && "object" == typeof type)) {
                    if (l = type.length, symbolsSupported) for (i = 0; i < l; i++) if ("symbol" == typeof type[i]) {
                        containsSymbol = !0;
                        break;
                    }
                    containsSymbol || (type = type.join(this.delimiter));
                }
                var handler, promises = [], al = arguments.length;
                if (this._all) for (i = 0, l = this._all.length; i < l; i++) switch (this.event = type,
                al) {
                  case 1:
                    promises.push(this._all[i].call(this, type));
                    break;

                  case 2:
                    promises.push(this._all[i].call(this, type, arguments[1]));
                    break;

                  case 3:
                    promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                    break;

                  default:
                    promises.push(this._all[i].apply(this, arguments));
                }
                if (wildcard ? (handler = [], searchListenerTree.call(this, handler, ns, this.listenerTree, 0)) : handler = this._events[type],
                "function" == typeof handler) switch (this.event = type, al) {
                  case 1:
                    promises.push(handler.call(this));
                    break;

                  case 2:
                    promises.push(handler.call(this, arguments[1]));
                    break;

                  case 3:
                    promises.push(handler.call(this, arguments[1], arguments[2]));
                    break;

                  default:
                    for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    promises.push(handler.apply(this, args));
                } else if (handler && handler.length) {
                    if (handler = handler.slice(), al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        promises.push(handler[i].call(this));
                        break;

                      case 2:
                        promises.push(handler[i].call(this, arguments[1]));
                        break;

                      case 3:
                        promises.push(handler[i].call(this, arguments[1], arguments[2]));
                        break;

                      default:
                        promises.push(handler[i].apply(this, args));
                    }
                } else if (!this.ignoreErrors && !this._all && "error" === type) return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
                return Promise.all(promises);
            }, EventEmitter.prototype.on = function(type, listener, options) {
                return this._on(type, listener, !1, options);
            }, EventEmitter.prototype.prependListener = function(type, listener, options) {
                return this._on(type, listener, !0, options);
            }, EventEmitter.prototype.onAny = function(fn) {
                return this._onAny(fn, !1);
            }, EventEmitter.prototype.prependAny = function(fn) {
                return this._onAny(fn, !0);
            }, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prototype._onAny = function(fn, prepend) {
                if ("function" != typeof fn) throw new Error("onAny only accepts instances of Function");
                return this._all || (this._all = []), prepend ? this._all.unshift(fn) : this._all.push(fn),
                this;
            }, EventEmitter.prototype._on = function(type, listener, prepend, options) {
                if ("function" == typeof type) return this._onAny(type, listener), this;
                if ("function" != typeof listener) throw new Error("on only accepts instances of Function");
                this._events || init.call(this);
                var temp, returnValue = this;
                return options !== undefined && (temp = setupListener.call(this, type, listener, options),
                listener = temp[0], returnValue = temp[1]), this._newListener && this.emit("newListener", type, listener),
                this.wildcard ? (growListenerTree.call(this, type, listener), returnValue) : (this._events[type] ? ("function" == typeof this._events[type] && (this._events[type] = [ this._events[type] ]),
                prepend ? this._events[type].unshift(listener) : this._events[type].push(listener),
                !this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners && (this._events[type].warned = !0,
                logPossibleMemoryLeak.call(this, this._events[type].length, type))) : this._events[type] = listener,
                returnValue);
            }, EventEmitter.prototype.off = function(type, listener) {
                if ("function" != typeof listener) throw new Error("removeListener only takes instances of Function");
                var handlers, leafs = [];
                if (this.wildcard) {
                    var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    if (!(leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0))) return this;
                } else {
                    if (!this._events[type]) return this;
                    handlers = this._events[type], leafs.push({
                        _listeners: handlers
                    });
                }
                for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
                    var leaf = leafs[iLeaf];
                    if (handlers = leaf._listeners, isArray(handlers)) {
                        for (var position = -1, i = 0, length = handlers.length; i < length; i++) if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                            position = i;
                            break;
                        }
                        if (position < 0) continue;
                        return this.wildcard ? leaf._listeners.splice(position, 1) : this._events[type].splice(position, 1),
                        0 === handlers.length && (this.wildcard ? delete leaf._listeners : delete this._events[type]),
                        this._removeListener && this.emit("removeListener", type, listener), this;
                    }
                    (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) && (this.wildcard ? delete leaf._listeners : delete this._events[type],
                    this._removeListener && this.emit("removeListener", type, listener));
                }
                return this.listenerTree && recursivelyGarbageCollect(this.listenerTree), this;
            }, EventEmitter.prototype.offAny = function(fn) {
                var fns, i = 0, l = 0;
                if (fn && this._all && this._all.length > 0) {
                    for (fns = this._all, i = 0, l = fns.length; i < l; i++) if (fn === fns[i]) return fns.splice(i, 1),
                    this._removeListener && this.emit("removeListenerAny", fn), this;
                } else {
                    if (fns = this._all, this._removeListener) for (i = 0, l = fns.length; i < l; i++) this.emit("removeListenerAny", fns[i]);
                    this._all = [];
                }
                return this;
            }, EventEmitter.prototype.removeListener = EventEmitter.prototype.off, EventEmitter.prototype.removeAllListeners = function(type) {
                if (type === undefined) return !this._events || init.call(this), this;
                if (this.wildcard) {
                    var leaf, i, leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0);
                    if (!leafs) return this;
                    for (i = 0; i < leafs.length; i++) leaf = leafs[i], leaf._listeners = null;
                    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
                } else this._events && (this._events[type] = null);
                return this;
            }, EventEmitter.prototype.listeners = function(type) {
                var keys, listeners, allListeners, i, listenerTree, _events = this._events;
                if (type === undefined) {
                    if (this.wildcard) throw Error("event name required for wildcard emitter");
                    if (!_events) return [];
                    for (keys = ownKeys(_events), i = keys.length, allListeners = []; i-- > 0; ) listeners = _events[keys[i]],
                    "function" == typeof listeners ? allListeners.push(listeners) : allListeners.push.apply(allListeners, listeners);
                    return allListeners;
                }
                if (this.wildcard) {
                    if (!(listenerTree = this.listenerTree)) return [];
                    var handlers = [], ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    return searchListenerTree.call(this, handlers, ns, listenerTree, 0), handlers;
                }
                return _events ? (listeners = _events[type], listeners ? "function" == typeof listeners ? [ listeners ] : listeners : []) : [];
            }, EventEmitter.prototype.eventNames = function(nsAsArray) {
                var _events = this._events;
                return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
            }, EventEmitter.prototype.listenerCount = function(type) {
                return this.listeners(type).length;
            }, EventEmitter.prototype.hasListeners = function(type) {
                if (this.wildcard) {
                    var handlers = [], ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    return searchListenerTree.call(this, handlers, ns, this.listenerTree, 0), handlers.length > 0;
                }
                var _events = this._events, _all = this._all;
                return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));
            }, EventEmitter.prototype.listenersAny = function() {
                return this._all ? this._all : [];
            }, EventEmitter.prototype.waitFor = function(event, options) {
                var self = this, type = typeof options;
                return "number" === type ? options = {
                    timeout: options
                } : "function" === type && (options = {
                    filter: options
                }), options = resolveOptions(options, {
                    timeout: 0,
                    filter: undefined,
                    handleError: !1,
                    Promise: Promise,
                    overload: !1
                }, {
                    filter: functionReducer,
                    Promise: constructorReducer
                }), makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
                    function listener() {
                        var filter = options.filter;
                        if (!filter || filter.apply(self, arguments)) if (self.off(event, listener), options.handleError) {
                            var err = arguments[0];
                            err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
                        } else resolve(toArray.apply(null, arguments));
                    }
                    onCancel(function() {
                        self.off(event, listener);
                    }), self._on(event, listener, !1);
                }, {
                    timeout: options.timeout,
                    overload: options.overload
                });
            };
            var prototype = EventEmitter.prototype;
            Object.defineProperties(EventEmitter, {
                defaultMaxListeners: {
                    get: function() {
                        return prototype._maxListeners;
                    },
                    set: function(n) {
                        if ("number" != typeof n || n < 0 || Number.isNaN(n)) throw TypeError("n must be a non-negative number");
                        prototype._maxListeners = n;
                    },
                    enumerable: !0
                },
                once: {
                    value: once,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperties(prototype, {
                _maxListeners: {
                    value: 10,
                    writable: !0,
                    configurable: !0
                },
                _observers: {
                    value: null,
                    writable: !0,
                    configurable: !0
                }
            });
            (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return EventEmitter;
            }.call(exports, __webpack_require__, exports, module)) !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        }();
    }).call(exports, __webpack_require__(13), __webpack_require__(72).setImmediate);
}, function(module, exports, __webpack_require__) {
    function Message(values) {
        assign(this, values);
    }
    var assign = __webpack_require__(2);
    module.exports = Message;
}, function(module, exports, __webpack_require__) {
    function ServiceRequest(values) {
        assign(this, values);
    }
    var assign = __webpack_require__(2);
    module.exports = ServiceRequest;
}, function(module, exports, __webpack_require__) {
    function Topic(options) {
        options = options || {}, this.ros = options.ros, this.name = options.name, this.messageType = options.messageType,
        this.isAdvertised = !1, this.compression = options.compression || "none", this.throttle_rate = options.throttle_rate || 0,
        this.latch = options.latch || !1, this.queue_size = options.queue_size || 100, this.queue_length = options.queue_length || 0,
        this.reconnect_on_close = void 0 === options.reconnect_on_close || options.reconnect_on_close,
        this.compression && "png" !== this.compression && "cbor" !== this.compression && "cbor-raw" !== this.compression && "none" !== this.compression && (this.emit("warning", this.compression + " compression is not supported. No compression will be used."),
        this.compression = "none"), this.throttle_rate < 0 && (this.emit("warning", this.throttle_rate + " is not allowed. Set to 0"),
        this.throttle_rate = 0);
        var that = this;
        this.reconnect_on_close ? this.callForSubscribeAndAdvertise = function(message) {
            that.ros.callOnConnection(message), that.waitForReconnect = !1, that.reconnectFunc = function() {
                that.waitForReconnect || (that.waitForReconnect = !0, that.ros.callOnConnection(message),
                that.ros.once("connection", function() {
                    that.waitForReconnect = !1;
                }));
            }, that.ros.on("close", that.reconnectFunc);
        } : this.callForSubscribeAndAdvertise = this.ros.callOnConnection, this._messageCallback = function(data) {
            that.emit("message", new Message(data));
        };
    }
    var EventEmitter2 = __webpack_require__(3).EventEmitter2, Message = __webpack_require__(6);
    Topic.prototype.__proto__ = EventEmitter2.prototype, Topic.prototype.subscribe = function(callback) {
        "function" == typeof callback && this.on("message", callback), this.subscribeId || (this.ros.on(this.name, this._messageCallback),
        this.subscribeId = "subscribe:" + this.name + ":" + ++this.ros.idCounter, this.callForSubscribeAndAdvertise({
            op: "subscribe",
            id: this.subscribeId,
            type: this.messageType,
            topic: this.name,
            compression: this.compression,
            throttle_rate: this.throttle_rate,
            queue_length: this.queue_length
        }));
    }, Topic.prototype.unsubscribe = function(callback) {
        callback && (this.off("message", callback), this.listeners("message").length) || this.subscribeId && (this.ros.off(this.name, this._messageCallback),
        this.reconnect_on_close && this.ros.off("close", this.reconnectFunc), this.emit("unsubscribe"),
        this.ros.callOnConnection({
            op: "unsubscribe",
            id: this.subscribeId,
            topic: this.name
        }), this.subscribeId = null);
    }, Topic.prototype.advertise = function() {
        if (!this.isAdvertised && (this.advertiseId = "advertise:" + this.name + ":" + ++this.ros.idCounter,
        this.callForSubscribeAndAdvertise({
            op: "advertise",
            id: this.advertiseId,
            type: this.messageType,
            topic: this.name,
            latch: this.latch,
            queue_size: this.queue_size
        }), this.isAdvertised = !0, !this.reconnect_on_close)) {
            var that = this;
            this.ros.on("close", function() {
                that.isAdvertised = !1;
            });
        }
    }, Topic.prototype.unadvertise = function() {
        this.isAdvertised && (this.reconnect_on_close && this.ros.off("close", this.reconnectFunc),
        this.emit("unadvertise"), this.ros.callOnConnection({
            op: "unadvertise",
            id: this.advertiseId,
            topic: this.name
        }), this.isAdvertised = !1);
    }, Topic.prototype.publish = function(message) {
        this.isAdvertised || this.advertise(), this.ros.idCounter++;
        var call = {
            op: "publish",
            id: "publish:" + this.name + ":" + this.ros.idCounter,
            topic: this.name,
            msg: message,
            latch: this.latch
        };
        this.ros.callOnConnection(call);
    }, module.exports = Topic;
}, function(module, exports) {
    function Quaternion(options) {
        options = options || {}, this.x = options.x || 0, this.y = options.y || 0, this.z = options.z || 0,
        this.w = "number" == typeof options.w ? options.w : 1;
    }
    Quaternion.prototype.conjugate = function() {
        this.x *= -1, this.y *= -1, this.z *= -1;
    }, Quaternion.prototype.norm = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }, Quaternion.prototype.normalize = function() {
        var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        0 === l ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (l = 1 / l, this.x = this.x * l,
        this.y = this.y * l, this.z = this.z * l, this.w = this.w * l);
    }, Quaternion.prototype.invert = function() {
        this.conjugate(), this.normalize();
    }, Quaternion.prototype.multiply = function(q) {
        var newX = this.x * q.w + this.y * q.z - this.z * q.y + this.w * q.x, newY = -this.x * q.z + this.y * q.w + this.z * q.x + this.w * q.y, newZ = this.x * q.y - this.y * q.x + this.z * q.w + this.w * q.z, newW = -this.x * q.x - this.y * q.y - this.z * q.z + this.w * q.w;
        this.x = newX, this.y = newY, this.z = newZ, this.w = newW;
    }, Quaternion.prototype.clone = function() {
        return new Quaternion(this);
    }, module.exports = Quaternion;
}, function(module, exports) {
    module.exports = {
        URDF_SPHERE: 0,
        URDF_BOX: 1,
        URDF_CYLINDER: 2,
        URDF_MESH: 3
    };
}, function(module, exports) {
    var g;
    g = function() {
        return this;
    }();
    try {
        g = g || Function("return this")() || (0, eval)("this");
    } catch (e) {
        "object" == typeof window && (g = window);
    }
    module.exports = g;
}, function(module, exports, __webpack_require__) {
    function Service(options) {
        options = options || {}, this.ros = options.ros, this.name = options.name, this.serviceType = options.serviceType,
        this.isAdvertised = !1, this._serviceCallback = null;
    }
    var ServiceResponse = __webpack_require__(22), EventEmitter2 = (__webpack_require__(7),
    __webpack_require__(3).EventEmitter2);
    Service.prototype.__proto__ = EventEmitter2.prototype, Service.prototype.callService = function(request, callback, failedCallback) {
        if (!this.isAdvertised) {
            var serviceCallId = "call_service:" + this.name + ":" + ++this.ros.idCounter;
            (callback || failedCallback) && this.ros.once(serviceCallId, function(message) {
                void 0 !== message.result && !1 === message.result ? "function" == typeof failedCallback && failedCallback(message.values) : "function" == typeof callback && callback(new ServiceResponse(message.values));
            });
            var call = {
                op: "call_service",
                id: serviceCallId,
                service: this.name,
                type: this.serviceType,
                args: request
            };
            this.ros.callOnConnection(call);
        }
    }, Service.prototype.advertise = function(callback) {
        this.isAdvertised || "function" != typeof callback || (this._serviceCallback = callback,
        this.ros.on(this.name, this._serviceResponse.bind(this)), this.ros.callOnConnection({
            op: "advertise_service",
            type: this.serviceType,
            service: this.name
        }), this.isAdvertised = !0);
    }, Service.prototype.unadvertise = function() {
        this.isAdvertised && (this.ros.callOnConnection({
            op: "unadvertise_service",
            service: this.name
        }), this.isAdvertised = !1);
    }, Service.prototype._serviceResponse = function(rosbridgeRequest) {
        var response = {}, success = this._serviceCallback(rosbridgeRequest.args, response), call = {
            op: "service_response",
            service: this.name,
            values: new ServiceResponse(response),
            result: success
        };
        rosbridgeRequest.id && (call.id = rosbridgeRequest.id), this.ros.callOnConnection(call);
    }, module.exports = Service;
}, function(module, exports) {
    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
    }
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout,
        setTimeout(fun, 0);
        try {
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout,
        clearTimeout(marker);
        try {
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    function cleanUpNextTick() {
        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
        queue.length && drainQueue());
    }
    function drainQueue() {
        if (!draining) {
            var timeout = runTimeout(cleanUpNextTick);
            draining = !0;
            for (var len = queue.length; len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, len = queue.length;
            }
            currentQueue = null, draining = !1, runClearTimeout(timeout);
        }
    }
    function Item(fun, array) {
        this.fun = fun, this.array = array;
    }
    function noop() {}
    var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
    !function() {
        try {
            cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    }();
    var currentQueue, queue = [], draining = !1, queueIndex = -1;
    process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
        queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
    }, Item.prototype.run = function() {
        this.fun.apply(null, this.array);
    }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [],
    process.version = "", process.versions = {}, process.on = noop, process.addListener = noop,
    process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop,
    process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop,
    process.listeners = function(name) {
        return [];
    }, process.binding = function(name) {
        throw new Error("process.binding is not supported");
    }, process.cwd = function() {
        return "/";
    }, process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
    }, process.umask = function() {
        return 0;
    };
}, function(module, exports) {
    module.exports = function(Ros, classes, features) {
        classes.forEach(function(className) {
            var Class = features[className];
            Ros.prototype[className] = function(options) {
                return options.ros = this, new Class(options);
            };
        });
    };
}, function(module, exports, __webpack_require__) {
    function Ros(options) {
        options = options || {}, this.socket = null, this.idCounter = 0, this.isConnected = !1,
        this.transportLibrary = options.transportLibrary || "websocket", this.transportOptions = options.transportOptions || {},
        void 0 === options.groovyCompatibility ? this.groovyCompatibility = !0 : this.groovyCompatibility = options.groovyCompatibility,
        this.setMaxListeners(0), options.url && this.connect(options.url);
    }
    var WebSocket = __webpack_require__(21), WorkerSocket = __webpack_require__(75), socketAdapter = __webpack_require__(78), Service = __webpack_require__(12), ServiceRequest = __webpack_require__(7), assign = __webpack_require__(2), EventEmitter2 = __webpack_require__(3).EventEmitter2;
    Ros.prototype.__proto__ = EventEmitter2.prototype, Ros.prototype.connect = function(url) {
        if ("socket.io" === this.transportLibrary) this.socket = assign(io(url, {
            "force new connection": !0
        }), socketAdapter(this)), this.socket.on("connect", this.socket.onopen), this.socket.on("data", this.socket.onmessage),
        this.socket.on("close", this.socket.onclose), this.socket.on("error", this.socket.onerror); else if ("RTCPeerConnection" === this.transportLibrary.constructor.name) this.socket = assign(this.transportLibrary.createDataChannel(url, this.transportOptions), socketAdapter(this)); else if ("websocket" === this.transportLibrary) {
            if (!this.socket || this.socket.readyState === WebSocket.CLOSED) {
                var sock = new WebSocket(url);
                sock.binaryType = "arraybuffer", this.socket = assign(sock, socketAdapter(this));
            }
        } else {
            if ("workersocket" !== this.transportLibrary) throw "Unknown transportLibrary: " + this.transportLibrary.toString();
            this.socket = assign(new WorkerSocket(url), socketAdapter(this));
        }
    }, Ros.prototype.close = function() {
        this.socket && this.socket.close();
    }, Ros.prototype.authenticate = function(mac, client, dest, rand, t, level, end) {
        var auth = {
            op: "auth",
            mac: mac,
            client: client,
            dest: dest,
            rand: rand,
            t: t,
            level: level,
            end: end
        };
        this.callOnConnection(auth);
    }, Ros.prototype.callOnConnection = function(message) {
        var that = this, messageJson = JSON.stringify(message), emitter = null;
        emitter = "socket.io" === this.transportLibrary ? function(msg) {
            that.socket.emit("operation", msg);
        } : function(msg) {
            that.socket.send(msg);
        }, this.isConnected ? emitter(messageJson) : that.once("connection", function() {
            emitter(messageJson);
        });
    }, Ros.prototype.setStatusLevel = function(level, id) {
        var levelMsg = {
            op: "set_level",
            level: level,
            id: id
        };
        this.callOnConnection(levelMsg);
    }, Ros.prototype.getActionServers = function(callback, failedCallback) {
        var getActionServers = new Service({
            ros: this,
            name: "/rosapi/action_servers",
            serviceType: "rosapi/GetActionServers"
        }), request = new ServiceRequest({});
        "function" == typeof failedCallback ? getActionServers.callService(request, function(result) {
            callback(result.action_servers);
        }, function(message) {
            failedCallback(message);
        }) : getActionServers.callService(request, function(result) {
            callback(result.action_servers);
        });
    }, Ros.prototype.getTopics = function(callback, failedCallback) {
        var topicsClient = new Service({
            ros: this,
            name: "/rosapi/topics",
            serviceType: "rosapi/Topics"
        }), request = new ServiceRequest();
        "function" == typeof failedCallback ? topicsClient.callService(request, function(result) {
            callback(result);
        }, function(message) {
            failedCallback(message);
        }) : topicsClient.callService(request, function(result) {
            callback(result);
        });
    }, Ros.prototype.getTopicsForType = function(topicType, callback, failedCallback) {
        var topicsForTypeClient = new Service({
            ros: this,
            name: "/rosapi/topics_for_type",
            serviceType: "rosapi/TopicsForType"
        }), request = new ServiceRequest({
            type: topicType
        });
        "function" == typeof failedCallback ? topicsForTypeClient.callService(request, function(result) {
            callback(result.topics);
        }, function(message) {
            failedCallback(message);
        }) : topicsForTypeClient.callService(request, function(result) {
            callback(result.topics);
        });
    }, Ros.prototype.getServices = function(callback, failedCallback) {
        var servicesClient = new Service({
            ros: this,
            name: "/rosapi/services",
            serviceType: "rosapi/Services"
        }), request = new ServiceRequest();
        "function" == typeof failedCallback ? servicesClient.callService(request, function(result) {
            callback(result.services);
        }, function(message) {
            failedCallback(message);
        }) : servicesClient.callService(request, function(result) {
            callback(result.services);
        });
    }, Ros.prototype.getServicesForType = function(serviceType, callback, failedCallback) {
        var servicesForTypeClient = new Service({
            ros: this,
            name: "/rosapi/services_for_type",
            serviceType: "rosapi/ServicesForType"
        }), request = new ServiceRequest({
            type: serviceType
        });
        "function" == typeof failedCallback ? servicesForTypeClient.callService(request, function(result) {
            callback(result.services);
        }, function(message) {
            failedCallback(message);
        }) : servicesForTypeClient.callService(request, function(result) {
            callback(result.services);
        });
    }, Ros.prototype.getServiceRequestDetails = function(type, callback, failedCallback) {
        var serviceTypeClient = new Service({
            ros: this,
            name: "/rosapi/service_request_details",
            serviceType: "rosapi/ServiceRequestDetails"
        }), request = new ServiceRequest({
            type: type
        });
        "function" == typeof failedCallback ? serviceTypeClient.callService(request, function(result) {
            callback(result);
        }, function(message) {
            failedCallback(message);
        }) : serviceTypeClient.callService(request, function(result) {
            callback(result);
        });
    }, Ros.prototype.getServiceResponseDetails = function(type, callback, failedCallback) {
        var serviceTypeClient = new Service({
            ros: this,
            name: "/rosapi/service_response_details",
            serviceType: "rosapi/ServiceResponseDetails"
        }), request = new ServiceRequest({
            type: type
        });
        "function" == typeof failedCallback ? serviceTypeClient.callService(request, function(result) {
            callback(result);
        }, function(message) {
            failedCallback(message);
        }) : serviceTypeClient.callService(request, function(result) {
            callback(result);
        });
    }, Ros.prototype.getNodes = function(callback, failedCallback) {
        var nodesClient = new Service({
            ros: this,
            name: "/rosapi/nodes",
            serviceType: "rosapi/Nodes"
        }), request = new ServiceRequest();
        "function" == typeof failedCallback ? nodesClient.callService(request, function(result) {
            callback(result.nodes);
        }, function(message) {
            failedCallback(message);
        }) : nodesClient.callService(request, function(result) {
            callback(result.nodes);
        });
    }, Ros.prototype.getNodeDetails = function(node, callback, failedCallback) {
        var nodesClient = new Service({
            ros: this,
            name: "/rosapi/node_details",
            serviceType: "rosapi/NodeDetails"
        }), request = new ServiceRequest({
            node: node
        });
        "function" == typeof failedCallback ? nodesClient.callService(request, function(result) {
            callback(result.subscribing, result.publishing, result.services);
        }, function(message) {
            failedCallback(message);
        }) : nodesClient.callService(request, function(result) {
            callback(result);
        });
    }, Ros.prototype.getParams = function(callback, failedCallback) {
        var paramsClient = new Service({
            ros: this,
            name: "/rosapi/get_param_names",
            serviceType: "rosapi/GetParamNames"
        }), request = new ServiceRequest();
        "function" == typeof failedCallback ? paramsClient.callService(request, function(result) {
            callback(result.names);
        }, function(message) {
            failedCallback(message);
        }) : paramsClient.callService(request, function(result) {
            callback(result.names);
        });
    }, Ros.prototype.getTopicType = function(topic, callback, failedCallback) {
        var topicTypeClient = new Service({
            ros: this,
            name: "/rosapi/topic_type",
            serviceType: "rosapi/TopicType"
        }), request = new ServiceRequest({
            topic: topic
        });
        "function" == typeof failedCallback ? topicTypeClient.callService(request, function(result) {
            callback(result.type);
        }, function(message) {
            failedCallback(message);
        }) : topicTypeClient.callService(request, function(result) {
            callback(result.type);
        });
    }, Ros.prototype.getServiceType = function(service, callback, failedCallback) {
        var serviceTypeClient = new Service({
            ros: this,
            name: "/rosapi/service_type",
            serviceType: "rosapi/ServiceType"
        }), request = new ServiceRequest({
            service: service
        });
        "function" == typeof failedCallback ? serviceTypeClient.callService(request, function(result) {
            callback(result.type);
        }, function(message) {
            failedCallback(message);
        }) : serviceTypeClient.callService(request, function(result) {
            callback(result.type);
        });
    }, Ros.prototype.getMessageDetails = function(message, callback, failedCallback) {
        var messageDetailClient = new Service({
            ros: this,
            name: "/rosapi/message_details",
            serviceType: "rosapi/MessageDetails"
        }), request = new ServiceRequest({
            type: message
        });
        "function" == typeof failedCallback ? messageDetailClient.callService(request, function(result) {
            callback(result.typedefs);
        }, function(message) {
            failedCallback(message);
        }) : messageDetailClient.callService(request, function(result) {
            callback(result.typedefs);
        });
    }, Ros.prototype.decodeTypeDefs = function(defs) {
        var that = this, decodeTypeDefsRec = function(theType, hints) {
            for (var typeDefDict = {}, i = 0; i < theType.fieldnames.length; i++) {
                var arrayLen = theType.fieldarraylen[i], fieldName = theType.fieldnames[i], fieldType = theType.fieldtypes[i];
                if (-1 === fieldType.indexOf("/")) typeDefDict[fieldName] = -1 === arrayLen ? fieldType : [ fieldType ]; else {
                    for (var sub = !1, j = 0; j < hints.length; j++) if (hints[j].type.toString() === fieldType.toString()) {
                        sub = hints[j];
                        break;
                    }
                    if (sub) {
                        var subResult = decodeTypeDefsRec(sub, hints);
                        -1 === arrayLen || (typeDefDict[fieldName] = [ subResult ]);
                    } else that.emit("error", "Cannot find " + fieldType + " in decodeTypeDefs");
                }
            }
            return typeDefDict;
        };
        return decodeTypeDefsRec(defs[0], defs);
    }, Ros.prototype.getTopicsAndRawTypes = function(callback, failedCallback) {
        var topicsAndRawTypesClient = new Service({
            ros: this,
            name: "/rosapi/topics_and_raw_types",
            serviceType: "rosapi/TopicsAndRawTypes"
        }), request = new ServiceRequest();
        "function" == typeof failedCallback ? topicsAndRawTypesClient.callService(request, function(result) {
            callback(result);
        }, function(message) {
            failedCallback(message);
        }) : topicsAndRawTypesClient.callService(request, function(result) {
            callback(result);
        });
    }, module.exports = Ros;
}, function(module, exports, __webpack_require__) {
    function Pose(options) {
        options = options || {}, this.position = new Vector3(options.position), this.orientation = new Quaternion(options.orientation);
    }
    var Vector3 = __webpack_require__(4), Quaternion = __webpack_require__(9);
    Pose.prototype.applyTransform = function(tf) {
        this.position.multiplyQuaternion(tf.rotation), this.position.add(tf.translation);
        var tmp = tf.rotation.clone();
        tmp.multiply(this.orientation), this.orientation = tmp;
    }, Pose.prototype.clone = function() {
        return new Pose(this);
    }, Pose.prototype.multiply = function(pose) {
        var p = pose.clone();
        return p.applyTransform({
            rotation: this.orientation,
            translation: this.position
        }), p;
    }, Pose.prototype.getInverse = function() {
        var inverse = this.clone();
        return inverse.orientation.invert(), inverse.position.multiplyQuaternion(inverse.orientation),
        inverse.position.x *= -1, inverse.position.y *= -1, inverse.position.z *= -1, inverse;
    }, module.exports = Pose;
}, function(module, exports, __webpack_require__) {
    function UrdfMaterial(options) {
        this.textureFilename = null, this.color = null, this.name = options.xml.getAttribute("name");
        var textures = options.xml.getElementsByTagName("texture");
        textures.length > 0 && (this.textureFilename = textures[0].getAttribute("filename"));
        var colors = options.xml.getElementsByTagName("color");
        colors.length > 0 && (this.color = new UrdfColor({
            xml: colors[0]
        }));
    }
    var UrdfColor = __webpack_require__(27);
    UrdfMaterial.prototype.isLink = function() {
        return null === this.color && null === this.textureFilename;
    };
    var assign = __webpack_require__(2);
    UrdfMaterial.prototype.assign = function(obj) {
        return assign(this, obj);
    }, module.exports = UrdfMaterial;
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
    !function(global, factory) {
        "use strict";
        "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
            if (!w.document) throw new Error("jQuery requires a window with a document");
            return factory(w);
        } : factory(global);
    }("undefined" != typeof window ? window : this, function(window, noGlobal) {
        "use strict";
        function DOMEval(code, node, doc) {
            doc = doc || document;
            var i, val, script = doc.createElement("script");
            if (script.text = code, node) for (i in preservedScriptAttributes) (val = node[i] || node.getAttribute && node.getAttribute(i)) && script.setAttribute(i, val);
            doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        function isArrayLike(obj) {
            var length = !!obj && "length" in obj && obj.length, type = toType(obj);
            return !isFunction(obj) && !isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj);
        }
        function nodeName(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        function winnow(elements, qualifier, not) {
            return isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            }) : jQuery.filter(qualifier, elements, not);
        }
        function sibling(cur, dir) {
            for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
            return cur;
        }
        function createOptions(options) {
            var object = {};
            return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                object[flag] = !0;
            }), object;
        }
        function Identity(v) {
            return v;
        }
        function Thrower(ex) {
            throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
            var method;
            try {
                value && isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [ value ].slice(noValue));
            } catch (value) {
                reject.apply(void 0, [ value ]);
            }
        }
        function completed() {
            document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed),
            jQuery.ready();
        }
        function fcamelCase(all, letter) {
            return letter.toUpperCase();
        }
        function camelCase(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        function Data() {
            this.expando = jQuery.expando + Data.uid++;
        }
        function getData(data) {
            return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data);
        }
        function dataAttr(elem, key, data) {
            var name;
            if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(),
            "string" == typeof (data = elem.getAttribute(name))) {
                try {
                    data = getData(data);
                } catch (e) {}
                dataUser.set(elem, key, data);
            } else data = void 0;
            return data;
        }
        function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
                return tween.cur();
            } : function() {
                return jQuery.css(elem, prop, "");
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
                for (initial /= 2, unit = unit || initialInUnit[3], initialInUnit = +initial || 1; maxIterations--; ) jQuery.style(elem, prop, initialInUnit + unit),
                (1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0 && (maxIterations = 0),
                initialInUnit /= scale;
                initialInUnit *= 2, jQuery.style(elem, prop, initialInUnit + unit), valueParts = valueParts || [];
            }
            return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2],
            tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)),
            adjusted;
        }
        function getDefaultDisplay(elem) {
            var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
            return display || (temp = doc.body.appendChild(doc.createElement(nodeName)), display = jQuery.css(temp, "display"),
            temp.parentNode.removeChild(temp), "none" === display && (display = "block"), defaultDisplayMap[nodeName] = display,
            display);
        }
        function showHide(elements, show) {
            for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++) elem = elements[index],
            elem.style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null,
            values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none",
            dataPriv.set(elem, "display", display)));
            for (index = 0; index < length; index++) null != values[index] && (elements[index].style.display = values[index]);
            return elements;
        }
        function getAll(context, tag) {
            var ret;
            return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [],
            void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
        }
        function setGlobalEval(elems, refElements) {
            for (var i = 0, l = elems.length; i < l; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
        function buildFragment(elems, context, scripts, selection, ignored) {
            for (var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++) if ((elem = elems[i]) || 0 === elem) if ("object" === toType(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
                for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(),
                wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2],
                j = wrap[0]; j--; ) tmp = tmp.lastChild;
                jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
            } else nodes.push(context.createTextNode(elem));
            for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem); else if (attached = isAttached(elem),
            tmp = getAll(fragment.appendChild(elem), "script"), attached && setGlobalEval(tmp),
            scripts) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
            return fragment;
        }
        function returnTrue() {
            return !0;
        }
        function returnFalse() {
            return !1;
        }
        function expectSync(elem, type) {
            return elem === safeActiveElement() == ("focus" === type);
        }
        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch (err) {}
        }
        function on(elem, types, selector, data, fn, one) {
            var origFn, type;
            if ("object" == typeof types) {
                "string" != typeof selector && (data = data || selector, selector = void 0);
                for (type in types) on(elem, type, selector, data, types[type], one);
                return elem;
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data,
            data = void 0) : (fn = data, data = selector, selector = void 0)), !1 === fn) fn = returnFalse; else if (!fn) return elem;
            return 1 === one && (origFn = fn, fn = function(event) {
                return jQuery().off(event), origFn.apply(this, arguments);
            }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        }
        function leverageNative(el, type, expectSync) {
            if (!expectSync) return void (void 0 === dataPriv.get(el, type) && jQuery.event.add(el, type, returnTrue));
            dataPriv.set(el, type, !1), jQuery.event.add(el, type, {
                namespace: !1,
                handler: function(event) {
                    var notAsync, result, saved = dataPriv.get(this, type);
                    if (1 & event.isTrigger && this[type]) {
                        if (saved.length) (jQuery.event.special[type] || {}).delegateType && event.stopPropagation(); else if (saved = slice.call(arguments),
                        dataPriv.set(this, type, saved), notAsync = expectSync(this, type), this[type](),
                        result = dataPriv.get(this, type), saved !== result || notAsync ? dataPriv.set(this, type, !1) : result = {},
                        saved !== result) return event.stopImmediatePropagation(), event.preventDefault(),
                        result.value;
                    } else saved.length && (dataPriv.set(this, type, {
                        value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                    }), event.stopImmediatePropagation());
                }
            });
        }
        function manipulationTarget(elem, content) {
            return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? jQuery(elem).children("tbody")[0] || elem : elem;
        }
        function disableScript(elem) {
            return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
        }
        function restoreScript(elem) {
            return "true/" === (elem.type || "").slice(0, 5) ? elem.type = elem.type.slice(5) : elem.removeAttribute("type"),
            elem;
        }
        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (1 === dest.nodeType) {
                if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld),
                events = pdataOld.events)) {
                    delete pdataCur.handle, pdataCur.events = {};
                    for (type in events) for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
                }
                dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld),
                dataUser.set(dest, udataCur));
            }
        }
        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue);
        }
        function domManip(collection, args, callback, ignored) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
            if (valueIsFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
                var self = collection.eq(index);
                valueIsFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored);
            });
            if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored),
            first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first),
            first || ignored)) {
                for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; i < l; i++) node = fragment,
                i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))),
                callback.call(collection[i], node, i);
                if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript),
                i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src && "module" !== (node.type || "").toLowerCase() ? jQuery._evalUrl && !node.noModule && jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                }) : DOMEval(node.textContent.replace(rcleanScript, ""), node, doc));
            }
            return collection;
        }
        function remove(elem, selector, keepData) {
            for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)),
            node.parentNode && (keepData && isAttached(node) && setGlobalEval(getAll(node, "script")),
            node.parentNode.removeChild(node));
            return elem;
        }
        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name],
            "" !== ret || isAttached(elem) || (ret = jQuery.style(elem, name)), !support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name) && (width = style.width,
            minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret,
            ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)),
            void 0 !== ret ? ret + "" : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function() {
                    return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments);
                }
            };
        }
        function vendorPropName(name) {
            for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; ) if ((name = cssPrefixes[i] + capName) in emptyStyle) return name;
        }
        function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name];
            return final || (name in emptyStyle ? name : vendorProps[name] = vendorPropName(name) || name);
        }
        function setPositiveNumber(elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
            var i = "width" === dimension ? 1 : 0, extra = 0, delta = 0;
            if (box === (isBorderBox ? "border" : "content")) return 0;
            for (;i < 4; i += 2) "margin" === box && (delta += jQuery.css(elem, box + cssExpand[i], !0, styles)),
            isBorderBox ? ("content" === box && (delta -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)),
            "margin" !== box && (delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (delta += jQuery.css(elem, "padding" + cssExpand[i], !0, styles),
            "padding" !== box ? delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles) : extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles));
            return !isBorderBox && computedVal >= 0 && (delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5)) || 0),
            delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
            var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && "border-box" === jQuery.css(elem, "boxSizing", !1, styles), valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
            if (rnumnonpx.test(val)) {
                if (!extra) return val;
                val = "auto";
            }
            return (!support.boxSizingReliable() && isBorderBox || "auto" === val || !parseFloat(val) && "inline" === jQuery.css(elem, "display", !1, styles)) && elem.getClientRects().length && (isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles),
            (valueIsBorderBox = offsetProp in elem) && (val = elem[offsetProp])), (val = parseFloat(val) || 0) + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
        }
        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        function schedule() {
            inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval),
            jQuery.fx.tick());
        }
        function createFxNow() {
            return window.setTimeout(function() {
                fxNow = void 0;
            }), fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
            var which, i = 0, attrs = {
                height: type
            };
            for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) which = cssExpand[i],
            attrs["margin" + which] = attrs["padding" + which] = type;
            return includeWidth && (attrs.opacity = attrs.width = type), attrs;
        }
        function createTween(value, prop, animation) {
            for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
        }
        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
            opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0,
            oldfire = hooks.empty.fire, hooks.empty.fire = function() {
                hooks.unqueued || oldfire();
            }), hooks.unqueued++, anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
                });
            }));
            for (prop in props) if (value = props[prop], rfxtypes.test(value)) {
                if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                    if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                    hidden = !0;
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
            if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig)) {
                isBox && 1 === elem.nodeType && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ],
                restoreDisplay = dataShow && dataShow.display, null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")),
                display = jQuery.css(elem, "display"), "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([ elem ], !0),
                restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"),
                showHide([ elem ]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                    style.display = restoreDisplay;
                }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)),
                style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function() {
                    style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
                })), propTween = !1;
                for (prop in orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                }), toggle && (dataShow.hidden = !hidden), hidden && showHide([ elem ], !0), anim.done(function() {
                    hidden || showHide([ elem ]), dataPriv.remove(elem, "fxshow");
                    for (prop in orig) jQuery.style(elem, prop, orig[prop]);
                })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start,
                hidden && (propTween.end = propTween.start, propTween.start = 0));
            }
        }
        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) if (name = camelCase(index), easing = specialEasing[name],
            value = props[index], Array.isArray(value) && (easing = value[1], value = props[index] = value[0]),
            index !== name && (props[name] = value, delete props[index]), (hooks = jQuery.cssHooks[name]) && "expand" in hooks) {
                value = hooks.expand(value), delete props[name];
                for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
            } else specialEasing[name] = easing;
        }
        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
                delete tick.elem;
            }), tick = function() {
                if (stopped) return !1;
                for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
                return deferred.notifyWith(elem, [ animation, percent, remaining ]), percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [ animation, 1, 0 ]),
                deferred.resolveWith(elem, [ animation ]), !1);
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(!0, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    return animation.tweens.push(tween), tween;
                },
                stop: function(gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) return this;
                    for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
                    return gotoEnd ? (deferred.notifyWith(elem, [ animation, 1, 0 ]), deferred.resolveWith(elem, [ animation, gotoEnd ])) : deferred.rejectWith(elem, [ animation, gotoEnd ]),
                    this;
                }
            }), props = animation.props;
            for (propFilter(props, animation.opts.specialEasing); index < length; index++) if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result)),
            result;
            return jQuery.map(props, createTween, animation), isFunction(animation.opts.start) && animation.opts.start.call(elem, animation),
            animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always),
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })), animation;
        }
        function stripAndCollapse(value) {
            return (value.match(rnothtmlwhite) || []).join(" ");
        }
        function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
            return Array.isArray(value) ? value : "string" == typeof value ? value.match(rnothtmlwhite) || [] : [];
        }
        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (Array.isArray(obj)) jQuery.each(obj, function(i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add);
            }); else if (traditional || "object" !== toType(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
                if (isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*",
                (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
            };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            function inspect(dataType) {
                var selected;
                return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport),
                    inspect(dataTypeOrTransport), !1);
                }), selected;
            }
            var inspected = {}, seekingTransport = structure === transports;
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
            return deep && jQuery.extend(!0, target, deep), target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
            for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(),
            void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
            if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
            }
            if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                        finalDataType = type;
                        break;
                    }
                    firstDataType || (firstDataType = type);
                }
                finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType),
            responses[finalDataType];
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
            if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
            for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response),
            !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)),
            prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
                if (!(conv = converters[prev + " " + current] || converters["* " + current])) for (conv2 in converters) if (tmp = conv2.split(" "),
                tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                    !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0],
                    dataTypes.unshift(tmp[1]));
                    break;
                }
                if (!0 !== conv) if (conv && s.throws) response = conv(response); else try {
                    response = conv(response);
                } catch (e) {
                    return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                }
            }
            return {
                state: "success",
                data: response
            };
        }
        var arr = [], document = window.document, getProto = Object.getPrototypeOf, slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, fnToString = hasOwn.toString, ObjectFunctionString = fnToString.call(Object), support = {}, isFunction = function(obj) {
            return "function" == typeof obj && "number" != typeof obj.nodeType;
        }, isWindow = function(obj) {
            return null != obj && obj === obj.window;
        }, preservedScriptAttributes = {
            type: !0,
            src: !0,
            nonce: !0,
            noModule: !0
        }, jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery.fn = jQuery.prototype = {
            jquery: "3.4.1",
            constructor: jQuery,
            length: 0,
            toArray: function() {
                return slice.call(this);
            },
            get: function(num) {
                return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num];
            },
            pushStack: function(elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this, ret;
            },
            each: function(callback) {
                return jQuery.each(this, callback);
            },
            map: function(callback) {
                return this.pushStack(jQuery.map(this, function(elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            slice: function() {
                return this.pushStack(slice.apply(this, arguments));
            },
            first: function() {
                return this.eq(0);
            },
            last: function() {
                return this.eq(-1);
            },
            eq: function(i) {
                var len = this.length, j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
            },
            end: function() {
                return this.prevObject || this.constructor();
            },
            push: push,
            sort: arr.sort,
            splice: arr.splice
        }, jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[i] || {},
            i++), "object" == typeof target || isFunction(target) || (target = {}), i === length && (target = this,
            i--); i < length; i++) if (null != (options = arguments[i])) for (name in options) copy = options[name],
            "__proto__" !== name && target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (src = target[name],
            clone = copyIsArray && !Array.isArray(src) ? [] : copyIsArray || jQuery.isPlainObject(src) ? src : {},
            copyIsArray = !1, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target;
        }, jQuery.extend({
            expando: "jQuery" + ("3.4.1" + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(msg) {
                throw new Error(msg);
            },
            noop: function() {},
            isPlainObject: function(obj) {
                var proto, Ctor;
                return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || "function" == typeof (Ctor = hasOwn.call(proto, "constructor") && proto.constructor) && fnToString.call(Ctor) === ObjectFunctionString);
            },
            isEmptyObject: function(obj) {
                var name;
                for (name in obj) return !1;
                return !0;
            },
            globalEval: function(code, options) {
                DOMEval(code, {
                    nonce: options && options.nonce
                });
            },
            each: function(obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj)) for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++) ; else for (i in obj) if (!1 === callback.call(obj[i], i, obj[i])) break;
                return obj;
            },
            trim: function(text) {
                return null == text ? "" : (text + "").replace(rtrim, "");
            },
            makeArray: function(arr, results) {
                var ret = results || [];
                return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)),
                ret;
            },
            inArray: function(elem, arr, i) {
                return null == arr ? -1 : indexOf.call(arr, elem, i);
            },
            merge: function(first, second) {
                for (var len = +second.length, j = 0, i = first.length; j < len; j++) first[i++] = second[j];
                return first.length = i, first;
            },
            grep: function(elems, callback, invert) {
                for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
                return matches;
            },
            map: function(elems, callback, arg) {
                var length, value, i = 0, ret = [];
                if (isArrayLike(elems)) for (length = elems.length; i < length; i++) null != (value = callback(elems[i], i, arg)) && ret.push(value); else for (i in elems) null != (value = callback(elems[i], i, arg)) && ret.push(value);
                return concat.apply([], ret);
            },
            guid: 1,
            support: support
        }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]),
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });
        var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
        function(window) {
            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
                if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
                if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context),
                context = context || document, documentIsHTML)) {
                    if (11 !== nodeType && (match = rquickExpr.exec(selector))) if (m = match[1]) {
                        if (9 === nodeType) {
                            if (!(elem = context.getElementById(m))) return results;
                            if (elem.id === m) return results.push(elem), results;
                        } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem),
                        results;
                    } else {
                        if (match[2]) return push.apply(results, context.getElementsByTagName(selector)),
                        results;
                        if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)),
                        results;
                    }
                    if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (1 !== nodeType || "object" !== context.nodeName.toLowerCase())) {
                        if (newSelector = selector, newContext = context, 1 === nodeType && rdescend.test(selector)) {
                            for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando),
                            groups = tokenize(selector), i = groups.length; i--; ) groups[i] = "#" + nid + " " + toSelector(groups[i]);
                            newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, !0);
                        } finally {
                            nid === expando && context.removeAttribute("id");
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }
            function createCache() {
                function cache(key, value) {
                    return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
                }
                var keys = [];
                return cache;
            }
            function markFunction(fn) {
                return fn[expando] = !0, fn;
            }
            function assert(fn) {
                var el = document.createElement("fieldset");
                try {
                    return !!fn(el);
                } catch (e) {
                    return !1;
                } finally {
                    el.parentNode && el.parentNode.removeChild(el), el = null;
                }
            }
            function addHandle(attrs, handler) {
                for (var arr = attrs.split("|"), i = arr.length; i--; ) Expr.attrHandle[arr[i]] = handler;
            }
            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
                if (diff) return diff;
                if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
                return a ? 1 : -1;
            }
            function createDisabledPseudo(disabled) {
                return function(elem) {
                    return "form" in elem ? elem.parentNode && !1 === elem.disabled ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled : elem.disabled === disabled : "label" in elem && elem.disabled === disabled;
                };
            }
            function createPositionalPseudo(fn) {
                return markFunction(function(argument) {
                    return argument = +argument, markFunction(function(seed, matches) {
                        for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                    });
                });
            }
            function testContext(context) {
                return context && void 0 !== context.getElementsByTagName && context;
            }
            function setFilters() {}
            function toSelector(tokens) {
                for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
                return selector;
            }
            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && "parentNode" === key, doneName = done++;
                return combinator.first ? function(elem, context, xml) {
                    for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
                    return !1;
                } : function(elem, context, xml) {
                    var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                    if (xml) {
                        for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                    } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) if (outerCache = elem[expando] || (elem[expando] = {}),
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem; else {
                        if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                        if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                    }
                    return !1;
                };
            }
            function elementMatcher(matchers) {
                return matchers.length > 1 ? function(elem, context, xml) {
                    for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                    return !0;
                } : matchers[0];
            }
            function multipleContexts(selector, contexts, results) {
                for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
                return results;
            }
            function condense(unmatched, map, filter, context, xml) {
                for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++) (elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem),
                mapped && map.push(i)));
                return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)),
                postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)),
                markFunction(function(seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap),
                    postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                postFinder(null, matcherOut = [], temp, xml);
                            }
                            for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                        }
                    } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut),
                    postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
                });
            }
            function matcherFromTokens(tokens) {
                for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                    return elem === checkContext;
                }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    return checkContext = null, ret;
                } ]; i < len; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                    if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                        for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++) ;
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: " " === tokens[i - 2].type ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
                return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                    for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                        if (byElement && elem) {
                            for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++]; ) if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break;
                            }
                            outermost && (dirruns = dirrunsUnique);
                        }
                        bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
                    }
                    if (matchedCount += i, bySet && i !== matchedCount) {
                        for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                        if (seed) {
                            if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                    }
                    return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup),
                    unmatched;
                };
                return bySet ? markFunction(superMatcher) : superMatcher;
            }
            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
                return a === b && (hasDuplicate = !0), 0;
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
                for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;
                return -1;
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                ID: new RegExp("^#(" + identifier + ")"),
                CLASS: new RegExp("^\\.(" + identifier + ")"),
                TAG: new RegExp("^(" + identifier + "|[*])"),
                ATTR: new RegExp("^" + attributes),
                PSEUDO: new RegExp("^" + pseudos),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + booleans + ")$", "i"),
                needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
                return asCodePoint ? "\0" === ch ? "" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch;
            }, unloadHandler = function() {
                setDocument();
            }, inDisabledFieldset = addCombinator(function(elem) {
                return !0 === elem.disabled && "fieldset" === elem.nodeName.toLowerCase();
            }, {
                dir: "parentNode",
                next: "legend"
            });
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes),
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ? function(target, els) {
                        push_native.apply(target, slice.call(els));
                    } : function(target, els) {
                        for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                        target.length = j - 1;
                    }
                };
            }
            support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
                var namespace = elem.namespaceURI, docElem = (elem.ownerDocument || elem).documentElement;
                return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
            }, setDocument = Sizzle.setDocument = function(node) {
                var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc,
                docElem = document.documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)),
                support.attributes = assert(function(el) {
                    return el.className = "i", !el.getAttribute("className");
                }), support.getElementsByTagName = assert(function(el) {
                    return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length;
                }), support.getElementsByClassName = rnative.test(document.getElementsByClassName),
                support.getById = assert(function(el) {
                    return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length;
                }), support.getById ? (Expr.filter.ID = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                }, Expr.find.ID = function(id, context) {
                    if (void 0 !== context.getElementById && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [ elem ] : [];
                    }
                }) : (Expr.filter.ID = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                }, Expr.find.ID = function(id, context) {
                    if (void 0 !== context.getElementById && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            if ((node = elem.getAttributeNode("id")) && node.value === id) return [ elem ];
                            for (elems = context.getElementsByName(id), i = 0; elem = elems[i++]; ) if ((node = elem.getAttributeNode("id")) && node.value === id) return [ elem ];
                        }
                        return [];
                    }
                }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                    return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0;
                } : function(tag, context) {
                    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                    if ("*" === tag) {
                        for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                        return tmp;
                    }
                    return results;
                }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                    if (void 0 !== context.getElementsByClassName && documentIsHTML) return context.getElementsByClassName(className);
                }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                    el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"),
                    el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"),
                    el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"),
                    el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
                }), assert(function(el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"),
                    el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="),
                    2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                    docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                    el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
                })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                    support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"),
                    rbuggyMatches.push("!=", pseudos);
                }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")),
                hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                    var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                    return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
                } : function(a, b) {
                    if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                    return !1;
                }, sortOrder = hasCompare ? function(a, b) {
                    if (a === b) return hasDuplicate = !0, 0;
                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                    return compare || (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1,
                    1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1);
                } : function(a, b) {
                    if (a === b) return hasDuplicate = !0, 0;
                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                    if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                    if (aup === bup) return siblingCheck(a, b);
                    for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                    for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                    for (;ap[i] === bp[i]; ) i++;
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                }, document) : document;
            }, Sizzle.matches = function(expr, elements) {
                return Sizzle(expr, null, null, elements);
            }, Sizzle.matchesSelector = function(elem, expr) {
                if ((elem.ownerDocument || elem) !== document && setDocument(elem), support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
                } catch (e) {
                    nonnativeSelectorCache(expr, !0);
                }
                return Sizzle(expr, document, null, [ elem ]).length > 0;
            }, Sizzle.contains = function(context, elem) {
                return (context.ownerDocument || context) !== document && setDocument(context),
                contains(context, elem);
            }, Sizzle.attr = function(elem, name) {
                (elem.ownerDocument || elem) !== document && setDocument(elem);
                var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }, Sizzle.escape = function(sel) {
                return (sel + "").replace(rcssescape, fcssescape);
            }, Sizzle.error = function(msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            }, Sizzle.uniqueSort = function(results) {
                var elem, duplicates = [], j = 0, i = 0;
                if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0),
                results.sort(sortOrder), hasDuplicate) {
                    for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                    for (;j--; ) results.splice(duplicates[j], 1);
                }
                return sortInput = null, results;
            }, getText = Sizzle.getText = function(elem) {
                var node, ret = "", i = 0, nodeType = elem.nodeType;
                if (nodeType) {
                    if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                        if ("string" == typeof elem.textContent) return elem.textContent;
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                    } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
                } else for (;node = elem[i++]; ) ret += getText(node);
                return ret;
            }, Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function(match) {
                        return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape),
                        "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                    },
                    CHILD: function(match) {
                        return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]),
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])),
                        match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]),
                        match;
                    },
                    PSEUDO: function(match) {
                        var excess, unquoted = !match[6] && match[2];
                        return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess),
                        match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                    }
                },
                filter: {
                    TAG: function(nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return "*" === nodeNameSelector ? function() {
                            return !0;
                        } : function(elem) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                        };
                    },
                    CLASS: function(className) {
                        var pattern = classCache[className + " "];
                        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                            return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "");
                        });
                    },
                    ATTR: function(name, operator, check) {
                        return function(elem) {
                            var result = Sizzle.attr(elem, name);
                            return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"));
                        };
                    },
                    CHILD: function(type, what, argument, first, last) {
                        var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                        return 1 === first && 0 === last ? function(elem) {
                            return !!elem.parentNode;
                        } : function(elem, context, xml) {
                            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                            if (parent) {
                                if (simple) {
                                    for (;dir; ) {
                                        for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                        start = dir = "only" === type && !start && "nextSibling";
                                    }
                                    return !0;
                                }
                                if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                    for (node = parent, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}),
                                    cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex && cache[2],
                                    node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                        uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                } else if (useCache && (node = elem, outerCache = node[expando] || (node[expando] = {}),
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [],
                                nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex), !1 === diff) for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}),
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), uniqueCache[type] = [ dirruns, diff ]),
                                node !== elem)); ) ;
                                return (diff -= last) === first || diff % first == 0 && diff / first >= 0;
                            }
                        };
                    },
                    PSEUDO: function(pseudo, argument) {
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                        return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ],
                        Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]),
                            seed[idx] = !(matches[idx] = matched[i]);
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        }) : fn;
                    }
                },
                pseudos: {
                    not: markFunction(function(selector) {
                        var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                        return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                            for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                        }) : function(elem, context, xml) {
                            return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
                        };
                    }),
                    has: markFunction(function(selector) {
                        return function(elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),
                    contains: markFunction(function(text) {
                        return text = text.replace(runescape, funescape), function(elem) {
                            return (elem.textContent || getText(elem)).indexOf(text) > -1;
                        };
                    }),
                    lang: markFunction(function(lang) {
                        return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang),
                        lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                            var elemLang;
                            do {
                                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-");
                            } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                            return !1;
                        };
                    }),
                    target: function(elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },
                    root: function(elem) {
                        return elem === docElem;
                    },
                    focus: function(elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },
                    enabled: createDisabledPseudo(!1),
                    disabled: createDisabledPseudo(!0),
                    checked: function(elem) {
                        var nodeName = elem.nodeName.toLowerCase();
                        return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                    },
                    selected: function(elem) {
                        return elem.parentNode && elem.parentNode.selectedIndex, !0 === elem.selected;
                    },
                    empty: function(elem) {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                        return !0;
                    },
                    parent: function(elem) {
                        return !Expr.pseudos.empty(elem);
                    },
                    header: function(elem) {
                        return rheader.test(elem.nodeName);
                    },
                    input: function(elem) {
                        return rinputs.test(elem.nodeName);
                    },
                    button: function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return "input" === name && "button" === elem.type || "button" === name;
                    },
                    text: function(elem) {
                        var attr;
                        return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                    },
                    first: createPositionalPseudo(function() {
                        return [ 0 ];
                    }),
                    last: createPositionalPseudo(function(matchIndexes, length) {
                        return [ length - 1 ];
                    }),
                    eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                        return [ argument < 0 ? argument + length : argument ];
                    }),
                    even: createPositionalPseudo(function(matchIndexes, length) {
                        for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                        return matchIndexes;
                    }),
                    odd: createPositionalPseudo(function(matchIndexes, length) {
                        for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                        return matchIndexes;
                    }),
                    lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                        for (var i = argument < 0 ? argument + length : argument > length ? length : argument; --i >= 0; ) matchIndexes.push(i);
                        return matchIndexes;
                    }),
                    gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                        for (var i = argument < 0 ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                        return matchIndexes;
                    })
                }
            }, Expr.pseudos.nth = Expr.pseudos.eq;
            for (i in {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) Expr.pseudos[i] = function(type) {
                return function(elem) {
                    return "input" === elem.nodeName.toLowerCase() && elem.type === type;
                };
            }(i);
            for (i in {
                submit: !0,
                reset: !0
            }) Expr.pseudos[i] = function(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type;
                };
            }(i);
            return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(),
            tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) return parseOnly ? 0 : cached.slice(0);
                for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                    matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar),
                    groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(),
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    }), soFar = soFar.slice(matched.length));
                    for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(),
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }), soFar = soFar.slice(matched.length));
                    if (!matched) break;
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
            }, compile = Sizzle.compile = function(selector, match) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                if (!cached) {
                    for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]),
                    cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)),
                    cached.selector = selector;
                }
                return cached;
            }, select = Sizzle.select = function(selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                if (results = results || [], 1 === match.length) {
                    if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                        if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0])) return results;
                        compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                    }
                    for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i],
                    !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                        if (tokens.splice(i, 1), !(selector = seed.length && toSelector(tokens))) return push.apply(results, seed),
                        results;
                        break;
                    }
                }
                return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context),
                results;
            }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando,
            support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(el) {
                return 1 & el.compareDocumentPosition(document.createElement("fieldset"));
            }), assert(function(el) {
                return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href");
            }) || addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
            }), support.attributes && assert(function(el) {
                return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value");
            }) || addHandle("value", function(elem, name, isXML) {
                if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue;
            }), assert(function(el) {
                return null == el.getAttribute("disabled");
            }) || addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }), Sizzle;
        }(window);
        jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos,
        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText,
        jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir, until) {
            for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
                if (truncate && jQuery(elem).is(until)) break;
                matched.push(elem);
            }
            return matched;
        }, siblings = function(n, elem) {
            for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
            return matched;
        }, rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        jQuery.filter = function(expr, elems, not) {
            var elem = elems[0];
            return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                return 1 === elem.nodeType;
            }));
        }, jQuery.fn.extend({
            find: function(selector) {
                var i, ret, len = this.length, self = this;
                if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) if (jQuery.contains(self[i], this)) return !0;
                }));
                for (ret = this.pushStack([]), i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
                return len > 1 ? jQuery.uniqueSort(ret) : ret;
            },
            filter: function(selector) {
                return this.pushStack(winnow(this, selector || [], !1));
            },
            not: function(selector) {
                return this.pushStack(winnow(this, selector || [], !0));
            },
            is: function(selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (jQuery.fn.init = function(selector, context, root) {
            var match, elem;
            if (!selector) return this;
            if (root = root || rootjQuery, "string" == typeof selector) {
                if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector)) || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
                if (match[1]) {
                    if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)),
                    rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                    return this;
                }
                return elem = document.getElementById(match[2]), elem && (this[0] = elem, this.length = 1),
                this;
            }
            return selector.nodeType ? (this[0] = selector, this.length = 1, this) : isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this);
        }).prototype = jQuery.fn, rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
        jQuery.fn.extend({
            has: function(target) {
                var targets = jQuery(target, this), l = targets.length;
                return this.filter(function() {
                    for (var i = 0; i < l; i++) if (jQuery.contains(this, targets[i])) return !0;
                });
            },
            closest: function(selectors, context) {
                var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
                if (!rneedsContext.test(selectors)) for (;i < l; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                }
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
            },
            index: function(elem) {
                return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            },
            add: function(selector, context) {
                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
            },
            addBack: function(selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
            }
        }), jQuery.each({
            parent: function(elem) {
                var parent = elem.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null;
            },
            parents: function(elem) {
                return dir(elem, "parentNode");
            },
            parentsUntil: function(elem, i, until) {
                return dir(elem, "parentNode", until);
            },
            next: function(elem) {
                return sibling(elem, "nextSibling");
            },
            prev: function(elem) {
                return sibling(elem, "previousSibling");
            },
            nextAll: function(elem) {
                return dir(elem, "nextSibling");
            },
            prevAll: function(elem) {
                return dir(elem, "previousSibling");
            },
            nextUntil: function(elem, i, until) {
                return dir(elem, "nextSibling", until);
            },
            prevUntil: function(elem, i, until) {
                return dir(elem, "previousSibling", until);
            },
            siblings: function(elem) {
                return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function(elem) {
                return siblings(elem.firstChild);
            },
            contents: function(elem) {
                return void 0 !== elem.contentDocument ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem),
                jQuery.merge([], elem.childNodes));
            }
        }, function(name, fn) {
            jQuery.fn[name] = function(until, selector) {
                var matched = jQuery.map(this, fn, until);
                return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)),
                this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()),
                this.pushStack(matched);
            };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        jQuery.Callbacks = function(options) {
            options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
            var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
                for (locked = locked || options.once, fired = firing = !0; queue.length; firingIndex = -1) for (memory = queue.shift(); ++firingIndex < list.length; ) !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length,
                memory = !1);
                options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "");
            }, self = {
                add: function() {
                    return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)),
                    function add(args) {
                        jQuery.each(args, function(_, arg) {
                            isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== toType(arg) && add(arg);
                        });
                    }(arguments), memory && !firing && fire()), this;
                },
                remove: function() {
                    return jQuery.each(arguments, function(_, arg) {
                        for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1),
                        index <= firingIndex && firingIndex--;
                    }), this;
                },
                has: function(fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function() {
                    return list && (list = []), this;
                },
                disable: function() {
                    return locked = queue = [], list = memory = "", this;
                },
                disabled: function() {
                    return !list;
                },
                lock: function() {
                    return locked = queue = [], memory || firing || (list = memory = ""), this;
                },
                locked: function() {
                    return !!locked;
                },
                fireWith: function(context, args) {
                    return locked || (args = args || [], args = [ context, args.slice ? args.slice() : args ],
                    queue.push(args), firing || fire()), this;
                },
                fire: function() {
                    return self.fireWith(this, arguments), this;
                },
                fired: function() {
                    return !!fired;
                }
            };
            return self;
        }, jQuery.extend({
            Deferred: function(func) {
                var tuples = [ [ "notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2 ], [ "resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected" ] ], state = "pending", promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        return deferred.done(arguments).fail(arguments), this;
                    },
                    catch: function(fn) {
                        return promise.then(null, fn);
                    },
                    pipe: function() {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function() {
                                    var returned = fn && fn.apply(this, arguments);
                                    returned && isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [ returned ] : arguments);
                                });
                            }), fns = null;
                        }).promise();
                    },
                    then: function(onFulfilled, onRejected, onProgress) {
                        function resolve(depth, deferred, handler, special) {
                            return function() {
                                var that = this, args = arguments, mightThrow = function() {
                                    var returned, then;
                                    if (!(depth < maxDepth)) {
                                        if ((returned = handler.apply(that, args)) === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                        then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then,
                                        isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++,
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0,
                                        args = [ returned ]), (special || deferred.resolveWith)(that, args));
                                    }
                                }, process = special ? mightThrow : function() {
                                    try {
                                        mightThrow();
                                    } catch (e) {
                                        jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace),
                                        depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [ e ]),
                                        deferred.rejectWith(that, args));
                                    }
                                };
                                depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()),
                                window.setTimeout(process));
                            };
                        }
                        var maxDepth = 0;
                        return jQuery.Deferred(function(newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)),
                            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)),
                            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                        }).promise();
                    },
                    promise: function(obj) {
                        return null != obj ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
                return jQuery.each(tuples, function(i, tuple) {
                    var list = tuple[2], stateString = tuple[5];
                    promise[tuple[1]] = list.add, stateString && list.add(function() {
                        state = stateString;
                    }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock),
                    list.add(tuple[3].fire), deferred[tuple[0]] = function() {
                        return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments),
                        this;
                    }, deferred[tuple[0] + "With"] = list.fireWith;
                }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
            },
            when: function(singleValue) {
                var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i) {
                    return function(value) {
                        resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value,
                        --remaining || master.resolveWith(resolveContexts, resolveValues);
                    };
                };
                if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining),
                "pending" === master.state() || isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
                for (;i--; ) adoptValue(resolveValues[i], updateFunc(i), master.reject);
                return master.promise();
            }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error, stack) {
            window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }, jQuery.readyException = function(error) {
            window.setTimeout(function() {
                throw error;
            });
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function(fn) {
            return readyList.then(fn).catch(function(error) {
                jQuery.readyException(error);
            }), this;
        }, jQuery.extend({
            isReady: !1,
            readyWait: 1,
            ready: function(wait) {
                (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, !0 !== wait && --jQuery.readyWait > 0 || readyList.resolveWith(document, [ jQuery ]));
            }
        }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed),
        window.addEventListener("load", completed));
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0, len = elems.length, bulk = null == key;
            if ("object" === toType(key)) {
                chainable = !0;
                for (i in key) access(elems, fn, i, key[i], !0, emptyGet, raw);
            } else if (void 0 !== value && (chainable = !0, isFunction(value) || (raw = !0),
            bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
                return bulk.call(jQuery(elem), value);
            })), fn)) for (;i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
        }, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, acceptData = function(owner) {
            return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
        };
        Data.uid = 1, Data.prototype = {
            cache: function(owner) {
                var value = owner[this.expando];
                return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                    value: value,
                    configurable: !0
                }))), value;
            },
            set: function(owner, data, value) {
                var prop, cache = this.cache(owner);
                if ("string" == typeof data) cache[camelCase(data)] = value; else for (prop in data) cache[camelCase(prop)] = data[prop];
                return cache;
            },
            get: function(owner, key) {
                return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
            },
            access: function(owner, key, value) {
                return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value),
                void 0 !== value ? value : key);
            },
            remove: function(owner, key) {
                var i, cache = owner[this.expando];
                if (void 0 !== cache) {
                    if (void 0 !== key) {
                        Array.isArray(key) ? key = key.map(camelCase) : (key = camelCase(key), key = key in cache ? [ key ] : key.match(rnothtmlwhite) || []),
                        i = key.length;
                        for (;i--; ) delete cache[key[i]];
                    }
                    (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando]);
                }
            },
            hasData: function(owner) {
                var cache = owner[this.expando];
                return void 0 !== cache && !jQuery.isEmptyObject(cache);
            }
        };
        var dataPriv = new Data(), dataUser = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        jQuery.extend({
            hasData: function(elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem);
            },
            data: function(elem, name, data) {
                return dataUser.access(elem, name, data);
            },
            removeData: function(elem, name) {
                dataUser.remove(elem, name);
            },
            _data: function(elem, name, data) {
                return dataPriv.access(elem, name, data);
            },
            _removeData: function(elem, name) {
                dataPriv.remove(elem, name);
            }
        }), jQuery.fn.extend({
            data: function(key, value) {
                var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                if (void 0 === key) {
                    if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                        for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = camelCase(name.slice(5)),
                        dataAttr(elem, name, data[name])));
                        dataPriv.set(elem, "hasDataAttrs", !0);
                    }
                    return data;
                }
                return "object" == typeof key ? this.each(function() {
                    dataUser.set(this, key);
                }) : access(this, function(value) {
                    var data;
                    if (elem && void 0 === value) {
                        if (void 0 !== (data = dataUser.get(elem, key))) return data;
                        if (void 0 !== (data = dataAttr(elem, key))) return data;
                    } else this.each(function() {
                        dataUser.set(this, key, value);
                    });
                }, null, value, arguments.length > 1, null, !0);
            },
            removeData: function(key) {
                return this.each(function() {
                    dataUser.remove(this, key);
                });
            }
        }), jQuery.extend({
            queue: function(elem, type, data) {
                var queue;
                if (elem) return type = (type || "fx") + "queue", queue = dataPriv.get(elem, type),
                data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)),
                queue || [];
            },
            dequeue: function(elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                    jQuery.dequeue(elem, type);
                };
                "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"),
                delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
            },
            _queueHooks: function(elem, type) {
                var key = type + "queueHooks";
                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function() {
                        dataPriv.remove(elem, [ type + "queue", key ]);
                    })
                });
            }
        }), jQuery.fn.extend({
            queue: function(type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
                });
            },
            dequeue: function(type) {
                return this.each(function() {
                    jQuery.dequeue(this, type);
                });
            },
            clearQueue: function(type) {
                return this.queue(type || "fx", []);
            },
            promise: function(type, obj) {
                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                    --count || defer.resolveWith(elements, [ elements ]);
                };
                for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) (tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++,
                tmp.empty.add(resolve));
                return resolve(), defer.promise(obj);
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), cssExpand = [ "Top", "Right", "Bottom", "Left" ], documentElement = document.documentElement, isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem);
        }, composed = {
            composed: !0
        };
        documentElement.getRootNode && (isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        });
        var isHiddenWithinTree = function(elem, el) {
            return elem = el || elem, "none" === elem.style.display || "" === elem.style.display && isAttached(elem) && "none" === jQuery.css(elem, "display");
        }, swap = function(elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
            ret = callback.apply(elem, args || []);
            for (name in options) elem.style[name] = old[name];
            return ret;
        }, defaultDisplayMap = {};
        jQuery.fn.extend({
            show: function() {
                return showHide(this, !0);
            },
            hide: function() {
                return showHide(this);
            },
            toggle: function(state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                    isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide();
                });
            }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i, rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, rscriptType = /^$|^module$|\/(?:java|ecma)script/i, wrapMap = {
            option: [ 1, "<select multiple='multiple'>", "</select>" ],
            thead: [ 1, "<table>", "</table>" ],
            col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
            _default: [ 0, "", "" ]
        };
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
        wrapMap.th = wrapMap.td;
        var rhtml = /<|&#?\w+;/;
        !function() {
            var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
            input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"),
            div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked,
            div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
        }();
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        jQuery.event = {
            global: {},
            add: function(elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler,
                selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector),
                handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}),
                (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                    return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
                }), types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [],
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {},
                type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {},
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0,
                special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)),
                special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)),
                selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj),
                jQuery.event.global[type] = !0);
            },
            remove: function(elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                if (elemData && (events = elemData.events)) {
                    for (types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [],
                    type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                        for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type,
                        handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                        origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1),
                        handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                        origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle),
                        delete events[type]);
                    } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events");
                }
            },
            dispatch: function(nativeEvent) {
                var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
                if (event.delegateTarget = this, !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem,
                    j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) event.rnamespace && !1 !== handleObj.namespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj,
                    event.data = handleObj.data, void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(),
                    event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event), event.result;
                }
            },
            handlers: function(event, handlers) {
                var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1)) for (;cur !== this; cur = cur.parentNode || this) if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                    for (matchedHandlers = [], matchedSelectors = {}, i = 0; i < delegateCount; i++) handleObj = handlers[i],
                    sel = handleObj.selector + " ", void 0 === matchedSelectors[sel] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length),
                    matchedSelectors[sel] && matchedHandlers.push(handleObj);
                    matchedHandlers.length && handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                    });
                }
                return cur = this, delegateCount < handlers.length && handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                }), handlerQueue;
            },
            addProp: function(name, hook) {
                Object.defineProperty(jQuery.Event.prototype, name, {
                    enumerable: !0,
                    configurable: !0,
                    get: isFunction(hook) ? function() {
                        if (this.originalEvent) return hook(this.originalEvent);
                    } : function() {
                        if (this.originalEvent) return this.originalEvent[name];
                    },
                    set: function(value) {
                        Object.defineProperty(this, name, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: value
                        });
                    }
                });
            },
            fix: function(originalEvent) {
                return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
            },
            special: {
                load: {
                    noBubble: !0
                },
                click: {
                    setup: function(data) {
                        var el = this || data;
                        return rcheckableType.test(el.type) && el.click && nodeName(el, "input") && leverageNative(el, "click", returnTrue),
                        !1;
                    },
                    trigger: function(data) {
                        var el = this || data;
                        return rcheckableType.test(el.type) && el.click && nodeName(el, "input") && leverageNative(el, "click"),
                        !0;
                    },
                    _default: function(event) {
                        var target = event.target;
                        return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                    }
                },
                beforeunload: {
                    postDispatch: function(event) {
                        void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                    }
                }
            }
        }, jQuery.removeEvent = function(elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle);
        }, jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
            src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse,
            this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target,
            this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src,
            props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || Date.now(),
            this[jQuery.expando] = !0;
        }, jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: !1,
            preventDefault: function() {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault();
            },
            stopPropagation: function() {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation();
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(),
                this.stopPropagation();
            }
        }, jQuery.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function(event) {
                var button = event.button;
                return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which;
            }
        }, jQuery.event.addProp), jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(type, delegateType) {
            jQuery.event.special[type] = {
                setup: function() {
                    return leverageNative(this, type, expectSync), !1;
                },
                trigger: function() {
                    return leverageNative(this, type), !0;
                },
                delegateType: delegateType
            };
        }), jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function(event) {
                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                    return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType,
                    ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
                }
            };
        }), jQuery.fn.extend({
            on: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn);
            },
            one: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn, 1);
            },
            off: function(types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj,
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler),
                this;
                if ("object" == typeof types) {
                    for (type in types) this.off(type, selector, types[type]);
                    return this;
                }
                return !1 !== selector && "function" != typeof selector || (fn = selector, selector = void 0),
                !1 === fn && (fn = returnFalse), this.each(function() {
                    jQuery.event.remove(this, types, fn, selector);
                });
            }
        });
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        jQuery.extend({
            htmlPrefilter: function(html) {
                return html.replace(rxhtmlTag, "<$1></$2>");
            },
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = isAttached(elem);
                if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone),
                srcElements = getAll(elem), i = 0, l = srcElements.length; i < l; i++) fixInput(srcElements[i], destElements[i]);
                if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem),
                destElements = destElements || getAll(clone), i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
                return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")),
                clone;
            },
            cleanData: function(elems) {
                for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        elem[dataPriv.expando] = void 0;
                    }
                    elem[dataUser.expando] && (elem[dataUser.expando] = void 0);
                }
            }
        }), jQuery.fn.extend({
            detach: function(selector) {
                return remove(this, selector, !0);
            },
            remove: function(selector) {
                return remove(this, selector);
            },
            text: function(value) {
                return access(this, function(value) {
                    return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value);
                    });
                }, null, value, arguments.length);
            },
            append: function() {
                return domManip(this, arguments, function(elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        manipulationTarget(this, elem).appendChild(elem);
                    }
                });
            },
            prepend: function() {
                return domManip(this, arguments, function(elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild);
                    }
                });
            },
            before: function() {
                return domManip(this, arguments, function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this);
                });
            },
            after: function() {
                return domManip(this, arguments, function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
                });
            },
            empty: function() {
                for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)),
                elem.textContent = "");
                return this;
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents,
                this.map(function() {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
            },
            html: function(value) {
                return access(this, function(value) {
                    var elem = this[0] || {}, i = 0, l = this.length;
                    if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                    if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                        value = jQuery.htmlPrefilter(value);
                        try {
                            for (;i < l; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)),
                            elem.innerHTML = value);
                            elem = 0;
                        } catch (e) {}
                    }
                    elem && this.empty().append(value);
                }, null, value, arguments.length);
            },
            replaceWith: function() {
                var ignored = [];
                return domManip(this, arguments, function(elem) {
                    var parent = this.parentNode;
                    jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this));
                }, ignored);
            }
        }), jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(name, original) {
            jQuery.fn[name] = function(selector) {
                for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++) elems = i === last ? this : this.clone(!0),
                jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
                return this.pushStack(ret);
            };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
            var view = elem.ownerDocument.defaultView;
            return view && view.opener || (view = window), view.getComputedStyle(elem);
        }, rboxStyle = new RegExp(cssExpand.join("|"), "i");
        !function() {
            function computeStyleTests() {
                if (div) {
                    container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                    div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                    documentElement.appendChild(container).appendChild(div);
                    var divStyle = window.getComputedStyle(div);
                    pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = 12 === roundPixelMeasures(divStyle.marginLeft),
                    div.style.right = "60%", pixelBoxStylesVal = 36 === roundPixelMeasures(divStyle.right),
                    boxSizingReliableVal = 36 === roundPixelMeasures(divStyle.width), div.style.position = "absolute",
                    scrollboxSizeVal = 12 === roundPixelMeasures(div.offsetWidth / 3), documentElement.removeChild(container),
                    div = null;
                }
            }
            function roundPixelMeasures(measure) {
                return Math.round(parseFloat(measure));
            }
            var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
            div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "",
            support.clearCloneStyle = "content-box" === div.style.backgroundClip, jQuery.extend(support, {
                boxSizingReliable: function() {
                    return computeStyleTests(), boxSizingReliableVal;
                },
                pixelBoxStyles: function() {
                    return computeStyleTests(), pixelBoxStylesVal;
                },
                pixelPosition: function() {
                    return computeStyleTests(), pixelPositionVal;
                },
                reliableMarginLeft: function() {
                    return computeStyleTests(), reliableMarginLeftVal;
                },
                scrollboxSize: function() {
                    return computeStyleTests(), scrollboxSizeVal;
                }
            }));
        }();
        var cssPrefixes = [ "Webkit", "Moz", "ms" ], emptyStyle = document.createElement("div").style, vendorProps = {}, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        }, cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        };
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret;
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function(elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
                    if (isCustomProp || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                    void 0 === value) return hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                    type = typeof value, "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret),
                    type = "number"), null != value && value === value && ("number" !== type || isCustomProp || (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")),
                    support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"),
                    hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value));
                }
            },
            css: function(elem, name, extra, styles) {
                var val, num, hooks, origName = camelCase(name);
                return rcustomProp.test(name) || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)),
                "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]),
                "" === extra || extra ? (num = parseFloat(val), !0 === extra || isFinite(num) ? num || 0 : val) : val;
            }
        }), jQuery.each([ "height", "width" ], function(i, dimension) {
            jQuery.cssHooks[dimension] = {
                get: function(elem, computed, extra) {
                    if (computed) return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, dimension, extra) : swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, dimension, extra);
                    });
                },
                set: function(elem, value, extra) {
                    var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && "absolute" === styles.position, boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && "border-box" === jQuery.css(elem, "boxSizing", !1, styles), subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                    return isBorderBox && scrollboxSizeBuggy && (subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", !1, styles) - .5)),
                    subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[dimension] = value,
                    value = jQuery.css(elem, dimension)), setPositiveNumber(elem, value, subtract);
                }
            };
        }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
            if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, function() {
                return elem.getBoundingClientRect().left;
            })) + "px";
        }), jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function(value) {
                    for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [ value ]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    return expanded;
                }
            }, "margin" !== prefix && (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
        }), jQuery.fn.extend({
            css: function(name, value) {
                return access(this, function(elem, name, value) {
                    var styles, len, map = {}, i = 0;
                    if (Array.isArray(name)) {
                        for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                        return map;
                    }
                    return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                }, name, value, arguments.length > 1);
            }
        }), jQuery.Tween = Tween, Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end, easing, unit) {
                this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default,
                this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
            },
            cur: function() {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function(percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent,
                this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this),
                hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
            }
        }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
            _default: {
                get: function(tween) {
                    var result;
                    return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""),
                    result && "auto" !== result ? result : 0);
                },
                set: function(tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || !jQuery.cssHooks[tween.prop] && null == tween.elem.style[finalPropName(tween.prop)] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                }
            }
        }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
            }
        }, jQuery.easing = {
            linear: function(p) {
                return p;
            },
            swing: function(p) {
                return .5 - Math.cos(p * Math.PI) / 2;
            },
            _default: "swing"
        }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
                "*": [ function(prop, value) {
                    var tween = this.createTween(prop, value);
                    return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween;
                } ]
            },
            tweener: function(props, callback) {
                isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.match(rnothtmlwhite);
                for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index],
                Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback);
            },
            prefilters: [ defaultPrefilter ],
            prefilter: function(callback, prepend) {
                prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback);
            }
        }), jQuery.speed = function(speed, easing, fn) {
            var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing || isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !isFunction(easing) && easing
            };
            return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default),
            null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"), opt.old = opt.complete,
            opt.complete = function() {
                isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
            }, opt;
        }, jQuery.fn.extend({
            fadeTo: function(speed, to, easing, callback) {
                return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                    opacity: to
                }, speed, easing, callback);
            },
            animate: function(prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    (empty || dataPriv.get(this, "finish")) && anim.stop(!0);
                };
                return doAnimation.finish = doAnimation, empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function(type, clearQueue, gotoEnd) {
                var stopQueue = function(hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop, stop(gotoEnd);
                };
                return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0),
                clearQueue && !1 !== type && this.queue(type || "fx", []), this.each(function() {
                    var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                    if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                    for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd),
                    dequeue = !1, timers.splice(index, 1));
                    !dequeue && gotoEnd || jQuery.dequeue(this, type);
                });
            },
            finish: function(type) {
                return !1 !== type && (type = type || "fx"), this.each(function() {
                    var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                    for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0),
                    index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0),
                    timers.splice(index, 1));
                    for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                    delete data.finish;
                });
            }
        }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function(speed, easing, callback) {
                return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
            };
        }), jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function(name, props) {
            jQuery.fn[name] = function(speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        }), jQuery.timers = [], jQuery.fx.tick = function() {
            var timer, i = 0, timers = jQuery.timers;
            for (fxNow = Date.now(); i < timers.length; i++) (timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
            timers.length || jQuery.fx.stop(), fxNow = void 0;
        }, jQuery.fx.timer = function(timer) {
            jQuery.timers.push(timer), jQuery.fx.start();
        }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
            inProgress || (inProgress = !0, schedule());
        }, jQuery.fx.stop = function() {
            inProgress = null;
        }, jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        }, jQuery.fn.delay = function(time, type) {
            return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx",
            this.queue(type, function(next, hooks) {
                var timeout = window.setTimeout(next, time);
                hooks.stop = function() {
                    window.clearTimeout(timeout);
                };
            });
        }, function() {
            var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
            input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected,
            input = document.createElement("input"), input.value = "t", input.type = "radio",
            support.radioValue = "t" === input.value;
        }();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function(name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function(name) {
                return this.each(function() {
                    jQuery.removeAttr(this, name);
                });
            }
        }), jQuery.extend({
            attr: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType) return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)),
                void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""),
                value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name),
                null == ret ? void 0 : ret));
            },
            attrHooks: {
                type: {
                    set: function(elem, value) {
                        if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value), val && (elem.value = val), value;
                        }
                    }
                }
            },
            removeAttr: function(elem, value) {
                var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
                if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) elem.removeAttribute(name);
            }
        }), boolHook = {
            set: function(elem, value, name) {
                return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name),
                name;
            }
        }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function(elem, name, isXML) {
                var ret, handle, lowercaseName = name.toLowerCase();
                return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret,
                ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle),
                ret;
            };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
            prop: function(name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function(name) {
                return this.each(function() {
                    delete this[jQuery.propFix[name] || name];
                });
            }
        }), jQuery.extend({
            prop: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name,
                hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
            },
            propHooks: {
                tabIndex: {
                    get: function(elem) {
                        var tabindex = jQuery.find.attr(elem, "tabindex");
                        return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                    }
                }
            },
            propFix: {
                for: "htmlFor",
                class: "className"
            }
        }), support.optSelected || (jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
            },
            set: function(elem) {
                var parent = elem.parentNode;
                parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex);
            }
        }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
            jQuery.propFix[this.toLowerCase()] = this;
        }), jQuery.fn.extend({
            addClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
                if (classes = classesToArray(value), classes.length) for (;elem = this[i++]; ) if (curValue = getClass(elem),
                cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                    for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                    finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
                }
                return this;
            },
            removeClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
                if (!arguments.length) return this.attr("class", "");
                if (classes = classesToArray(value), classes.length) for (;elem = this[i++]; ) if (curValue = getClass(elem),
                cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                    for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") > -1; ) cur = cur.replace(" " + clazz + " ", " ");
                    finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
                }
                return this;
            },
            toggleClass: function(value, stateVal) {
                var type = typeof value, isValidValue = "string" === type || Array.isArray(value);
                return "boolean" == typeof stateVal && isValidValue ? stateVal ? this.addClass(value) : this.removeClass(value) : isFunction(value) ? this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                }) : this.each(function() {
                    var className, i, self, classNames;
                    if (isValidValue) for (i = 0, self = jQuery(this), classNames = classesToArray(value); className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else void 0 !== value && "boolean" !== type || (className = getClass(this),
                    className && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""));
                });
            },
            hasClass: function(selector) {
                var className, elem, i = 0;
                for (className = " " + selector + " "; elem = this[i++]; ) if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return !0;
                return !1;
            }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
            val: function(value) {
                var hooks, ret, valueIsFunction, elem = this[0];
                {
                    if (arguments.length) return valueIsFunction = isFunction(value), this.each(function(i) {
                        var val;
                        1 === this.nodeType && (val = valueIsFunction ? value.call(this, i, jQuery(this).val()) : value,
                        null == val ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, function(value) {
                            return null == value ? "" : value + "";
                        })), (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
                    });
                    if (elem) return (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value,
                    "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret);
                }
            }
        }), jQuery.extend({
            valHooks: {
                option: {
                    get: function(elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return null != val ? val : stripAndCollapse(jQuery.text(elem));
                    }
                },
                select: {
                    get: function(elem) {
                        var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                        for (i = index < 0 ? max : one ? index : 0; i < max; i++) if (option = options[i],
                        (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                            if (value = jQuery(option).val(), one) return value;
                            values.push(value);
                        }
                        return values;
                    },
                    set: function(elem, value) {
                        for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i],
                        (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                        return optionSet || (elem.selectedIndex = -1), values;
                    }
                }
            }
        }), jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[this] = {
                set: function(elem, value) {
                    if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
                return null === elem.getAttribute("value") ? "on" : elem.value;
            });
        }), support.focusin = "onfocusin" in window;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
            e.stopPropagation();
        };
        jQuery.extend(jQuery.event, {
            trigger: function(event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = lastElement = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."),
                type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type,
                event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event),
                event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."),
                event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
                event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]),
                special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                    if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur),
                        tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                    }
                    for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) lastElement = cur,
                    event.type = i > 1 ? bubbleType : special.bindType || type, handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"),
                    handle && handle.apply(cur, data), (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data),
                    !1 === event.result && event.preventDefault());
                    return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && isFunction(elem[type]) && !isWindow(elem) && (tmp = elem[ontype],
                    tmp && (elem[ontype] = null), jQuery.event.triggered = type, event.isPropagationStopped() && lastElement.addEventListener(type, stopPropagationCallback),
                    elem[type](), event.isPropagationStopped() && lastElement.removeEventListener(type, stopPropagationCallback),
                    jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result;
                }
            },
            simulate: function(type, elem, event) {
                var e = jQuery.extend(new jQuery.Event(), event, {
                    type: type,
                    isSimulated: !0
                });
                jQuery.event.trigger(e, null, elem);
            }
        }), jQuery.fn.extend({
            trigger: function(type, data) {
                return this.each(function() {
                    jQuery.event.trigger(type, data, this);
                });
            },
            triggerHandler: function(type, data) {
                var elem = this[0];
                if (elem) return jQuery.event.trigger(type, data, elem, !0);
            }
        }), support.focusin || jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0),
                    dataPriv.remove(doc, fix));
                }
            };
        });
        var location = window.location, nonce = Date.now(), rquery = /\?/;
        jQuery.parseXML = function(data) {
            var xml;
            if (!data || "string" != typeof data) return null;
            try {
                xml = new window.DOMParser().parseFromString(data, "text/xml");
            } catch (e) {
                xml = void 0;
            }
            return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data),
            xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.param = function(a, traditional) {
            var prefix, s = [], add = function(key, valueOrFunction) {
                var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value);
            };
            if (null == a) return "";
            if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
                add(this.name, this.value);
            }); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
            return s.join("&");
        }, jQuery.fn.extend({
            serialize: function() {
                return jQuery.param(this.serializeArray());
            },
            serializeArray: function() {
                return this.map(function() {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this;
                }).filter(function() {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                }).map(function(i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : Array.isArray(val) ? jQuery.map(val, function(val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        };
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }).get();
            }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
        originAnchor.href = location.href, jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: location.href,
                type: "GET",
                isLocal: rlocalProtocol.test(location.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": JSON.parse,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function(url, options) {
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer),
                    transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0,
                    isSuccess = status >= 200 && status < 300 || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)),
                    response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"),
                    modified && (jQuery.lastModified[cacheURL] = modified), (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)),
                    204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state,
                    success = response.data, error = response.error, isSuccess = !error)) : (error = statusText,
                    !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status,
                    jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]),
                    jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]),
                    completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]),
                    --jQuery.active || jQuery.event.trigger("ajaxStop")));
                }
                "object" == typeof url && (options = url, url = void 0), options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                    readyState: 0,
                    getResponseHeader: function(key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                            match = responseHeaders[key.toLowerCase() + " "];
                        }
                        return null == match ? null : match.join(", ");
                    },
                    getAllResponseHeaders: function() {
                        return completed ? responseHeadersString : null;
                    },
                    setRequestHeader: function(name, value) {
                        return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name,
                        requestHeaders[name] = value), this;
                    },
                    overrideMimeType: function(type) {
                        return null == completed && (s.mimeType = type), this;
                    },
                    statusCode: function(map) {
                        var code;
                        if (map) if (completed) jqXHR.always(map[jqXHR.status]); else for (code in map) statusCode[code] = [ statusCode[code], map[code] ];
                        return this;
                    },
                    abort: function(statusText) {
                        var finalText = statusText || strAbort;
                        return transport && transport.abort(finalText), done(0, finalText), this;
                    }
                };
                if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"),
                s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [ "" ],
                null == s.crossDomain) {
                    urlAnchor = document.createElement("a");
                    try {
                        urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host;
                    } catch (e) {
                        s.crossDomain = !0;
                    }
                }
                if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)),
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
                fireGlobals = jQuery.event && s.global, fireGlobals && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"),
                s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""),
                s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length),
                s.data && (s.processData || "string" == typeof s.data) && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data,
                delete s.data), !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"),
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), s.url = cacheURL + uncached),
                s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]),
                jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])),
                (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType),
                jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed)) return jqXHR.abort();
                if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success),
                jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]),
                    completed) return jqXHR;
                    s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout));
                    try {
                        completed = !1, transport.send(requestHeaders, done);
                    } catch (e) {
                        if (completed) throw e;
                        done(-1, e);
                    }
                } else done(-1, "No Transport");
                return jqXHR;
            },
            getJSON: function(url, data, callback) {
                return jQuery.get(url, data, callback, "json");
            },
            getScript: function(url, callback) {
                return jQuery.get(url, void 0, callback, "script");
            }
        }), jQuery.each([ "get", "post" ], function(i, method) {
            jQuery[method] = function(url, data, callback, type) {
                return isFunction(data) && (type = type || callback, callback = data, data = void 0),
                jQuery.ajax(jQuery.extend({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                }, jQuery.isPlainObject(url) && url));
            };
        }), jQuery._evalUrl = function(url, options) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function() {}
                },
                dataFilter: function(response) {
                    jQuery.globalEval(response, options);
                }
            });
        }, jQuery.fn.extend({
            wrapAll: function(html) {
                var wrap;
                return this[0] && (isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0),
                this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                    for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
                    return elem;
                }).append(this)), this;
            },
            wrapInner: function(html) {
                return isFunction(html) ? this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                }) : this.each(function() {
                    var self = jQuery(this), contents = self.contents();
                    contents.length ? contents.wrapAll(html) : self.append(html);
                });
            },
            wrap: function(html) {
                var htmlIsFunction = isFunction(html);
                return this.each(function(i) {
                    jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
                });
            },
            unwrap: function(selector) {
                return this.parent(selector).not("body").each(function() {
                    jQuery(this).replaceWith(this.childNodes);
                }), this;
            }
        }), jQuery.expr.pseudos.hidden = function(elem) {
            return !jQuery.expr.pseudos.visible(elem);
        }, jQuery.expr.pseudos.visible = function(elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        }, jQuery.ajaxSettings.xhr = function() {
            try {
                return new window.XMLHttpRequest();
            } catch (e) {}
        };
        var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported,
        jQuery.ajaxTransport(function(options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password),
                    options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType),
                    options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                    for (i in headers) xhr.setRequestHeader(i, headers[i]);
                    callback = function(type) {
                        return function() {
                            callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null,
                            "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders()));
                        };
                    }, xhr.onload = callback(), errorCallback = xhr.onerror = xhr.ontimeout = callback("error"),
                    void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                        4 === xhr.readyState && window.setTimeout(function() {
                            callback && errorCallback();
                        });
                    }, callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) throw e;
                    }
                },
                abort: function() {
                    callback && callback();
                }
            };
        }), jQuery.ajaxPrefilter(function(s) {
            s.crossDomain && (s.contents.script = !1);
        }), jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function(text) {
                    return jQuery.globalEval(text), text;
                }
            }
        }), jQuery.ajaxPrefilter("script", function(s) {
            void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
        }), jQuery.ajaxTransport("script", function(s) {
            if (s.crossDomain || s.scriptAttrs) {
                var script, callback;
                return {
                    send: function(_, complete) {
                        script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                            charset: s.scriptCharset,
                            src: s.url
                        }).on("load error", callback = function(evt) {
                            script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type);
                        }), document.head.appendChild(script[0]);
                    },
                    abort: function() {
                        callback && callback();
                    }
                };
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                return this[callback] = !0, callback;
            }
        }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
            jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName),
            s.converters["script json"] = function() {
                return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
            }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
                responseContainer = arguments;
            }, jqXHR.always(function() {
                void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten,
                s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)),
                responseContainer && isFunction(overwritten) && overwritten(responseContainer[0]),
                responseContainer = overwritten = void 0;
            }), "script";
        }), support.createHTMLDocument = function() {
            var body = document.implementation.createHTMLDocument("").body;
            return body.innerHTML = "<form></form><form></form>", 2 === body.childNodes.length;
        }(), jQuery.parseHTML = function(data, context, keepScripts) {
            if ("string" != typeof data) return [];
            "boolean" == typeof context && (keepScripts = context, context = !1);
            var base, parsed, scripts;
            return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""),
            base = context.createElement("base"), base.href = document.location.href, context.head.appendChild(base)) : context = document),
            parsed = rsingleTag.exec(data), scripts = !keepScripts && [], parsed ? [ context.createElement(parsed[1]) ] : (parsed = buildFragment([ data ], context, scripts),
            scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
        }, jQuery.fn.load = function(url, params, callback) {
            var selector, type, response, self = this, off = url.indexOf(" ");
            return off > -1 && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)),
            isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"),
            self.length > 0 && jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
                self.each(function() {
                    callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
                });
            }), this;
        }, jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
            jQuery.fn[type] = function(fn) {
                return this.on(type, fn);
            };
        }), jQuery.expr.pseudos.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn) {
                return elem === fn.elem;
            }).length;
        }, jQuery.offset = {
            setOffset: function(elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
                "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1,
                calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top,
                curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0),
                isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))),
                null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft),
                "using" in options ? options.using.call(elem, props) : curElem.css(props);
            }
        }, jQuery.fn.extend({
            offset: function(options) {
                if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
                var rect, win, elem = this[0];
                if (elem) return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(),
                win = elem.ownerDocument.defaultView, {
                    top: rect.top + win.pageYOffset,
                    left: rect.left + win.pageXOffset
                }) : {
                    top: 0,
                    left: 0
                };
            },
            position: function() {
                if (this[0]) {
                    var offsetParent, offset, doc, elem = this[0], parentOffset = {
                        top: 0,
                        left: 0
                    };
                    if ("fixed" === jQuery.css(elem, "position")) offset = elem.getBoundingClientRect(); else {
                        for (offset = this.offset(), doc = elem.ownerDocument, offsetParent = elem.offsetParent || doc.documentElement; offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.parentNode;
                        offsetParent && offsetParent !== elem && 1 === offsetParent.nodeType && (parentOffset = jQuery(offsetParent).offset(),
                        parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", !0));
                    }
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    };
                }
            },
            offsetParent: function() {
                return this.map(function() {
                    for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                    return offsetParent || documentElement;
                });
            }
        }), jQuery.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function(val) {
                return access(this, function(elem, method, val) {
                    var win;
                    if (isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView),
                    void 0 === val) return win ? win[prop] : elem[method];
                    win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val;
                }, method, val, arguments.length);
            };
        }), jQuery.each([ "top", "left" ], function(i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            });
        }), jQuery.each({
            Height: "height",
            Width: "width"
        }, function(name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, function(defaultExtra, funcName) {
                jQuery.fn[funcName] = function(margin, value) {
                    var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                    return access(this, function(elem, type, value) {
                        var doc;
                        return isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement,
                        Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : void 0, chainable);
                };
            });
        }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
            jQuery.fn[name] = function(data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        }), jQuery.fn.extend({
            hover: function(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            }
        }), jQuery.fn.extend({
            bind: function(types, data, fn) {
                return this.on(types, null, data, fn);
            },
            unbind: function(types, fn) {
                return this.off(types, null, fn);
            },
            delegate: function(selector, types, data, fn) {
                return this.on(types, selector, data, fn);
            },
            undelegate: function(selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
            }
        }), jQuery.proxy = function(fn, context) {
            var tmp, args, proxy;
            if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), isFunction(fn)) return args = slice.call(arguments, 2),
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy;
        }, jQuery.holdReady = function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0);
        }, jQuery.isArray = Array.isArray, jQuery.parseJSON = JSON.parse, jQuery.nodeName = nodeName,
        jQuery.isFunction = isFunction, jQuery.isWindow = isWindow, jQuery.camelCase = camelCase,
        jQuery.type = toType, jQuery.now = Date.now, jQuery.isNumeric = function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj));
        }, __WEBPACK_AMD_DEFINE_ARRAY__ = [], void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return jQuery;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        var _jQuery = window.jQuery, _$ = window.$;
        return jQuery.noConflict = function(deep) {
            return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery),
            jQuery;
        }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery;
    });
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function EventDispatcher() {}
    function Vector2(x, y) {
        this.x = x || 0, this.y = y || 0;
    }
    function Matrix4() {
        this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    function Quaternion(x, y, z, w) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._w = void 0 !== w ? w : 1;
    }
    function Vector3(x, y, z) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0;
    }
    function Matrix3() {
        this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, "id", {
            value: textureId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.image = void 0 !== image ? image : Texture.DEFAULT_IMAGE,
        this.mipmaps = [], this.mapping = void 0 !== mapping ? mapping : Texture.DEFAULT_MAPPING,
        this.wrapS = void 0 !== wrapS ? wrapS : ClampToEdgeWrapping, this.wrapT = void 0 !== wrapT ? wrapT : ClampToEdgeWrapping,
        this.magFilter = void 0 !== magFilter ? magFilter : LinearFilter, this.minFilter = void 0 !== minFilter ? minFilter : LinearMipMapLinearFilter,
        this.anisotropy = void 0 !== anisotropy ? anisotropy : 1, this.format = void 0 !== format ? format : RGBAFormat,
        this.type = void 0 !== type ? type : UnsignedByteType, this.offset = new Vector2(0, 0),
        this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0,
        this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0,
        this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== encoding ? encoding : LinearEncoding,
        this.version = 0, this.onUpdate = null;
    }
    function Vector4(x, y, z, w) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = void 0 !== w ? w : 1;
    }
    function WebGLRenderTarget(width, height, options) {
        this.uuid = _Math.generateUUID(), this.width = width, this.height = height, this.scissor = new Vector4(0, 0, width, height),
        this.scissorTest = !1, this.viewport = new Vector4(0, 0, width, height), options = options || {},
        void 0 === options.minFilter && (options.minFilter = LinearFilter), this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding),
        this.depthBuffer = void 0 === options.depthBuffer || options.depthBuffer, this.stencilBuffer = void 0 === options.stencilBuffer || options.stencilBuffer,
        this.depthTexture = void 0 !== options.depthTexture ? options.depthTexture : null;
    }
    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
    }
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
        this.image = {
            data: data,
            width: width,
            height: height
        }, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter,
        this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = void 0 !== images ? images : [], mapping = void 0 !== mapping ? mapping : CubeReflectionMapping,
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
        this.flipY = !1;
    }
    function UniformContainer() {
        this.seq = [], this.map = {};
    }
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0) return array;
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (void 0 === r && (r = new Float32Array(n), arrayCacheF32[n] = r), 0 !== nBlocks) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) offset += blockSize, array[i].toArray(r, offset);
        }
        return r;
    }
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        void 0 === r && (r = new Int32Array(n), arrayCacheI32[n] = r);
        for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();
        return r;
    }
    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }
    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }
    function setValue2fv(gl, v) {
        void 0 === v.x ? gl.uniform2fv(this.addr, v) : gl.uniform2f(this.addr, v.x, v.y);
    }
    function setValue3fv(gl, v) {
        void 0 !== v.x ? gl.uniform3f(this.addr, v.x, v.y, v.z) : void 0 !== v.r ? gl.uniform3f(this.addr, v.r, v.g, v.b) : gl.uniform3fv(this.addr, v);
    }
    function setValue4fv(gl, v) {
        void 0 === v.x ? gl.uniform4fv(this.addr, v) : gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    }
    function setValue2fm(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, v.elements || v);
    }
    function setValue3fm(gl, v) {
        void 0 === v.elements ? gl.uniformMatrix3fv(this.addr, !1, v) : (mat3array.set(v.elements),
        gl.uniformMatrix3fv(this.addr, !1, mat3array));
    }
    function setValue4fm(gl, v) {
        void 0 === v.elements ? gl.uniformMatrix4fv(this.addr, !1, v) : (mat4array.set(v.elements),
        gl.uniformMatrix4fv(this.addr, !1, mat4array));
    }
    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTexture2D(v || emptyTexture, unit);
    }
    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }
    function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValue1f;

          case 35664:
            return setValue2fv;

          case 35665:
            return setValue3fv;

          case 35666:
            return setValue4fv;

          case 35674:
            return setValue2fm;

          case 35675:
            return setValue3fm;

          case 35676:
            return setValue4fm;

          case 35678:
          case 36198:
            return setValueT1;

          case 35680:
            return setValueT6;

          case 5124:
          case 35670:
            return setValue1i;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }
    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }
    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }
    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, flatten(v, this.size, 4));
    }
    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, !1, flatten(v, this.size, 9));
    }
    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, !1, flatten(v, this.size, 16));
    }
    function setValueT1a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTexture2D(v[i] || emptyTexture, units[i]);
    }
    function setValueT6a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
    function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValue1fv;

          case 35664:
            return setValueV2a;

          case 35665:
            return setValueV3a;

          case 35666:
            return setValueV4a;

          case 35674:
            return setValueM2a;

          case 35675:
            return setValueM3a;

          case 35676:
            return setValueM4a;

          case 35678:
            return setValueT1a;

          case 35680:
            return setValueT6a;

          case 5124:
          case 35670:
            return setValue1iv;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function SingleUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.size = activeInfo.size, this.setValue = getPureArraySetter(activeInfo.type);
    }
    function StructuredUniform(id) {
        this.id = id, UniformContainer.call(this);
    }
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject), container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        for (RePathPart.lastIndex = 0; ;) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = "]" === match[2], subscript = match[3];
            if (idIsIndex && (id |= 0), void 0 === subscript || "[" === subscript && matchEnd + 2 === pathLength) {
                addUniform(container, void 0 === subscript ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            }
            var map = container.map, next = map[id];
            void 0 === next && (next = new StructuredUniform(id), addUniform(container, next)),
            container = next;
        }
    }
    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this), this.renderer = renderer;
        for (var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i), path = info.name;
            parseUniform(info, gl.getUniformLocation(program, path), this);
        }
    }
    function Color(r, g, b) {
        return void 0 === g && void 0 === b ? this.set(r) : this.setRGB(r, g, b);
    }
    function Box2(min, max) {
        this.min = void 0 !== min ? min : new Vector2(1 / 0, 1 / 0), this.max = void 0 !== max ? max : new Vector2(-1 / 0, -1 / 0);
    }
    function WebGLFlareRenderer(renderer, gl, state, textures, capabilities) {
        function init() {
            var vertices = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), tempTexture = gl.createTexture(),
            occlusionTexture = gl.createTexture(), state.bindTexture(gl.TEXTURE_2D, tempTexture),
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null),
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE),
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null),
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE),
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tvUV = uv;", "\tvec2 pos = position;", "\tif ( renderType == 2 ) {", "\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "\t\tvVisibility =        visibility.r / 9.0;", "\t\tvVisibility *= 1.0 - visibility.g / 9.0;", "\t\tvVisibility *=       visibility.b / 9.0;", "\t\tvVisibility *= 1.0 - visibility.a / 9.0;", "\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "\t}", "\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tif ( renderType == 0 ) {", "\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "\t} else if ( renderType == 1 ) {", "\t\tgl_FragColor = texture2D( map, vUV );", "\t} else {", "\t\tvec4 texture = texture2D( map, vUV );", "\t\ttexture.a *= opacity * vVisibility;", "\t\tgl_FragColor = texture;", "\t\tgl_FragColor.rgb *= color;", "\t}", "}" ].join("\n")
            }, program = createProgram(shader), attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        }
        function createProgram(shader) {
            var program = gl.createProgram(), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER), vertexShader = gl.createShader(gl.VERTEX_SHADER), prefix = "precision " + capabilities.precision + " float;\n";
            return gl.shaderSource(fragmentShader, prefix + shader.fragmentShader), gl.shaderSource(vertexShader, prefix + shader.vertexShader),
            gl.compileShader(fragmentShader), gl.compileShader(vertexShader), gl.attachShader(program, fragmentShader),
            gl.attachShader(program, vertexShader), gl.linkProgram(program), program;
        }
        var vertexBuffer, elementBuffer, shader, program, attributes, uniforms, tempTexture, occlusionTexture;
        this.render = function(flares, scene, camera, viewport) {
            if (0 !== flares.length) {
                var tempPosition = new Vector3(), invAspect = viewport.w / viewport.z, halfViewportWidth = .5 * viewport.z, halfViewportHeight = .5 * viewport.w, size = 16 / viewport.w, scale = new Vector2(size * invAspect, size), screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1), validArea = new Box2();
                validArea.min.set(viewport.x, viewport.y), validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)),
                void 0 === program && init(), state.useProgram(program), state.initAttributes(),
                state.enableAttribute(attributes.vertex), state.enableAttribute(attributes.uv),
                state.disableUnusedAttributes(), gl.uniform1i(uniforms.occlusionMap, 0), gl.uniform1i(uniforms.map, 1),
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, !1, 16, 0),
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                state.disable(gl.CULL_FACE), state.buffers.depth.setMask(!1);
                for (var i = 0, l = flares.length; i < l; i++) {
                    size = 16 / viewport.w, scale.set(size * invAspect, size);
                    var flare = flares[i];
                    if (tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]),
                    tempPosition.applyMatrix4(camera.matrixWorldInverse), tempPosition.applyMatrix4(camera.projectionMatrix),
                    screenPosition.copy(tempPosition), screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8,
                    screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8,
                    !0 === validArea.containsPoint(screenPositionPixels)) {
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, null), state.activeTexture(gl.TEXTURE1),
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0),
                        gl.uniform1i(uniforms.renderType, 0), gl.uniform2f(uniforms.scale, scale.x, scale.y),
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z),
                        state.disable(gl.BLEND), state.enable(gl.DEPTH_TEST), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0),
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, occlusionTexture),
                        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0),
                        gl.uniform1i(uniforms.renderType, 1), state.disable(gl.DEPTH_TEST), state.activeTexture(gl.TEXTURE1),
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0),
                        flare.positionScreen.copy(screenPosition), flare.customUpdateCallback ? flare.customUpdateCallback(flare) : flare.updateLensFlares(),
                        gl.uniform1i(uniforms.renderType, 2), state.enable(gl.BLEND);
                        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                            var sprite = flare.lensFlares[j];
                            sprite.opacity > .001 && sprite.scale > .001 && (screenPosition.x = sprite.x, screenPosition.y = sprite.y,
                            screenPosition.z = sprite.z, size = sprite.size * sprite.scale / viewport.w, scale.x = size * invAspect,
                            scale.y = size, gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z),
                            gl.uniform2f(uniforms.scale, scale.x, scale.y), gl.uniform1f(uniforms.rotation, sprite.rotation),
                            gl.uniform1f(uniforms.opacity, sprite.opacity), gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b),
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst),
                            textures.setTexture2D(sprite.texture, 1), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
                        }
                    }
                }
                state.enable(gl.CULL_FACE), state.enable(gl.DEPTH_TEST), state.buffers.depth.setMask(!0),
                state.reset();
            }
        };
    }
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy),
        this.needsUpdate = !0;
    }
    function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {
        function init() {
            var vertices = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), program = createProgram(),
            attributes = {
                position: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                uvOffset: gl.getUniformLocation(program, "uvOffset"),
                uvScale: gl.getUniformLocation(program, "uvScale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                scale: gl.getUniformLocation(program, "scale"),
                color: gl.getUniformLocation(program, "color"),
                map: gl.getUniformLocation(program, "map"),
                opacity: gl.getUniformLocation(program, "opacity"),
                modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                fogType: gl.getUniformLocation(program, "fogType"),
                fogDensity: gl.getUniformLocation(program, "fogDensity"),
                fogNear: gl.getUniformLocation(program, "fogNear"),
                fogFar: gl.getUniformLocation(program, "fogFar"),
                fogColor: gl.getUniformLocation(program, "fogColor"),
                fogDepth: gl.getUniformLocation(program, "fogDepth"),
                alphaTest: gl.getUniformLocation(program, "alphaTest")
            };
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = 8, canvas.height = 8;
            var context = canvas.getContext("2d");
            context.fillStyle = "white", context.fillRect(0, 0, 8, 8), texture = new CanvasTexture(canvas);
        }
        function createProgram() {
            var program = gl.createProgram(), vertexShader = gl.createShader(gl.VERTEX_SHADER), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            return gl.shaderSource(vertexShader, [ "precision " + capabilities.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = position * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}" ].join("\n")),
            gl.shaderSource(fragmentShader, [ "precision " + capabilities.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}" ].join("\n")),
            gl.compileShader(vertexShader), gl.compileShader(fragmentShader), gl.attachShader(program, vertexShader),
            gl.attachShader(program, fragmentShader), gl.linkProgram(program), program;
        }
        function painterSortStable(a, b) {
            return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id;
        }
        var vertexBuffer, elementBuffer, program, attributes, uniforms, texture, spritePosition = new Vector3(), spriteRotation = new Quaternion(), spriteScale = new Vector3();
        this.render = function(sprites, scene, camera) {
            if (0 !== sprites.length) {
                void 0 === program && init(), state.useProgram(program), state.initAttributes(),
                state.enableAttribute(attributes.position), state.enableAttribute(attributes.uv),
                state.disableUnusedAttributes(), state.disable(gl.CULL_FACE), state.enable(gl.BLEND),
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, !1, 16, 0),
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                gl.uniformMatrix4fv(uniforms.projectionMatrix, !1, camera.projectionMatrix.elements),
                state.activeTexture(gl.TEXTURE0), gl.uniform1i(uniforms.map, 0);
                var oldFogType = 0, sceneFogType = 0, fog = scene.fog;
                fog ? (gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b), fog.isFog ? (gl.uniform1f(uniforms.fogNear, fog.near),
                gl.uniform1f(uniforms.fogFar, fog.far), gl.uniform1i(uniforms.fogType, 1), oldFogType = 1,
                sceneFogType = 1) : fog.isFogExp2 && (gl.uniform1f(uniforms.fogDensity, fog.density),
                gl.uniform1i(uniforms.fogType, 2), oldFogType = 2, sceneFogType = 2)) : (gl.uniform1i(uniforms.fogType, 0),
                oldFogType = 0, sceneFogType = 0);
                for (var i = 0, l = sprites.length; i < l; i++) {
                    var sprite = sprites[i];
                    sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld),
                    sprite.z = -sprite.modelViewMatrix.elements[14];
                }
                sprites.sort(painterSortStable);
                for (var scale = [], i = 0, l = sprites.length; i < l; i++) {
                    var sprite = sprites[i], material = sprite.material;
                    if (!1 !== material.visible) {
                        sprite.onBeforeRender(renderer, scene, camera, void 0, material, void 0), gl.uniform1f(uniforms.alphaTest, material.alphaTest),
                        gl.uniformMatrix4fv(uniforms.modelViewMatrix, !1, sprite.modelViewMatrix.elements),
                        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale), scale[0] = spriteScale.x,
                        scale[1] = spriteScale.y;
                        var fogType = 0;
                        scene.fog && material.fog && (fogType = sceneFogType), oldFogType !== fogType && (gl.uniform1i(uniforms.fogType, fogType),
                        oldFogType = fogType), null !== material.map ? (gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y),
                        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y)) : (gl.uniform2f(uniforms.uvOffset, 0, 0),
                        gl.uniform2f(uniforms.uvScale, 1, 1)), gl.uniform1f(uniforms.opacity, material.opacity),
                        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b),
                        gl.uniform1f(uniforms.rotation, material.rotation), gl.uniform2fv(uniforms.scale, scale),
                        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha),
                        state.buffers.depth.setTest(material.depthTest), state.buffers.depth.setMask(material.depthWrite),
                        state.buffers.color.setMask(material.colorWrite), textures.setTexture2D(material.map || texture, 0),
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), sprite.onAfterRender(renderer, scene, camera, void 0, material, void 0);
                    }
                }
                state.enable(gl.CULL_FACE), state.reset();
            }
        };
    }
    function Material() {
        Object.defineProperty(this, "id", {
            value: materialId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Material", this.fog = !0,
        this.lights = !0, this.blending = NormalBlending, this.side = FrontSide, this.flatShading = !1,
        this.vertexColors = NoColors, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor,
        this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null,
        this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth,
        this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1,
        this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1,
        this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1,
        this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0,
        this.userData = {}, this.needsUpdate = !0;
    }
    function MeshDepthMaterial(parameters) {
        Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking,
        this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null,
        this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0,
        this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1,
        this.setValues(parameters);
    }
    function MeshDistanceMaterial(parameters) {
        Material.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(),
        this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1,
        this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1,
        this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(parameters);
    }
    function Box3(min, max) {
        this.min = void 0 !== min ? min : new Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== max ? max : new Vector3(-1 / 0, -1 / 0, -1 / 0);
    }
    function Sphere(center, radius) {
        this.center = void 0 !== center ? center : new Vector3(), this.radius = void 0 !== radius ? radius : 0;
    }
    function Plane(normal, constant) {
        this.normal = void 0 !== normal ? normal : new Vector3(1, 0, 0), this.constant = void 0 !== constant ? constant : 0;
    }
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [ void 0 !== p0 ? p0 : new Plane(), void 0 !== p1 ? p1 : new Plane(), void 0 !== p2 ? p2 : new Plane(), void 0 !== p3 ? p3 : new Plane(), void 0 !== p4 ? p4 : new Plane(), void 0 !== p5 ? p5 : new Plane() ];
    }
    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
            var geometry = object.geometry, result = null, materialVariants = _depthMaterials, customMaterial = object.customDepthMaterial;
            if (isPointLight && (materialVariants = _distanceMaterials, customMaterial = object.customDistanceMaterial),
            customMaterial) result = customMaterial; else {
                var useMorphing = !1;
                material.morphTargets && (geometry && geometry.isBufferGeometry ? useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0 : geometry && geometry.isGeometry && (useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0)),
                object.isSkinnedMesh && !1 === material.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
                var useSkinning = object.isSkinnedMesh && material.skinning, variantIndex = 0;
                useMorphing && (variantIndex |= _MorphingFlag), useSkinning && (variantIndex |= _SkinningFlag),
                result = materialVariants[variantIndex];
            }
            if (_renderer.localClippingEnabled && !0 === material.clipShadows && 0 !== material.clippingPlanes.length) {
                var keyA = result.uuid, keyB = material.uuid, materialsForVariant = _materialCache[keyA];
                void 0 === materialsForVariant && (materialsForVariant = {}, _materialCache[keyA] = materialsForVariant);
                var cachedMaterial = materialsForVariant[keyB];
                void 0 === cachedMaterial && (cachedMaterial = result.clone(), materialsForVariant[keyB] = cachedMaterial),
                result = cachedMaterial;
            }
            result.visible = material.visible, result.wireframe = material.wireframe;
            var side = material.side;
            return scope.renderSingleSided && side == DoubleSide && (side = FrontSide), scope.renderReverseSided && (side === FrontSide ? side = BackSide : side === BackSide && (side = FrontSide)),
            result.side = side, result.clipShadows = material.clipShadows, result.clippingPlanes = material.clippingPlanes,
            result.clipIntersection = material.clipIntersection, result.wireframeLinewidth = material.wireframeLinewidth,
            result.linewidth = material.linewidth, isPointLight && result.isMeshDistanceMaterial && (result.referencePosition.copy(lightPositionWorld),
            result.nearDistance = shadowCameraNear, result.farDistance = shadowCameraFar), result;
        }
        function renderObject(object, camera, shadowCamera, isPointLight) {
            if (!1 !== object.visible) {
                if (object.layers.test(camera.layers) && (object.isMesh || object.isLine || object.isPoints) && object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object), material = object.material;
                    if (Array.isArray(material)) for (var groups = geometry.groups, k = 0, kl = groups.length; k < kl; k++) {
                        var group = groups[k], groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    } else if (material.visible) {
                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
                for (var children = object.children, i = 0, l = children.length; i < l; i++) renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
        for (var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = 1 + (_MorphingFlag | _SkinningFlag), _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {}, cubeDirections = [ new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0) ], cubeUps = [ new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1) ], cube2DViewPorts = [ new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4() ], i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = 0 != (i & _MorphingFlag), useSkinning = 0 != (i & _SkinningFlag), depthMaterial = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap,
        this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(lights, scene, camera) {
            if (!1 !== scope.enabled && (!1 !== scope.autoUpdate || !1 !== scope.needsUpdate) && 0 !== lights.length) {
                var _gl = _renderer.context, _state = _renderer.state;
                _state.disable(_gl.BLEND), _state.buffers.color.setClear(1, 1, 1, 1), _state.buffers.depth.setTest(!0),
                _state.setScissorTest(!1);
                for (var faceCount, i = 0, il = lights.length; i < il; i++) {
                    var light = lights[i], shadow = light.shadow, isPointLight = light && light.isPointLight;
                    if (void 0 !== shadow) {
                        var shadowCamera = shadow.camera;
                        if (_shadowMapSize.copy(shadow.mapSize), _shadowMapSize.min(_maxShadowMapSize),
                        isPointLight) {
                            var vpWidth = _shadowMapSize.x, vpHeight = _shadowMapSize.y;
                            cube2DViewPorts[0].set(2 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight),
                            cube2DViewPorts[2].set(3 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight),
                            cube2DViewPorts[4].set(3 * vpWidth, 0, vpWidth, vpHeight), cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight),
                            _shadowMapSize.x *= 4, _shadowMapSize.y *= 2;
                        }
                        if (null === shadow.map) {
                            var pars = {
                                minFilter: NearestFilter,
                                magFilter: NearestFilter,
                                format: RGBAFormat
                            };
                            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars), shadow.map.texture.name = light.name + ".shadowMap",
                            shadowCamera.updateProjectionMatrix();
                        }
                        shadow.isSpotLightShadow && shadow.update(light);
                        var shadowMap = shadow.map, shadowMatrix = shadow.matrix;
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld), shadowCamera.position.copy(_lightPositionWorld),
                        isPointLight ? (faceCount = 6, shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z)) : (faceCount = 1,
                        _lookTarget.setFromMatrixPosition(light.target.matrixWorld), shadowCamera.lookAt(_lookTarget),
                        shadowCamera.updateMatrixWorld(), shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        shadowMatrix.multiply(shadowCamera.projectionMatrix), shadowMatrix.multiply(shadowCamera.matrixWorldInverse)),
                        _renderer.setRenderTarget(shadowMap), _renderer.clear();
                        for (var face = 0; face < faceCount; face++) {
                            if (isPointLight) {
                                _lookTarget.copy(shadowCamera.position), _lookTarget.add(cubeDirections[face]),
                                shadowCamera.up.copy(cubeUps[face]), shadowCamera.lookAt(_lookTarget), shadowCamera.updateMatrixWorld();
                                var vpDimensions = cube2DViewPorts[face];
                                _state.viewport(vpDimensions);
                            }
                            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse),
                            _frustum.setFromMatrix(_projScreenMatrix), renderObject(scene, camera, shadowCamera, isPointLight);
                        }
                    } else console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                }
                scope.needsUpdate = !1;
            }
        };
    }
    function WebGLAttributes(gl) {
        function createBuffer(attribute, bufferType) {
            var array = attribute.array, usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW, buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer), gl.bufferData(bufferType, array, usage), attribute.onUploadCallback();
            var type = gl.FLOAT;
            return array instanceof Float32Array ? type = gl.FLOAT : array instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : array instanceof Uint16Array ? type = gl.UNSIGNED_SHORT : array instanceof Int16Array ? type = gl.SHORT : array instanceof Uint32Array ? type = gl.UNSIGNED_INT : array instanceof Int32Array ? type = gl.INT : array instanceof Int8Array ? type = gl.BYTE : array instanceof Uint8Array && (type = gl.UNSIGNED_BYTE),
            {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }
        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array, updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer), !1 === attribute.dynamic ? gl.bufferData(bufferType, array, gl.STATIC_DRAW) : -1 === updateRange.count ? gl.bufferSubData(bufferType, 0, array) : 0 === updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count)),
            updateRange.count = -1);
        }
        function get(attribute) {
            return attribute.isInterleavedBufferAttribute && (attribute = attribute.data), buffers[attribute.uuid];
        }
        function remove(attribute) {
            attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
            var data = buffers[attribute.uuid];
            data && (gl.deleteBuffer(data.buffer), delete buffers[attribute.uuid]);
        }
        function update(attribute, bufferType) {
            attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
            var data = buffers[attribute.uuid];
            void 0 === data ? buffers[attribute.uuid] = createBuffer(attribute, bufferType) : data.version < attribute.version && (updateBuffer(data.buffer, attribute, bufferType),
            data.version = attribute.version);
        }
        var buffers = {};
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    function Euler(x, y, z, order) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._order = order || Euler.DefaultOrder;
    }
    function Layers() {
        this.mask = 1;
    }
    function Object3D() {
        function onRotationChange() {
            quaternion.setFromEuler(rotation, !1);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, !1);
        }
        Object.defineProperty(this, "id", {
            value: object3DId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null,
        this.children = [], this.up = Object3D.DefaultUp.clone();
        var position = new Vector3(), rotation = new Euler(), quaternion = new Quaternion(), scale = new Vector3(1, 1, 1);
        rotation.onChange(onRotationChange), quaternion.onChange(onQuaternionChange), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: position
            },
            rotation: {
                enumerable: !0,
                value: rotation
            },
            quaternion: {
                enumerable: !0,
                value: quaternion
            },
            scale: {
                enumerable: !0,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0,
        this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0,
        this.userData = {};
    }
    function Camera() {
        Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4(),
        this.projectionMatrix = new Matrix4();
    }
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null,
        this.left = left, this.right = right, this.top = top, this.bottom = bottom, this.near = void 0 !== near ? near : .1,
        this.far = void 0 !== far ? far : 2e3, this.updateProjectionMatrix();
    }
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a, this.b = b, this.c = c, this.normal = normal && normal.isVector3 ? normal : new Vector3(),
        this.vertexNormals = Array.isArray(normal) ? normal : [], this.color = color && color.isColor ? color : new Color(),
        this.vertexColors = Array.isArray(color) ? color : [], this.materialIndex = void 0 !== materialIndex ? materialIndex : 0;
    }
    function Geometry() {
        Object.defineProperty(this, "id", {
            value: geometryId += 2
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [],
        this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], this.morphTargets = [],
        this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [],
        this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = _Math.generateUUID(), this.name = "", this.array = array, this.itemSize = itemSize,
        this.count = void 0 !== array ? array.length / itemSize : 0, this.normalized = !0 === normalized,
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0;
    }
    function Int8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    function Uint8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    function Int16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    function Uint16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    function Int32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    function Uint32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    function Float32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    function Float64BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    function DirectGeometry() {
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [],
        this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [],
        this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1;
    }
    function arrayMax(array) {
        if (0 === array.length) return -1 / 0;
        for (var max = array[0], i = 1, l = array.length; i < l; ++i) array[i] > max && (max = array[i]);
        return max;
    }
    function BufferGeometry() {
        Object.defineProperty(this, "id", {
            value: bufferGeometryId += 2
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "BufferGeometry",
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [],
        this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        };
    }
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        }, this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)),
        this.mergeVertices();
    }
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var ix, iy, segmentWidth = width / gridX, segmentHeight = height / gridY, widthHalf = width / 2, heightHalf = height / 2, depthHalf = depth / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, groupCount = 0, vector = new Vector3();
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir, vector[v] = y * vdir, vector[w] = depthHalf, vertices.push(vector.x, vector.y, vector.z),
                    vector[u] = 0, vector[v] = 0, vector[w] = depth > 0 ? 1 : -1, normals.push(vector.x, vector.y, vector.z),
                    uvs.push(ix / gridX), uvs.push(1 - iy / gridY), vertexCounter += 1;
                }
            }
            for (iy = 0; iy < gridY; iy++) for (ix = 0; ix < gridX; ix++) {
                var a = numberOfVertices + ix + gridX1 * iy, b = numberOfVertices + ix + gridX1 * (iy + 1), c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1), d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, materialIndex), groupStart += groupCount,
            numberOfVertices += vertexCounter;
        }
        BufferGeometry.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        width = width || 1, height = height || 1, depth = depth || 1, widthSegments = Math.floor(widthSegments) || 1,
        heightSegments = Math.floor(heightSegments) || 1, depthSegments = Math.floor(depthSegments) || 1;
        var indices = [], vertices = [], normals = [], uvs = [], numberOfVertices = 0, groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0),
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1),
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2),
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3),
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4),
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5),
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        }, this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments)),
        this.mergeVertices();
    }
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        }, width = width || 1, height = height || 1;
        var ix, iy, width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments) || 1, gridY = Math.floor(heightSegments) || 1, gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0), normals.push(0, 0, 1), uvs.push(ix / gridX), uvs.push(1 - iy / gridY);
            }
        }
        for (iy = 0; iy < gridY; iy++) for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy, b = ix + gridX1 * (iy + 1), c = ix + 1 + gridX1 * (iy + 1), d = ix + 1 + gridX1 * iy;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function MeshBasicMaterial(parameters) {
        Material.call(this), this.type = "MeshBasicMaterial", this.color = new Color(16777215),
        this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null,
        this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null,
        this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98,
        this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1,
        this.setValues(parameters);
    }
    function ShaderMaterial(parameters) {
        Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1,
        this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1,
        this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [ 1, 1, 1 ],
            uv: [ 0, 0 ],
            uv2: [ 0, 0 ]
        }, this.index0AttributeName = void 0, void 0 !== parameters && (void 0 !== parameters.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(parameters));
    }
    function Ray(origin, direction) {
        this.origin = void 0 !== origin ? origin : new Vector3(), this.direction = void 0 !== direction ? direction : new Vector3();
    }
    function Line3(start, end) {
        this.start = void 0 !== start ? start : new Vector3(), this.end = void 0 !== end ? end : new Vector3();
    }
    function Triangle(a, b, c) {
        this.a = void 0 !== a ? a : new Vector3(), this.b = void 0 !== b ? b : new Vector3(),
        this.c = void 0 !== c ? c : new Vector3();
    }
    function Mesh(geometry, material) {
        Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(),
        this.material = void 0 !== material ? material : new MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.drawMode = TrianglesDrawMode, this.updateMorphTargets();
    }
    function WebGLBackground(renderer, state, geometries, premultipliedAlpha) {
        function render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            null === background ? setClear(clearColor, clearAlpha) : background && background.isColor && (setClear(background, 1),
            forceClear = !0), (renderer.autoClear || forceClear) && renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil),
            background && background.isCubeTexture ? (void 0 === boxMesh && (boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                uniforms: ShaderLib.cube.uniforms,
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: !0,
                depthWrite: !1,
                fog: !1
            })), boxMesh.geometry.removeAttribute("normal"), boxMesh.geometry.removeAttribute("uv"),
            boxMesh.onBeforeRender = function(renderer, scene, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
            }, geometries.update(boxMesh.geometry)), boxMesh.material.uniforms.tCube.value = background,
            renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null)) : background && background.isTexture && (void 0 === planeCamera && (planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1),
            planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), geometries.update(planeMesh.geometry)), planeMesh.material.map = background,
            renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null));
        }
        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        var planeCamera, planeMesh, boxMesh, clearColor = new Color(0), clearAlpha = 0;
        return {
            getClearColor: function() {
                return clearColor;
            },
            setClearColor: function(color, alpha) {
                clearColor.set(color), clearAlpha = void 0 !== alpha ? alpha : 1, setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function() {
                return clearAlpha;
            },
            setClearAlpha: function(alpha) {
                clearAlpha = alpha, setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }
    function painterSortStable(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function reversePainterSortStable(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function WebGLRenderList() {
        function init() {
            renderItemsIndex = 0, opaque.length = 0, transparent.length = 0;
        }
        function push(object, geometry, material, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            void 0 === renderItem ? (renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: material.program,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            }, renderItems[renderItemsIndex] = renderItem) : (renderItem.id = object.id, renderItem.object = object,
            renderItem.geometry = geometry, renderItem.material = material, renderItem.program = material.program,
            renderItem.renderOrder = object.renderOrder, renderItem.z = z, renderItem.group = group),
            (!0 === material.transparent ? transparent : opaque).push(renderItem), renderItemsIndex++;
        }
        function sort() {
            opaque.length > 1 && opaque.sort(painterSortStable), transparent.length > 1 && transparent.sort(reversePainterSortStable);
        }
        var renderItems = [], renderItemsIndex = 0, opaque = [], transparent = [];
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            sort: sort
        };
    }
    function WebGLRenderLists() {
        function get(scene, camera) {
            var hash = scene.id + "," + camera.id, list = lists[hash];
            return void 0 === list && (list = new WebGLRenderList(), lists[hash] = list), list;
        }
        function dispose() {
            lists = {};
        }
        var lists = {};
        return {
            get: get,
            dispose: dispose
        };
    }
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences, length = objectInfluences.length, influences = influencesList[geometry.id];
            if (void 0 === influences) {
                influences = [];
                for (var i = 0; i < length; i++) influences[i] = [ i, 0 ];
                influencesList[geometry.id] = influences;
            }
            for (var morphTargets = material.morphTargets && geometry.morphAttributes.position, morphNormals = material.morphNormals && geometry.morphAttributes.normal, i = 0; i < length; i++) {
                var influence = influences[i];
                0 !== influence[1] && (morphTargets && geometry.removeAttribute("morphTarget" + i),
                morphNormals && geometry.removeAttribute("morphNormal" + i));
            }
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i, influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0], value = influence[1];
                    if (value) {
                        morphTargets && geometry.addAttribute("morphTarget" + i, morphTargets[index]), morphNormals && geometry.addAttribute("morphNormal" + i, morphNormals[index]),
                        morphInfluences[i] = value;
                        continue;
                    }
                }
                morphInfluences[i] = 0;
            }
            program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
        }
        var influencesList = {}, morphInfluences = new Float32Array(8);
        return {
            update: update
        };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function setIndex(value) {
            type = value.type, bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement), infoRender.calls++,
            infoRender.vertices += count, mode === gl.TRIANGLES ? infoRender.faces += count / 3 : mode === gl.POINTS && (infoRender.points += count);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (null === extension) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount),
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, mode === gl.TRIANGLES ? infoRender.faces += geometry.maxInstancedCount * count / 3 : mode === gl.POINTS && (infoRender.points += geometry.maxInstancedCount * count);
        }
        var mode, type, bytesPerElement;
        this.setMode = setMode, this.setIndex = setIndex, this.render = render, this.renderInstances = renderInstances;
    }
    function WebGLBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count), infoRender.calls++, infoRender.vertices += count,
            mode === gl.TRIANGLES ? infoRender.faces += count / 3 : mode === gl.POINTS && (infoRender.points += count);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (null === extension) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var position = geometry.attributes.position;
            position.isInterleavedBufferAttribute ? (count = position.data.count, extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)) : extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount),
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, mode === gl.TRIANGLES ? infoRender.faces += geometry.maxInstancedCount * count / 3 : mode === gl.POINTS && (infoRender.points += geometry.maxInstancedCount * count);
        }
        var mode;
        this.setMode = setMode, this.render = render, this.renderInstances = renderInstances;
    }
    function WebGLGeometries(gl, attributes, infoMemory) {
        function onGeometryDispose(event) {
            var geometry = event.target, buffergeometry = geometries[geometry.id];
            null !== buffergeometry.index && attributes.remove(buffergeometry.index);
            for (var name in buffergeometry.attributes) attributes.remove(buffergeometry.attributes[name]);
            geometry.removeEventListener("dispose", onGeometryDispose), delete geometries[geometry.id];
            var attribute = wireframeAttributes[geometry.id];
            attribute && (attributes.remove(attribute), delete wireframeAttributes[geometry.id]),
            attribute = wireframeAttributes[buffergeometry.id], attribute && (attributes.remove(attribute),
            delete wireframeAttributes[buffergeometry.id]), infoMemory.geometries--;
        }
        function get(object, geometry) {
            var buffergeometry = geometries[geometry.id];
            return buffergeometry || (geometry.addEventListener("dispose", onGeometryDispose),
            geometry.isBufferGeometry ? buffergeometry = geometry : geometry.isGeometry && (void 0 === geometry._bufferGeometry && (geometry._bufferGeometry = new BufferGeometry().setFromObject(object)),
            buffergeometry = geometry._bufferGeometry), geometries[geometry.id] = buffergeometry,
            infoMemory.geometries++, buffergeometry);
        }
        function update(geometry) {
            var index = geometry.index, geometryAttributes = geometry.attributes;
            null !== index && attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            for (var name in geometryAttributes) attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) for (var array = morphAttributes[name], i = 0, l = array.length; i < l; i++) attributes.update(array[i], gl.ARRAY_BUFFER);
        }
        function getWireframeAttribute(geometry) {
            var attribute = wireframeAttributes[geometry.id];
            if (attribute) return attribute;
            var indices = [], geometryIndex = geometry.index, geometryAttributes = geometry.attributes;
            if (null !== geometryIndex) for (var array = geometryIndex.array, i = 0, l = array.length; i < l; i += 3) {
                var a = array[i + 0], b = array[i + 1], c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            } else for (var array = geometryAttributes.position.array, i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                var a = i + 0, b = i + 1, c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
            return attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1),
            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER), wireframeAttributes[geometry.id] = attribute,
            attribute;
        }
        var geometries = {}, wireframeAttributes = {};
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }
    function UniformsCache() {
        var lights = {};
        return {
            get: function(light) {
                if (void 0 !== lights[light.id]) return lights[light.id];
                var uniforms;
                switch (light.type) {
                  case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;

                  case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;

                  case "RectAreaLight":
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                }
                return lights[light.id] = uniforms, uniforms;
            }
        };
    }
    function WebGLLights() {
        function setup(lights, shadows, camera) {
            for (var r = 0, g = 0, b = 0, directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0, viewMatrix = camera.matrixWorldInverse, i = 0, l = lights.length; i < l; i++) {
                var light = lights[i], color = light.color, intensity = light.intensity, distance = light.distance, shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight) r += color.r * intensity, g += color.g * intensity, b += color.b * intensity; else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.direction.setFromMatrixPosition(light.matrixWorld),
                    vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3),
                    uniforms.direction.transformDirection(viewMatrix), uniforms.shadow = light.castShadow,
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.directionalShadowMap[directionalLength] = shadowMap, state.directionalShadowMatrix[directionalLength] = light.shadow.matrix,
                    state.directional[directionalLength] = uniforms, directionalLength++;
                } else if (light.isSpotLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix),
                    uniforms.color.copy(color).multiplyScalar(intensity), uniforms.distance = distance,
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld),
                    uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix),
                    uniforms.coneCos = Math.cos(light.angle), uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)),
                    uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow,
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.spotShadowMap[spotLength] = shadowMap, state.spotShadowMatrix[spotLength] = light.shadow.matrix,
                    state.spot[spotLength] = uniforms, spotLength++;
                } else if (light.isRectAreaLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height)),
                    uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix),
                    matrix42.identity(), matrix4.copy(light.matrixWorld), matrix4.premultiply(viewMatrix),
                    matrix42.extractRotation(matrix4), uniforms.halfWidth.set(.5 * light.width, 0, 0),
                    uniforms.halfHeight.set(0, .5 * light.height, 0), uniforms.halfWidth.applyMatrix4(matrix42),
                    uniforms.halfHeight.applyMatrix4(matrix42), state.rectArea[rectAreaLength] = uniforms,
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix),
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.distance = light.distance,
                    uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow,
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize,
                        uniforms.shadowCameraNear = shadow.camera.near, uniforms.shadowCameraFar = shadow.camera.far;
                    }
                    state.pointShadowMap[pointLength] = shadowMap, state.pointShadowMatrix[pointLength] = light.shadow.matrix,
                    state.point[pointLength] = uniforms, pointLength++;
                } else if (light.isHemisphereLight) {
                    var uniforms = cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld), uniforms.direction.transformDirection(viewMatrix),
                    uniforms.direction.normalize(), uniforms.skyColor.copy(light.color).multiplyScalar(intensity),
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity), state.hemi[hemiLength] = uniforms,
                    hemiLength++;
                }
            }
            state.ambient[0] = r, state.ambient[1] = g, state.ambient[2] = b, state.directional.length = directionalLength,
            state.spot.length = spotLength, state.rectArea.length = rectAreaLength, state.point.length = pointLength,
            state.hemi.length = hemiLength, state.hash = directionalLength + "," + pointLength + "," + spotLength + "," + rectAreaLength + "," + hemiLength + "," + shadows.length;
        }
        var cache = new UniformsCache(), state = {
            hash: "",
            ambient: [ 0, 0, 0 ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, vector3 = new Vector3(), matrix4 = new Matrix4(), matrix42 = new Matrix4();
        return {
            setup: setup,
            state: state
        };
    }
    function WebGLObjects(geometries, infoRender) {
        function update(object) {
            var frame = infoRender.frame, geometry = object.geometry, buffergeometry = geometries.get(object, geometry);
            return updateList[buffergeometry.id] !== frame && (geometry.isGeometry && buffergeometry.updateFromObject(object),
            geometries.update(buffergeometry), updateList[buffergeometry.id] = frame), buffergeometry;
        }
        function clear() {
            updateList = {};
        }
        var updateList = {};
        return {
            update: update,
            clear: clear
        };
    }
    function addLineNumbers(string) {
        for (var lines = string.split("\n"), i = 0; i < lines.length; i++) lines[i] = i + 1 + ": " + lines[i];
        return lines.join("\n");
    }
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        return gl.shaderSource(shader, string), gl.compileShader(shader), !1 === gl.getShaderParameter(shader, gl.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== gl.getShaderInfoLog(shader) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string)),
        shader;
    }
    function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return [ "Linear", "( value )" ];

          case sRGBEncoding:
            return [ "sRGB", "( value )" ];

          case RGBEEncoding:
            return [ "RGBE", "( value )" ];

          case RGBM7Encoding:
            return [ "RGBM", "( value, 7.0 )" ];

          case RGBM16Encoding:
            return [ "RGBM", "( value, 16.0 )" ];

          case RGBDEncoding:
            return [ "RGBD", "( value, 256.0 )" ];

          case GammaEncoding:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw new Error("unsupported encoding: " + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;

          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;

          case Uncharted2ToneMapping:
            toneMappingName = "Uncharted2";
            break;

          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;

          default:
            throw new Error("unsupported toneMapping: " + toneMapping);
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        return extensions = extensions || {}, [ extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ].filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            !1 !== value && chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program) {
        for (var attributes = {}, n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i), name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return "" !== string;
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function parseIncludes(string) {
        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (void 0 === replace) throw new Error("Can not resolve #include <" + include + ">");
            return parseIncludes(replace);
        }
        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        function replace(match, start, end, snippet) {
            for (var unroll = "", i = parseInt(start); i < parseInt(end); i++) unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
            return unroll;
        }
        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return string.replace(pattern, replace);
    }
    function WebGLProgram(renderer, extensions, code, material, shader, parameters) {
        var gl = renderer.context, defines = material.defines, vertexShader = shader.vertexShader, fragmentShader = shader.fragmentShader, shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        parameters.shadowMapType === PCFShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : parameters.shadowMapType === PCFSoftShadowMap && (shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT");
        var envMapTypeDefine = "ENVMAP_TYPE_CUBE", envMapModeDefine = "ENVMAP_MODE_REFLECTION", envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
              case CubeReflectionMapping:
              case CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;

              case CubeUVReflectionMapping:
              case CubeUVRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;

              case EquirectangularReflectionMapping:
              case EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;

              case SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
            }
            switch (material.envMap.mapping) {
              case CubeRefractionMapping:
              case EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            }
            switch (material.combine) {
              case MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;

              case AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            }
        }
        var prefixVertex, prefixFragment, gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1, customExtensions = generateExtensions(material.extensions, parameters, extensions), customDefines = generateDefines(defines), program = gl.createProgram();
        material.isRawShaderMaterial ? (prefixVertex = [ customDefines ].filter(filterEmptyLine).join("\n"),
        prefixVertex.length > 0 && (prefixVertex += "\n"), prefixFragment = [ customExtensions, customDefines ].filter(filterEmptyLine).join("\n"),
        prefixFragment.length > 0 && (prefixFragment += "\n")) : (prefixVertex = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && !1 === parameters.flatShading ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(filterEmptyLine).join("\n"),
        prefixFragment = [ customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk.encodings_pars_fragment : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n" ].filter(filterEmptyLine).join("\n")),
        vertexShader = parseIncludes(vertexShader), vertexShader = replaceLightNums(vertexShader, parameters),
        fragmentShader = parseIncludes(fragmentShader), fragmentShader = replaceLightNums(fragmentShader, parameters),
        material.isShaderMaterial || (vertexShader = unrollLoops(vertexShader), fragmentShader = unrollLoops(fragmentShader));
        var vertexGlsl = prefixVertex + vertexShader, fragmentGlsl = prefixFragment + fragmentShader, glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl), glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader), gl.attachShader(program, glFragmentShader),
        void 0 !== material.index0AttributeName ? gl.bindAttribLocation(program, 0, material.index0AttributeName) : !0 === parameters.morphTargets && gl.bindAttribLocation(program, 0, "position"),
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program), vertexLog = gl.getShaderInfoLog(glVertexShader), fragmentLog = gl.getShaderInfoLog(glFragmentShader), runnable = !0, haveDiagnostics = !0;
        !1 === gl.getProgramParameter(program, gl.LINK_STATUS) ? (runnable = !1, console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog)) : "" !== programLog ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog) : "" !== vertexLog && "" !== fragmentLog || (haveDiagnostics = !1),
        haveDiagnostics && (this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        }), gl.deleteShader(glVertexShader), gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
            return void 0 === cachedUniforms && (cachedUniforms = new WebGLUniforms(gl, program, renderer)),
            cachedUniforms;
        };
        var cachedAttributes;
        return this.getAttributes = function() {
            return void 0 === cachedAttributes && (cachedAttributes = fetchAttributeLocations(gl, program)),
            cachedAttributes;
        }, this.destroy = function() {
            gl.deleteProgram(program), this.program = void 0;
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes();
                }
            }
        }), this.id = programIdCount++, this.code = code, this.usedTimes = 1, this.program = program,
        this.vertexShader = glVertexShader, this.fragmentShader = glFragmentShader, this;
    }
    function WebGLPrograms(renderer, extensions, capabilities) {
        function allocateBones(object) {
            var skeleton = object.skeleton, bones = skeleton.bones;
            if (capabilities.floatVertexTextures) return 1024;
            var nVertexUniforms = capabilities.maxVertexUniforms, nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4), maxBones = Math.min(nVertexMatrices, bones.length);
            return maxBones < bones.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + "."),
            0) : maxBones;
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            return map ? map.isTexture ? encoding = map.encoding : map.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            encoding = map.texture.encoding) : encoding = LinearEncoding, encoding === LinearEncoding && gammaOverrideLinear && (encoding = GammaEncoding),
            encoding;
        }
        var programs = [], shaderIDs = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow"
        }, parameterNames = [ "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering" ];
        this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type], maxBones = object.isSkinnedMesh ? allocateBones(object) : 0, precision = capabilities.precision;
            null !== material.precision && (precision = capabilities.getMaxPrecision(material.precision)) !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            var currentRenderTarget = renderer.getRenderTarget();
            return {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(currentRenderTarget ? currentRenderTarget.texture : null, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: void 0 !== material.depthPacking && material.depthPacking
            };
        }, this.getProgramCode = function(material, parameters) {
            var array = [];
            if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(material.fragmentShader),
            array.push(material.vertexShader)), void 0 !== material.defines) for (var name in material.defines) array.push(name),
            array.push(material.defines[name]);
            for (var i = 0; i < parameterNames.length; i++) array.push(parameters[parameterNames[i]]);
            return array.push(material.onBeforeCompile.toString()), array.push(renderer.gammaOutput),
            array.join();
        }, this.acquireProgram = function(material, shader, parameters, code) {
            for (var program, p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo, ++program.usedTimes;
                    break;
                }
            }
            return void 0 === program && (program = new WebGLProgram(renderer, extensions, code, material, shader, parameters),
            programs.push(program)), program;
        }, this.releaseProgram = function(program) {
            if (0 == --program.usedTimes) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1], programs.pop(), program.destroy();
            }
        }, this.programs = programs;
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, infoMemory) {
        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height), canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = Math.floor(image.width * scale), canvas.height = Math.floor(image.height * scale);
                return canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height),
                console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image),
                canvas;
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }
        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = _Math.floorPowerOfTwo(image.width), canvas.height = _Math.floorPowerOfTwo(image.height);
                return canvas.getContext("2d").drawImage(image, 0, 0, canvas.width, canvas.height),
                console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image),
                canvas;
            }
            return image;
        }
        function textureNeedsPowerOfTwo(texture) {
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
            return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function filterFallback(f) {
            return f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ? _gl.NEAREST : _gl.LINEAR;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener("dispose", onTextureDispose), deallocateTexture(texture),
            infoMemory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener("dispose", onRenderTargetDispose), deallocateRenderTarget(renderTarget),
            infoMemory.textures--;
        }
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) _gl.deleteTexture(textureProperties.__image__webglTextureCube); else {
                if (void 0 === textureProperties.__webglInit) return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            if (renderTarget) {
                if (void 0 !== textureProperties.__webglTexture && _gl.deleteTexture(textureProperties.__webglTexture),
                renderTarget.depthTexture && renderTarget.depthTexture.dispose(), renderTarget.isWebGLRenderTargetCube) for (var i = 0; i < 6; i++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]),
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]); else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer),
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                properties.remove(renderTarget.texture), properties.remove(renderTarget);
            }
        }
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture); else {
                    if (!1 !== image.complete) return void uploadTexture(textureProperties, texture, slot);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture);
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (6 === texture.image.length) if (texture.version > 0 && textureProperties.__version !== texture.version) {
                textureProperties.__image__webglTextureCube || (texture.addEventListener("dispose", onTextureDispose),
                textureProperties.__image__webglTextureCube = _gl.createTexture(), infoMemory.textures++),
                state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube),
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                for (var isCompressed = texture && texture.isCompressedTexture, isDataTexture = texture.image[0] && texture.image[0].isDataTexture, cubeImage = [], i = 0; i < 6; i++) cubeImage[i] = isCompressed || isDataTexture ? isDataTexture ? texture.image[i].image : texture.image[i] : clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                for (var i = 0; i < 6; i++) if (isCompressed) for (var mipmap, mipmaps = cubeImage[i].mipmaps, j = 0, jl = mipmaps.length; j < jl; j++) mipmap = mipmaps[j],
                texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else isDataTexture ? state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage) && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
                textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
            } else state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }
        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage ? (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS)),
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT)),
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter)),
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter))) : (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE),
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE), texture.wrapS === ClampToEdgeWrapping && texture.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture),
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter)),
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter)),
            texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture)),
            extension = extensions.get("EXT_texture_filter_anisotropic")) {
                if (texture.type === FloatType && null === extensions.get("OES_texture_float_linear")) return;
                if (texture.type === HalfFloatType && null === extensions.get("OES_texture_half_float_linear")) return;
                (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) && (_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())),
                properties.get(texture).__currentAnisotropy = texture.anisotropy);
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            void 0 === textureProperties.__webglInit && (textureProperties.__webglInit = !0,
            texture.addEventListener("dispose", onTextureDispose), textureProperties.__webglTexture = _gl.createTexture(),
            infoMemory.textures++), state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture),
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha),
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            textureNeedsPowerOfTwo(texture) && !1 === isPowerOfTwo(image) && (image = makePowerOfTwo(image));
            var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else _isWebGL2 && (internalFormat = _gl.DEPTH_COMPONENT16);
                texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT && texture.type !== UnsignedShortType && texture.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                texture.type = UnsignedShortType, glType = utils.convert(texture.type)), texture.format === DepthStencilFormat && (internalFormat = _gl.DEPTH_STENCIL,
                texture.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                texture.type = UnsignedInt248Type, glType = utils.convert(texture.type))), state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data); else if (texture.isCompressedTexture) for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i],
            texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
            textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage) && _gl.generateMipmap(_gl.TEXTURE_2D),
            textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format), glType = utils.convert(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer), renderTarget.depthBuffer && !renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height),
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : renderTarget.depthBuffer && renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height),
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height),
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
            if (renderTarget && renderTarget.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
            if (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), !renderTarget.depthTexture || !renderTarget.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            properties.get(renderTarget.depthTexture).__webglTexture && renderTarget.depthTexture.image.width === renderTarget.width && renderTarget.depthTexture.image.height === renderTarget.height || (renderTarget.depthTexture.image.width = renderTarget.width,
            renderTarget.depthTexture.image.height = renderTarget.height, renderTarget.depthTexture.needsUpdate = !0),
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0); else {
                if (renderTarget.depthTexture.format !== DepthStencilFormat) throw new Error("Unknown depthTexture format");
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
        }
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), isCube = !0 === renderTarget.isWebGLRenderTargetCube;
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]),
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
            } else _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer),
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener("dispose", onRenderTargetDispose), textureProperties.__webglTexture = _gl.createTexture(),
            infoMemory.textures++;
            var isCube = !0 === renderTarget.isWebGLRenderTargetCube, isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            } else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo) && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo),
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D),
            textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo) && _gl.generateMipmap(_gl.TEXTURE_2D),
            state.bindTexture(_gl.TEXTURE_2D, null);
            renderTarget.depthBuffer && setupDepthRenderbuffer(renderTarget);
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            if (textureNeedsGenerateMipmaps(texture, isPowerOfTwo(renderTarget))) {
                var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D, webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture), _gl.generateMipmap(target), state.bindTexture(target, null);
            }
        }
        var _isWebGL2 = "undefined" != typeof WebGL2RenderingContext && _gl instanceof window.WebGL2RenderingContext;
        this.setTexture2D = setTexture2D, this.setTextureCube = setTextureCube, this.setTextureCubeDynamic = setTextureCubeDynamic,
        this.setupRenderTarget = setupRenderTarget, this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }
    function WebGLProperties() {
        function get(object) {
            var uuid = object.uuid, map = properties[uuid];
            return void 0 === map && (map = {}, properties[uuid] = map), map;
        }
        function remove(object) {
            delete properties[object.uuid];
        }
        function clear() {
            properties = {};
        }
        var properties = {};
        return {
            get: get,
            remove: remove,
            clear: clear
        };
    }
    function WebGLState(gl, extensions, utils) {
        function ColorBuffer() {
            var locked = !1, color = new Vector4(), currentColorMask = null, currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function(colorMask) {
                    currentColorMask === colorMask || locked || (gl.colorMask(colorMask, colorMask, colorMask, colorMask),
                    currentColorMask = colorMask);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(r, g, b, a, premultipliedAlpha) {
                    !0 === premultipliedAlpha && (r *= a, g *= a, b *= a), color.set(r, g, b, a), !1 === currentColorClear.equals(color) && (gl.clearColor(r, g, b, a),
                    currentColorClear.copy(color));
                },
                reset: function() {
                    locked = !1, currentColorMask = null, currentColorClear.set(-1, 0, 0, 0);
                }
            };
        }
        function DepthBuffer() {
            var locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
            return {
                setTest: function(depthTest) {
                    depthTest ? enable(gl.DEPTH_TEST) : disable(gl.DEPTH_TEST);
                },
                setMask: function(depthMask) {
                    currentDepthMask === depthMask || locked || (gl.depthMask(depthMask), currentDepthMask = depthMask);
                },
                setFunc: function(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) switch (depthFunc) {
                          case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;

                          case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;

                          case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;

                          case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;

                          case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;

                          case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;

                          case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;

                          case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;

                          default:
                            gl.depthFunc(gl.LEQUAL);
                        } else gl.depthFunc(gl.LEQUAL);
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(depth) {
                    currentDepthClear !== depth && (gl.clearDepth(depth), currentDepthClear = depth);
                },
                reset: function() {
                    locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null;
            return {
                setTest: function(stencilTest) {
                    stencilTest ? enable(gl.STENCIL_TEST) : disable(gl.STENCIL_TEST);
                },
                setMask: function(stencilMask) {
                    currentStencilMask === stencilMask || locked || (gl.stencilMask(stencilMask), currentStencilMask = stencilMask);
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                    currentStencilFunc === stencilFunc && currentStencilRef === stencilRef && currentStencilFuncMask === stencilMask || (gl.stencilFunc(stencilFunc, stencilRef, stencilMask),
                    currentStencilFunc = stencilFunc, currentStencilRef = stencilRef, currentStencilFuncMask = stencilMask);
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                    currentStencilFail === stencilFail && currentStencilZFail === stencilZFail && currentStencilZPass === stencilZPass || (gl.stencilOp(stencilFail, stencilZFail, stencilZPass),
                    currentStencilFail = stencilFail, currentStencilZFail = stencilZFail, currentStencilZPass = stencilZPass);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(stencil) {
                    currentStencilClear !== stencil && (gl.clearStencil(stencil), currentStencilClear = stencil);
                },
                reset: function() {
                    locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null,
                    currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null,
                    currentStencilZPass = null, currentStencilClear = null;
                }
            };
        }
        function createTexture(type, target, count) {
            var data = new Uint8Array(4), texture = gl.createTexture();
            gl.bindTexture(type, texture), gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            return texture;
        }
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) newAttributes[i] = 0;
        }
        function enableAttribute(attribute) {
            if (newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute),
            enabledAttributes[attribute] = 1), 0 !== attributeDivisors[attribute]) {
                extensions.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attribute, 0),
                attributeDivisors[attribute] = 0;
            }
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            if (newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute),
            enabledAttributes[attribute] = 1), attributeDivisors[attribute] !== meshPerAttribute) {
                extensions.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attribute, meshPerAttribute),
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i),
            enabledAttributes[i] = 0);
        }
        function enable(id) {
            !0 !== capabilities[id] && (gl.enable(id), capabilities[id] = !0);
        }
        function disable(id) {
            !1 !== capabilities[id] && (gl.disable(id), capabilities[id] = !1);
        }
        function getCompressedTextureFormats() {
            if (null === compressedTextureFormats && (compressedTextureFormats = [], extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1"))) for (var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS), i = 0; i < formats.length; i++) compressedTextureFormats.push(formats[i]);
            return compressedTextureFormats;
        }
        function useProgram(program) {
            return currentProgram !== program && (gl.useProgram(program), currentProgram = program,
            !0);
        }
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending !== NoBlending ? enable(gl.BLEND) : disable(gl.BLEND), blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) switch (blending) {
                  case AdditiveBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)) : (gl.blendEquation(gl.FUNC_ADD),
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE));
                    break;

                  case SubtractiveBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD),
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR));
                    break;

                  case MultiplyBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD),
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR));
                    break;

                  default:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA));
                }
                currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null,
                currentBlendSrcAlpha = null, currentBlendDstAlpha = null;
            } else blendEquationAlpha = blendEquationAlpha || blendEquation, blendSrcAlpha = blendSrcAlpha || blendSrc,
            blendDstAlpha = blendDstAlpha || blendDst, blendEquation === currentBlendEquation && blendEquationAlpha === currentBlendEquationAlpha || (gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha)),
            currentBlendEquation = blendEquation, currentBlendEquationAlpha = blendEquationAlpha),
            blendSrc === currentBlendSrc && blendDst === currentBlendDst && blendSrcAlpha === currentBlendSrcAlpha && blendDstAlpha === currentBlendDstAlpha || (gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha)),
            currentBlendSrc = blendSrc, currentBlendDst = blendDst, currentBlendSrcAlpha = blendSrcAlpha,
            currentBlendDstAlpha = blendDstAlpha);
            currentBlending = blending, currentPremultipledAlpha = premultipliedAlpha;
        }
        function setMaterial(material) {
            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE), setFlipSided(material.side === BackSide),
            !0 === material.transparent ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending),
            depthBuffer.setFunc(material.depthFunc), depthBuffer.setTest(material.depthTest),
            depthBuffer.setMask(material.depthWrite), colorBuffer.setMask(material.colorWrite),
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        function setFlipSided(flipSided) {
            currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW),
            currentFlipSided = flipSided);
        }
        function setCullFace(cullFace) {
            cullFace !== CullFaceNone ? (enable(gl.CULL_FACE), cullFace !== currentCullFace && (cullFace === CullFaceBack ? gl.cullFace(gl.BACK) : cullFace === CullFaceFront ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : disable(gl.CULL_FACE),
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            width !== currentLineWidth && (lineWidthAvailable && gl.lineWidth(width), currentLineWidth = width);
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            polygonOffset ? (enable(gl.POLYGON_OFFSET_FILL), currentPolygonOffsetFactor === factor && currentPolygonOffsetUnits === units || (gl.polygonOffset(factor, units),
            currentPolygonOffsetFactor = factor, currentPolygonOffsetUnits = units)) : disable(gl.POLYGON_OFFSET_FILL);
        }
        function setScissorTest(scissorTest) {
            scissorTest ? enable(gl.SCISSOR_TEST) : disable(gl.SCISSOR_TEST);
        }
        function activeTexture(webglSlot) {
            void 0 === webglSlot && (webglSlot = gl.TEXTURE0 + maxTextures - 1), currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot),
            currentTextureSlot = webglSlot);
        }
        function bindTexture(webglType, webglTexture) {
            null === currentTextureSlot && activeTexture();
            var boundTexture = currentBoundTextures[currentTextureSlot];
            void 0 === boundTexture && (boundTexture = {
                type: void 0,
                texture: void 0
            }, currentBoundTextures[currentTextureSlot] = boundTexture), boundTexture.type === webglType && boundTexture.texture === webglTexture || (gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]),
            boundTexture.type = webglType, boundTexture.texture = webglTexture);
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error("THREE.WebGLState:", error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error("THREE.WebGLState:", error);
            }
        }
        function scissor(scissor) {
            !1 === currentScissor.equals(scissor) && (gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w),
            currentScissor.copy(scissor));
        }
        function viewport(viewport) {
            !1 === currentViewport.equals(viewport) && (gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w),
            currentViewport.copy(viewport));
        }
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) 1 === enabledAttributes[i] && (gl.disableVertexAttribArray(i),
            enabledAttributes[i] = 0);
            capabilities = {}, compressedTextureFormats = null, currentTextureSlot = null, currentBoundTextures = {},
            currentProgram = null, currentBlending = null, currentFlipSided = null, currentCullFace = null,
            colorBuffer.reset(), depthBuffer.reset(), stencilBuffer.reset();
        }
        var colorBuffer = new ColorBuffer(), depthBuffer = new DepthBuffer(), stencilBuffer = new StencilBuffer(), maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), newAttributes = new Uint8Array(maxVertexAttributes), enabledAttributes = new Uint8Array(maxVertexAttributes), attributeDivisors = new Uint8Array(maxVertexAttributes), capabilities = {}, compressedTextureFormats = null, currentProgram = null, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]), lineWidthAvailable = parseFloat(version) >= 1, currentTextureSlot = null, currentBoundTextures = {}, currentScissor = new Vector4(), currentViewport = new Vector4(), emptyTextures = {};
        return emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1),
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
        colorBuffer.setClear(0, 0, 0, 1), depthBuffer.setClear(1), stencilBuffer.setClear(0),
        enable(gl.DEPTH_TEST), depthBuffer.setFunc(LessEqualDepth), setFlipSided(!1), setCullFace(CullFaceBack),
        enable(gl.CULL_FACE), enable(gl.BLEND), setBlending(NormalBlending), {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        function getMaxAnisotropy() {
            if (void 0 !== maxAnisotropy) return maxAnisotropy;
            var extension = extensions.get("EXT_texture_filter_anisotropic");
            return maxAnisotropy = null !== extension ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        }
        function getMaxPrecision(precision) {
            if ("highp" === precision) {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
                precision = "mediump";
            }
            return "mediump" === precision && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        var maxAnisotropy, precision = void 0 !== parameters.precision ? parameters.precision : "highp", maxPrecision = getMaxPrecision(precision);
        maxPrecision !== precision && (console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead."),
        precision = maxPrecision);
        var logarithmicDepthBuffer = !0 === parameters.logarithmicDepthBuffer, maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS), maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures = maxVertexTextures > 0, floatFragmentTextures = !!extensions.get("OES_texture_float");
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: vertexTextures && floatFragmentTextures
        };
    }
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== fov ? fov : 50,
        this.zoom = 1, this.near = void 0 !== near ? near : .1, this.far = void 0 !== far ? far : 2e3,
        this.focus = 10, this.aspect = void 0 !== aspect ? aspect : 1, this.view = null,
        this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    function ArrayCamera(array) {
        PerspectiveCamera.call(this), this.cameras = array || [];
    }
    function WebVRManager(renderer) {
        function onVRDisplayPresentChange() {
            if (null !== device && device.isPresenting) {
                var eyeParameters = device.getEyeParameters("left"), renderWidth = eyeParameters.renderWidth, renderHeight = eyeParameters.renderHeight;
                currentPixelRatio = renderer.getPixelRatio(), currentSize = renderer.getSize(),
                renderer.setDrawingBufferSize(2 * renderWidth, renderHeight, 1);
            } else scope.enabled && renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
        }
        var scope = this, device = null, frameData = null;
        "undefined" != typeof window && "VRFrameData" in window && (frameData = new window.VRFrameData());
        var matrixWorldInverse = new Matrix4(), standingMatrix = new Matrix4(), standingMatrixInverse = new Matrix4(), cameraL = new PerspectiveCamera();
        cameraL.bounds = new Vector4(0, 0, .5, 1), cameraL.layers.enable(1);
        var cameraR = new PerspectiveCamera();
        cameraR.bounds = new Vector4(.5, 0, .5, 1), cameraR.layers.enable(2);
        var cameraVR = new ArrayCamera([ cameraL, cameraR ]);
        cameraVR.layers.enable(1), cameraVR.layers.enable(2);
        var currentSize, currentPixelRatio;
        "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, !1),
        this.enabled = !1, this.standing = !1, this.getDevice = function() {
            return device;
        }, this.setDevice = function(value) {
            void 0 !== value && (device = value);
        }, this.getCamera = function(camera) {
            if (null === device) return camera;
            device.depthNear = camera.near, device.depthFar = camera.far, device.getFrameData(frameData);
            var pose = frameData.pose;
            null !== pose.position ? camera.position.fromArray(pose.position) : camera.position.set(0, 0, 0),
            null !== pose.orientation && camera.quaternion.fromArray(pose.orientation), camera.updateMatrixWorld();
            var stageParameters = device.stageParameters;
            if (this.standing && stageParameters && (standingMatrix.fromArray(stageParameters.sittingToStandingTransform),
            standingMatrixInverse.getInverse(standingMatrix), camera.matrixWorld.multiply(standingMatrix),
            camera.matrixWorldInverse.multiply(standingMatrixInverse)), !1 === device.isPresenting) return camera;
            cameraL.near = camera.near, cameraR.near = camera.near, cameraL.far = camera.far,
            cameraR.far = camera.far, cameraVR.matrixWorld.copy(camera.matrixWorld), cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse),
            cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix), cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix),
            this.standing && stageParameters && (cameraL.matrixWorldInverse.multiply(standingMatrixInverse),
            cameraR.matrixWorldInverse.multiply(standingMatrixInverse));
            var parent = camera.parent;
            null !== parent && (matrixWorldInverse.getInverse(parent.matrixWorld), cameraL.matrixWorldInverse.multiply(matrixWorldInverse),
            cameraR.matrixWorldInverse.multiply(matrixWorldInverse)), cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse),
            cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse), cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix),
            cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix), cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            var layers = device.getLayers();
            if (layers.length) {
                var layer = layers[0];
                null !== layer.leftBounds && 4 === layer.leftBounds.length && cameraL.bounds.fromArray(layer.leftBounds),
                null !== layer.rightBounds && 4 === layer.rightBounds.length && cameraR.bounds.fromArray(layer.rightBounds);
            }
            return cameraVR;
        }, this.getStandingMatrix = function() {
            return standingMatrix;
        }, this.submitFrame = function() {
            device && device.isPresenting && device.submitFrame();
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
        };
    }
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function(name) {
                if (void 0 !== extensions[name]) return extensions[name];
                var extension;
                switch (name) {
                  case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;

                  case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;

                  case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;

                  case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;

                  case "WEBGL_compressed_texture_etc1":
                    extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                    break;

                  default:
                    extension = gl.getExtension(name);
                }
                return null === extension && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."),
                extensions[name] = extension, extension;
            }
        };
    }
    function WebGLClipping() {
        function resetGlobalState() {
            uniform.value !== globalState && (uniform.value = globalState, uniform.needsUpdate = numGlobalPlanes > 0),
            scope.numPlanes = numGlobalPlanes, scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = null !== planes ? planes.length : 0, dstArray = null;
            if (0 !== nPlanes) {
                if (dstArray = uniform.value, !0 !== skipTransform || null === dstArray) {
                    var flatSize = dstOffset + 4 * nPlanes, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix), (null === dstArray || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix),
                    plane.normal.toArray(dstArray, i4), dstArray[i4 + 3] = plane.constant;
                }
                uniform.value = dstArray, uniform.needsUpdate = !0;
            }
            return scope.numPlanes = nPlanes, dstArray;
        }
        var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = !1, renderingShadows = !1, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = uniform, this.numPlanes = 0, this.numIntersection = 0, this.init = function(planes, enableLocalClipping, camera) {
            var enabled = 0 !== planes.length || enableLocalClipping || 0 !== numGlobalPlanes || localClippingEnabled;
            return localClippingEnabled = enableLocalClipping, globalState = projectPlanes(planes, camera, 0),
            numGlobalPlanes = planes.length, enabled;
        }, this.beginShadows = function() {
            renderingShadows = !0, projectPlanes(null);
        }, this.endShadows = function() {
            renderingShadows = !1, resetGlobalState();
        }, this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || null === planes || 0 === planes.length || renderingShadows && !clipShadows) renderingShadows ? projectPlanes(null) : resetGlobalState(); else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = 4 * nGlobal, dstArray = cache.clippingState || null;
                uniform.value = dstArray, dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) dstArray[i] = globalState[i];
                cache.clippingState = dstArray, this.numIntersection = clipIntersection ? this.numPlanes : 0,
                this.numPlanes += nGlobal;
            }
        };
    }
    function WebGLUtils(gl, extensions) {
        function convert(p) {
            var extension;
            if (p === RepeatWrapping) return gl.REPEAT;
            if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;
            if (p === NearestFilter) return gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter) return gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType) return gl.BYTE;
            if (p === ShortType) return gl.SHORT;
            if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
            if (p === IntType) return gl.INT;
            if (p === UnsignedIntType) return gl.UNSIGNED_INT;
            if (p === FloatType) return gl.FLOAT;
            if (p === HalfFloatType && null !== (extension = extensions.get("OES_texture_half_float"))) return extension.HALF_FLOAT_OES;
            if (p === AlphaFormat) return gl.ALPHA;
            if (p === RGBFormat) return gl.RGB;
            if (p === RGBAFormat) return gl.RGBA;
            if (p === LuminanceFormat) return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
            if (p === AddEquation) return gl.FUNC_ADD;
            if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor) return gl.ZERO;
            if (p === OneFactor) return gl.ONE;
            if (p === SrcColorFactor) return gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor) return gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;
            if ((p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) && null !== (extension = extensions.get("WEBGL_compressed_texture_s3tc"))) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if ((p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) && null !== (extension = extensions.get("WEBGL_compressed_texture_pvrtc"))) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (p === RGB_ETC1_Format && null !== (extension = extensions.get("WEBGL_compressed_texture_etc1"))) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            if ((p === MinEquation || p === MaxEquation) && null !== (extension = extensions.get("EXT_blend_minmax"))) {
                if (p === MinEquation) return extension.MIN_EXT;
                if (p === MaxEquation) return extension.MAX_EXT;
            }
            return p === UnsignedInt248Type && null !== (extension = extensions.get("WEBGL_depth_texture")) ? extension.UNSIGNED_INT_24_8_WEBGL : 0;
        }
        return {
            convert: convert
        };
    }
    function WebGLRenderer(parameters) {
        function getTargetPixelRatio() {
            return null === _currentRenderTarget ? _pixelRatio : 1;
        }
        function initGLContext() {
            extensions = new WebGLExtensions(_gl), extensions.get("WEBGL_depth_texture"), extensions.get("OES_texture_float"),
            extensions.get("OES_texture_float_linear"), extensions.get("OES_texture_half_float"),
            extensions.get("OES_texture_half_float_linear"), extensions.get("OES_standard_derivatives"),
            extensions.get("OES_element_index_uint"), extensions.get("ANGLE_instanced_arrays"),
            utils = new WebGLUtils(_gl, extensions), capabilities = new WebGLCapabilities(_gl, extensions, parameters),
            state = new WebGLState(_gl, extensions, utils), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio)),
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio)), properties = new WebGLProperties(),
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, _infoMemory),
            attributes = new WebGLAttributes(_gl), geometries = new WebGLGeometries(_gl, attributes, _infoMemory),
            objects = new WebGLObjects(geometries, _infoRender), morphtargets = new WebGLMorphtargets(_gl),
            programCache = new WebGLPrograms(_this, extensions, capabilities), lights = new WebGLLights(),
            renderLists = new WebGLRenderLists(), background = new WebGLBackground(_this, state, geometries, _premultipliedAlpha),
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender), indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender),
            flareRenderer = new WebGLFlareRenderer(_this, _gl, state, textures, capabilities),
            spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities),
            _this.info.programs = programCache.programs, _this.context = _gl, _this.capabilities = capabilities,
            _this.extensions = extensions, _this.properties = properties, _this.renderLists = renderLists,
            _this.state = state;
        }
        function onContextLost(event) {
            event.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _isContextLost = !0;
        }
        function onContextRestore() {
            console.log("THREE.WebGLRenderer: Context Restored."), _isContextLost = !1, initGLContext();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener("dispose", onMaterialDispose), deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material), properties.remove(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = void 0, void 0 !== programInfo && programCache.releaseProgram(programInfo);
        }
        function renderObjectImmediate(object, program, material) {
            object.render(function(object) {
                _this.renderBufferImmediate(object, program, material);
            });
        }
        function setupVertexAttributes(material, program, geometry, startIndex) {
            if (geometry && geometry.isInstancedBufferGeometry && null === extensions.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === startIndex && (startIndex = 0), state.initAttributes();
            var geometryAttributes = geometry.attributes, programAttributes = program.getAttributes(), materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (void 0 !== geometryAttribute) {
                        var normalized = geometryAttribute.normalized, size = geometryAttribute.itemSize, attribute = attributes.get(geometryAttribute);
                        if (void 0 === attribute) continue;
                        var buffer = attribute.buffer, type = attribute.type, bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data, stride = data.stride, offset = geometryAttribute.offset;
                            data && data.isInstancedInterleavedBuffer ? (state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute),
                            void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = data.meshPerAttribute * data.count)) : state.enableAttribute(programAttribute),
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else geometryAttribute.isInstancedBufferAttribute ? (state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute),
                        void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count)) : state.enableAttribute(programAttribute),
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                    } else if (void 0 !== materialDefaultAttributeValues) {
                        var value = materialDefaultAttributeValues[name];
                        if (void 0 !== value) switch (value.length) {
                          case 2:
                            _gl.vertexAttrib2fv(programAttribute, value);
                            break;

                          case 3:
                            _gl.vertexAttrib3fv(programAttribute, value);
                            break;

                          case 4:
                            _gl.vertexAttrib4fv(programAttribute, value);
                            break;

                          default:
                            _gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        function start() {
            if (!isAnimating) {
                var device = vr.getDevice();
                device && device.isPresenting ? device.requestAnimationFrame(loop) : window.requestAnimationFrame(loop),
                isAnimating = !0;
            }
        }
        function loop(time) {
            null !== onAnimationFrame && onAnimationFrame(time);
            var device = vr.getDevice();
            device && device.isPresenting ? device.requestAnimationFrame(loop) : window.requestAnimationFrame(loop);
        }
        function projectObject(object, camera, sortObjects) {
            if (!1 !== object.visible) {
                if (object.layers.test(camera.layers)) if (object.isLight) lightsArray.push(object),
                object.castShadow && shadowsArray.push(object); else if (object.isSprite) object.frustumCulled && !_frustum.intersectsSprite(object) || spritesArray.push(object); else if (object.isLensFlare) flaresArray.push(object); else if (object.isImmediateRenderObject) sortObjects && _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix),
                currentRenderList.push(object, null, object.material, _vector3.z, null); else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.update(),
                !object.frustumCulled || _frustum.intersectsObject(object))) {
                    sortObjects && _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    var geometry = objects.update(object), material = object.material;
                    if (Array.isArray(material)) for (var groups = geometry.groups, i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i], groupMaterial = material[group.materialIndex];
                        groupMaterial && groupMaterial.visible && currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                    } else material.visible && currentRenderList.push(object, geometry, material, _vector3.z, null);
                }
                for (var children = object.children, i = 0, l = children.length; i < l; i++) projectObject(children[i], camera, sortObjects);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i], object = renderItem.object, geometry = renderItem.geometry, material = void 0 === overrideMaterial ? renderItem.material : overrideMaterial, group = renderItem.group;
                if (camera.isArrayCamera) {
                    _currentArrayCamera = camera;
                    for (var cameras = camera.cameras, j = 0, jl = cameras.length; j < jl; j++) {
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            var bounds = camera2.bounds, x = bounds.x * _width, y = bounds.y * _height, width = bounds.z * _width, height = bounds.w * _height;
                            state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio)),
                            renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                } else _currentArrayCamera = null, renderObject(object, scene, camera, geometry, material, group);
            }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
            if (object.onBeforeRender(_this, scene, camera, geometry, material, group), object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld),
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix), object.isImmediateRenderObject) {
                state.setMaterial(material);
                var program = setProgram(camera, scene.fog, material, object);
                _currentGeometryProgram = "", renderObjectImmediate(object, program, material);
            } else _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material), parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object), code = programCache.getProgramCode(material, parameters), program = materialProperties.program, programChange = !0;
            if (void 0 === program) material.addEventListener("dispose", onMaterialDispose); else if (program.code !== code) releaseMaterialProgramReference(material); else {
                if (void 0 !== parameters.shaderID) return;
                programChange = !1;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else materialProperties.shader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
                material.onBeforeCompile(materialProperties.shader), program = programCache.acquireProgram(material, materialProperties.shader, parameters, code),
                materialProperties.program = program, material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) programAttributes["morphTarget" + i] >= 0 && material.numSupportedMorphTargets++;
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) programAttributes["morphNormal" + i] >= 0 && material.numSupportedMorphNormals++;
            }
            var uniforms = materialProperties.shader.uniforms;
            (material.isShaderMaterial || material.isRawShaderMaterial) && !0 !== material.clipping || (materialProperties.numClippingPlanes = _clipping.numPlanes,
            materialProperties.numIntersection = _clipping.numIntersection, uniforms.clippingPlanes = _clipping.uniform),
            materialProperties.fog = fog, materialProperties.lightsHash = lights.state.hash,
            material.lights && (uniforms.ambientLightColor.value = lights.state.ambient, uniforms.directionalLights.value = lights.state.directional,
            uniforms.spotLights.value = lights.state.spot, uniforms.rectAreaLights.value = lights.state.rectArea,
            uniforms.pointLights.value = lights.state.point, uniforms.hemisphereLights.value = lights.state.hemi,
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap, uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix,
            uniforms.spotShadowMap.value = lights.state.spotShadowMap, uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix,
            uniforms.pointShadowMap.value = lights.state.pointShadowMap, uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix);
            var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            if (_clippingEnabled && (_localClippingEnabled || camera !== _currentCamera)) {
                var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
            !1 === material.needsUpdate && (void 0 === materialProperties.program ? material.needsUpdate = !0 : material.fog && materialProperties.fog !== fog ? material.needsUpdate = !0 : material.lights && materialProperties.lightsHash !== lights.state.hash ? material.needsUpdate = !0 : void 0 === materialProperties.numClippingPlanes || materialProperties.numClippingPlanes === _clipping.numPlanes && materialProperties.numIntersection === _clipping.numIntersection || (material.needsUpdate = !0)),
            material.needsUpdate && (initMaterial(material, fog, object), material.needsUpdate = !1);
            var refreshProgram = !1, refreshMaterial = !1, refreshLights = !1, program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
            if (state.useProgram(program.program) && (refreshProgram = !0, refreshMaterial = !0,
            refreshLights = !0), material.id !== _currentMaterialId && (_currentMaterialId = material.id,
            refreshMaterial = !0), refreshProgram || camera !== _currentCamera) {
                if (p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix), capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)),
                _currentCamera !== (_currentArrayCamera || camera) && (_currentCamera = _currentArrayCamera || camera,
                refreshMaterial = !0, refreshLights = !0), material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    void 0 !== uCamPos && uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
                (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) && p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, "bindMatrix"), p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (void 0 === skeleton.boneTexture) {
                            var size = Math.sqrt(4 * bones.length);
                            size = _Math.ceilPowerOfTwo(size), size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4);
                            boneMatrices.set(skeleton.boneMatrices);
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            skeleton.boneMatrices = boneMatrices, skeleton.boneTexture = boneTexture, skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture), p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                    } else p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
                }
            }
            return refreshMaterial && (p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure),
            p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint),
            material.lights && markUniformsLightsNeedsUpdate(m_uniforms, refreshLights), fog && material.fog && refreshUniformsFog(m_uniforms, fog),
            material.isMeshBasicMaterial ? refreshUniformsCommon(m_uniforms, material) : material.isMeshLambertMaterial ? (refreshUniformsCommon(m_uniforms, material),
            refreshUniformsLambert(m_uniforms, material)) : material.isMeshPhongMaterial ? (refreshUniformsCommon(m_uniforms, material),
            material.isMeshToonMaterial ? refreshUniformsToon(m_uniforms, material) : refreshUniformsPhong(m_uniforms, material)) : material.isMeshStandardMaterial ? (refreshUniformsCommon(m_uniforms, material),
            material.isMeshPhysicalMaterial ? refreshUniformsPhysical(m_uniforms, material) : refreshUniformsStandard(m_uniforms, material)) : material.isMeshDepthMaterial ? (refreshUniformsCommon(m_uniforms, material),
            refreshUniformsDepth(m_uniforms, material)) : material.isMeshDistanceMaterial ? (refreshUniformsCommon(m_uniforms, material),
            refreshUniformsDistance(m_uniforms, material)) : material.isMeshNormalMaterial ? (refreshUniformsCommon(m_uniforms, material),
            refreshUniformsNormal(m_uniforms, material)) : material.isLineBasicMaterial ? (refreshUniformsLine(m_uniforms, material),
            material.isLineDashedMaterial && refreshUniformsDash(m_uniforms, material)) : material.isPointsMaterial ? refreshUniformsPoints(m_uniforms, material) : material.isShadowMaterial && (m_uniforms.color.value = material.color,
            m_uniforms.opacity.value = material.opacity), void 0 !== m_uniforms.ltcMat && (m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE),
            void 0 !== m_uniforms.ltcMag && (m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE),
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this)),
            p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix), p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix),
            p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld), program;
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity, material.color && (uniforms.diffuse.value = material.color),
            material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity),
            material.map && (uniforms.map.value = material.map), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap),
            material.specularMap && (uniforms.specularMap.value = material.specularMap), material.envMap && (uniforms.envMap.value = material.envMap,
            uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1,
            uniforms.reflectivity.value = material.reflectivity, uniforms.refractionRatio.value = material.refractionRatio),
            material.lightMap && (uniforms.lightMap.value = material.lightMap, uniforms.lightMapIntensity.value = material.lightMapIntensity),
            material.aoMap && (uniforms.aoMap.value = material.aoMap, uniforms.aoMapIntensity.value = material.aoMapIntensity);
            var uvScaleMap;
            if (material.map ? uvScaleMap = material.map : material.specularMap ? uvScaleMap = material.specularMap : material.displacementMap ? uvScaleMap = material.displacementMap : material.normalMap ? uvScaleMap = material.normalMap : material.bumpMap ? uvScaleMap = material.bumpMap : material.roughnessMap ? uvScaleMap = material.roughnessMap : material.metalnessMap ? uvScaleMap = material.metalnessMap : material.alphaMap ? uvScaleMap = material.alphaMap : material.emissiveMap && (uvScaleMap = material.emissiveMap),
            void 0 !== uvScaleMap) {
                if (uvScaleMap.isWebGLRenderTarget && (uvScaleMap = uvScaleMap.texture), !0 === uvScaleMap.matrixAutoUpdate) {
                    var offset = uvScaleMap.offset, repeat = uvScaleMap.repeat, rotation = uvScaleMap.rotation, center = uvScaleMap.center;
                    uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize, uniforms.totalSize.value = material.dashSize + material.gapSize,
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            if (uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity,
            uniforms.size.value = material.size * _pixelRatio, uniforms.scale.value = .5 * _height,
            uniforms.map.value = material.map, null !== material.map) {
                if (!0 === material.map.matrixAutoUpdate) {
                    var offset = material.map.offset, repeat = material.map.repeat, rotation = material.map.rotation, center = material.map.center;
                    material.map.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
                }
                uniforms.uvTransform.value.copy(material.map.matrix);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color, fog.isFog ? (uniforms.fogNear.value = fog.near,
            uniforms.fogFar.value = fog.far) : fog.isFogExp2 && (uniforms.fogDensity.value = fog.density);
        }
        function refreshUniformsLambert(uniforms, material) {
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap);
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular, uniforms.shininess.value = Math.max(material.shininess, 1e-4),
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap,
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap,
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function refreshUniformsToon(uniforms, material) {
            refreshUniformsPhong(uniforms, material), material.gradientMap && (uniforms.gradientMap.value = material.gradientMap);
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness, uniforms.metalness.value = material.metalness,
            material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap),
            material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap),
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap,
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap,
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias),
            material.envMap && (uniforms.envMapIntensity.value = material.envMapIntensity);
        }
        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat, uniforms.clearCoatRoughness.value = material.clearCoatRoughness,
            refreshUniformsStandard(uniforms, material);
        }
        function refreshUniformsDepth(uniforms, material) {
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function refreshUniformsDistance(uniforms, material) {
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias),
            uniforms.referencePosition.value.copy(material.referencePosition), uniforms.nearDistance.value = material.nearDistance,
            uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
            material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, uniforms.bumpScale.value = material.bumpScale),
            material.normalMap && (uniforms.normalMap.value = material.normalMap, uniforms.normalScale.value.copy(material.normalScale)),
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value, uniforms.directionalLights.needsUpdate = value,
            uniforms.pointLights.needsUpdate = value, uniforms.spotLights.needsUpdate = value,
            uniforms.rectAreaLights.needsUpdate = value, uniforms.hemisphereLights.needsUpdate = value;
        }
        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            return textureUnit >= capabilities.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures),
            _usedTextureUnits += 1, textureUnit;
        }
        console.log("THREE.WebGLRenderer", REVISION), parameters = parameters || {};
        var _canvas = void 0 !== parameters.canvas ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = void 0 !== parameters.context ? parameters.context : null, _alpha = void 0 !== parameters.alpha && parameters.alpha, _depth = void 0 === parameters.depth || parameters.depth, _stencil = void 0 === parameters.stencil || parameters.stencil, _antialias = void 0 !== parameters.antialias && parameters.antialias, _premultipliedAlpha = void 0 === parameters.premultipliedAlpha || parameters.premultipliedAlpha, _preserveDrawingBuffer = void 0 !== parameters.preserveDrawingBuffer && parameters.preserveDrawingBuffer, lightsArray = [], shadowsArray = [], currentRenderList = null, spritesArray = [], flaresArray = [];
        this.domElement = _canvas, this.context = null, this.autoClear = !0, this.autoClearColor = !0,
        this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [],
        this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1,
        this.physicallyCorrectLights = !1, this.toneMapping = LinearToneMapping, this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var _this = this, _isContextLost = !1, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _usedTextureUnits = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = !1, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = !1, _localClippingEnabled = !1, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _infoMemory = {
            geometries: 0,
            textures: 0
        }, _infoRender = {
            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
        this.info = {
            render: _infoRender,
            memory: _infoMemory,
            programs: null
        };
        var _gl;
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };
            if (null === (_gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes))) throw null !== _canvas.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            void 0 === _gl.getShaderPrecisionFormat && (_gl.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                };
            }), _canvas.addEventListener("webglcontextlost", onContextLost, !1), _canvas.addEventListener("webglcontextrestored", onContextRestore, !1);
        } catch (error) {
            console.error("THREE.WebGLRenderer: " + error);
        }
        var extensions, capabilities, state, properties, textures, attributes, geometries, objects, lights, programCache, renderLists, background, morphtargets, bufferRenderer, indexedBufferRenderer, flareRenderer, spriteRenderer, utils;
        initGLContext();
        var vr = new WebVRManager(_this);
        this.vr = vr;
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap, this.getContext = function() {
            return _gl;
        }, this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        }, this.forceContextLoss = function() {
            var extension = extensions.get("WEBGL_lose_context");
            extension && extension.loseContext();
        }, this.forceContextRestore = function() {
            var extension = extensions.get("WEBGL_lose_context");
            extension && extension.restoreContext();
        }, this.getPixelRatio = function() {
            return _pixelRatio;
        }, this.setPixelRatio = function(value) {
            void 0 !== value && (_pixelRatio = value, this.setSize(_width, _height, !1));
        }, this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        }, this.setSize = function(width, height, updateStyle) {
            var device = vr.getDevice();
            if (device && device.isPresenting) return void console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            _width = width, _height = height, _canvas.width = width * _pixelRatio, _canvas.height = height * _pixelRatio,
            !1 !== updateStyle && (_canvas.style.width = width + "px", _canvas.style.height = height + "px"),
            this.setViewport(0, 0, width, height);
        }, this.getDrawingBufferSize = function() {
            return {
                width: _width * _pixelRatio,
                height: _height * _pixelRatio
            };
        }, this.setDrawingBufferSize = function(width, height, pixelRatio) {
            _width = width, _height = height, _pixelRatio = pixelRatio, _canvas.width = width * pixelRatio,
            _canvas.height = height * pixelRatio, this.setViewport(0, 0, width, height);
        }, this.setViewport = function(x, y, width, height) {
            _viewport.set(x, _height - y - height, width, height), state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        }, this.setScissor = function(x, y, width, height) {
            _scissor.set(x, _height - y - height, width, height), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        }, this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        }, this.getClearColor = function() {
            return background.getClearColor();
        }, this.setClearColor = function() {
            background.setClearColor.apply(background, arguments);
        }, this.getClearAlpha = function() {
            return background.getClearAlpha();
        }, this.setClearAlpha = function() {
            background.setClearAlpha.apply(background, arguments);
        }, this.clear = function(color, depth, stencil) {
            var bits = 0;
            (void 0 === color || color) && (bits |= _gl.COLOR_BUFFER_BIT), (void 0 === depth || depth) && (bits |= _gl.DEPTH_BUFFER_BIT),
            (void 0 === stencil || stencil) && (bits |= _gl.STENCIL_BUFFER_BIT), _gl.clear(bits);
        }, this.clearColor = function() {
            this.clear(!0, !1, !1);
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1);
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0);
        }, this.clearTarget = function(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget), this.clear(color, depth, stencil);
        }, this.dispose = function() {
            _canvas.removeEventListener("webglcontextlost", onContextLost, !1), _canvas.removeEventListener("webglcontextrestored", onContextRestore, !1),
            renderLists.dispose(), vr.dispose();
        }, this.renderBufferImmediate = function(object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            object.hasPositions && !buffers.position && (buffers.position = _gl.createBuffer()),
            object.hasNormals && !buffers.normal && (buffers.normal = _gl.createBuffer()), object.hasUvs && !buffers.uv && (buffers.uv = _gl.createBuffer()),
            object.hasColors && !buffers.color && (buffers.color = _gl.createBuffer());
            var programAttributes = program.getAttributes();
            if (object.hasPositions && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position),
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.position),
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, !1, 0, 0)), object.hasNormals) {
                if (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal), !material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && !0 === material.flatShading) for (var i = 0, l = 3 * object.count; i < l; i += 9) {
                    var array = object.normalArray, nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3, ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3, nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx, array[i + 1] = ny, array[i + 2] = nz, array[i + 3] = nx, array[i + 4] = ny,
                    array[i + 5] = nz, array[i + 6] = nx, array[i + 7] = ny, array[i + 8] = nz;
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.normal),
                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, !1, 0, 0);
            }
            object.hasUvs && material.map && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv),
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.uv),
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, !1, 0, 0)), object.hasColors && material.vertexColors !== NoColors && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color),
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.color),
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, !1, 0, 0)), state.disableUnusedAttributes(),
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count), object.count = 0;
        }, this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
            state.setMaterial(material);
            var program = setProgram(camera, fog, material, object), geometryProgram = geometry.id + "_" + program.id + "_" + (!0 === material.wireframe), updateBuffers = !1;
            geometryProgram !== _currentGeometryProgram && (_currentGeometryProgram = geometryProgram,
            updateBuffers = !0), object.morphTargetInfluences && (morphtargets.update(object, geometry, material, program),
            updateBuffers = !0);
            var index = geometry.index, position = geometry.attributes.position, rangeFactor = 1;
            !0 === material.wireframe && (index = geometries.getWireframeAttribute(geometry),
            rangeFactor = 2);
            var attribute, renderer = bufferRenderer;
            null !== index && (attribute = attributes.get(index), renderer = indexedBufferRenderer,
            renderer.setIndex(attribute)), updateBuffers && (setupVertexAttributes(material, program, geometry),
            null !== index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer));
            var dataCount = 0;
            null !== index ? dataCount = index.count : void 0 !== position && (dataCount = position.count);
            var rangeStart = geometry.drawRange.start * rangeFactor, rangeCount = geometry.drawRange.count * rangeFactor, groupStart = null !== group ? group.start * rangeFactor : 0, groupCount = null !== group ? group.count * rangeFactor : 1 / 0, drawStart = Math.max(rangeStart, groupStart), drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1, drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (0 !== drawCount) {
                if (object.isMesh) if (!0 === material.wireframe) state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()),
                renderer.setMode(_gl.LINES); else switch (object.drawMode) {
                  case TrianglesDrawMode:
                    renderer.setMode(_gl.TRIANGLES);
                    break;

                  case TriangleStripDrawMode:
                    renderer.setMode(_gl.TRIANGLE_STRIP);
                    break;

                  case TriangleFanDrawMode:
                    renderer.setMode(_gl.TRIANGLE_FAN);
                } else if (object.isLine) {
                    var lineWidth = material.linewidth;
                    void 0 === lineWidth && (lineWidth = 1), state.setLineWidth(lineWidth * getTargetPixelRatio()),
                    object.isLineSegments ? renderer.setMode(_gl.LINES) : object.isLineLoop ? renderer.setMode(_gl.LINE_LOOP) : renderer.setMode(_gl.LINE_STRIP);
                } else object.isPoints && renderer.setMode(_gl.POINTS);
                geometry && geometry.isInstancedBufferGeometry ? geometry.maxInstancedCount > 0 && renderer.renderInstances(geometry, drawStart, drawCount) : renderer.render(drawStart, drawCount);
            }
        }, this.compile = function(scene, camera) {
            lightsArray.length = 0, shadowsArray.length = 0, scene.traverse(function(object) {
                object.isLight && (lightsArray.push(object), object.castShadow && shadowsArray.push(object));
            }), lights.setup(lightsArray, shadowsArray, camera), scene.traverse(function(object) {
                if (object.material) if (Array.isArray(object.material)) for (var i = 0; i < object.material.length; i++) initMaterial(object.material[i], scene.fog, object); else initMaterial(object.material, scene.fog, object);
            });
        };
        var isAnimating = !1, onAnimationFrame = null;
        this.animate = function(callback) {
            onAnimationFrame = callback, start();
        }, this.render = function(scene, camera, renderTarget, forceClear) {
            if (!camera || !camera.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!_isContextLost) {
                _currentGeometryProgram = "", _currentMaterialId = -1, _currentCamera = null, !0 === scene.autoUpdate && scene.updateMatrixWorld(),
                null === camera.parent && camera.updateMatrixWorld(), vr.enabled && (camera = vr.getCamera(camera)),
                _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse),
                _frustum.setFromMatrix(_projScreenMatrix), lightsArray.length = 0, shadowsArray.length = 0,
                spritesArray.length = 0, flaresArray.length = 0, _localClippingEnabled = this.localClippingEnabled,
                _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera),
                currentRenderList = renderLists.get(scene, camera), currentRenderList.init(), projectObject(scene, camera, _this.sortObjects),
                !0 === _this.sortObjects && currentRenderList.sort(), _clippingEnabled && _clipping.beginShadows(),
                shadowMap.render(shadowsArray, scene, camera), lights.setup(lightsArray, shadowsArray, camera),
                _clippingEnabled && _clipping.endShadows(), _infoRender.frame++, _infoRender.calls = 0,
                _infoRender.vertices = 0, _infoRender.faces = 0, _infoRender.points = 0, void 0 === renderTarget && (renderTarget = null),
                this.setRenderTarget(renderTarget), background.render(currentRenderList, scene, camera, forceClear);
                var opaqueObjects = currentRenderList.opaque, transparentObjects = currentRenderList.transparent;
                if (scene.overrideMaterial) {
                    var overrideMaterial = scene.overrideMaterial;
                    opaqueObjects.length && renderObjects(opaqueObjects, scene, camera, overrideMaterial),
                    transparentObjects.length && renderObjects(transparentObjects, scene, camera, overrideMaterial);
                } else opaqueObjects.length && renderObjects(opaqueObjects, scene, camera), transparentObjects.length && renderObjects(transparentObjects, scene, camera);
                spriteRenderer.render(spritesArray, scene, camera), flareRenderer.render(flaresArray, scene, camera, _currentViewport),
                renderTarget && textures.updateRenderTargetMipmap(renderTarget), state.buffers.depth.setTest(!0),
                state.buffers.depth.setMask(!0), state.buffers.color.setMask(!0), state.setPolygonOffset(!1),
                vr.enabled && vr.submitFrame();
            }
        }, this.setFaceCulling = function(cullFace, frontFaceDirection) {
            state.setCullFace(cullFace), state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        }, this.allocTextureUnit = allocTextureUnit, this.setTexture2D = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTarget && (warned || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                warned = !0), texture = texture.texture), textures.setTexture2D(texture, slot);
            };
        }(), this.setTexture = function() {
            var warned = !1;
            return function(texture, slot) {
                warned || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                warned = !0), textures.setTexture2D(texture, slot);
            };
        }(), this.setTextureCube = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTargetCube && (warned || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                warned = !0), texture = texture.texture), texture && texture.isCubeTexture || Array.isArray(texture.image) && 6 === texture.image.length ? textures.setTextureCube(texture, slot) : textures.setTextureCubeDynamic(texture, slot);
            };
        }(), this.getRenderTarget = function() {
            return _currentRenderTarget;
        }, this.setRenderTarget = function(renderTarget) {
            _currentRenderTarget = renderTarget, renderTarget && void 0 === properties.get(renderTarget).__webglFramebuffer && textures.setupRenderTarget(renderTarget);
            var framebuffer = null, isCube = !1;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                renderTarget.isWebGLRenderTargetCube ? (framebuffer = __webglFramebuffer[renderTarget.activeCubeFace],
                isCube = !0) : framebuffer = __webglFramebuffer, _currentViewport.copy(renderTarget.viewport),
                _currentScissor.copy(renderTarget.scissor), _currentScissorTest = renderTarget.scissorTest;
            } else _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio), _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio),
            _currentScissorTest = _scissorTest;
            if (_currentFramebuffer !== framebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
            _currentFramebuffer = framebuffer), state.viewport(_currentViewport), state.scissor(_currentScissor),
            state.setScissorTest(_currentScissorTest), isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        }, this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
            if (!renderTarget || !renderTarget.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = !1;
                framebuffer !== _currentFramebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
                restore = !0);
                try {
                    var texture = renderTarget.texture, textureFormat = texture.format, textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(textureType === UnsignedByteType || utils.convert(textureType) === _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) || textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float")) || textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    _gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE ? x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                } finally {
                    restore && _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                }
            }
        };
    }
    function FogExp2(color, density) {
        this.name = "", this.color = new Color(color), this.density = void 0 !== density ? density : 25e-5;
    }
    function Fog(color, near, far) {
        this.name = "", this.color = new Color(color), this.near = void 0 !== near ? near : 1,
        this.far = void 0 !== far ? far : 1e3;
    }
    function Scene() {
        Object3D.call(this), this.type = "Scene", this.background = null, this.fog = null,
        this.overrideMaterial = null, this.autoUpdate = !0;
    }
    function LensFlare(texture, size, distance, blending, color) {
        Object3D.call(this), this.lensFlares = [], this.positionScreen = new Vector3(),
        this.customUpdateCallback = void 0, void 0 !== texture && this.add(texture, size, distance, blending, color);
    }
    function SpriteMaterial(parameters) {
        Material.call(this), this.type = "SpriteMaterial", this.color = new Color(16777215),
        this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(parameters);
    }
    function Sprite(material) {
        Object3D.call(this), this.type = "Sprite", this.material = void 0 !== material ? material : new SpriteMaterial();
    }
    function LOD() {
        Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        });
    }
    function Skeleton(bones, boneInverses) {
        if (bones = bones || [], this.bones = bones.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === boneInverses) this.calculateInverses(); else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0); else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) this.boneInverses.push(new Matrix4());
        }
    }
    function Bone() {
        Object3D.call(this), this.type = "Bone";
    }
    function SkinnedMesh(geometry, material) {
        Mesh.call(this, geometry, material), this.type = "SkinnedMesh", this.bindMode = "attached",
        this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
        var bones = this.initBones(), skeleton = new Skeleton(bones);
        this.bind(skeleton, this.matrixWorld), this.normalizeSkinWeights();
    }
    function LineBasicMaterial(parameters) {
        Material.call(this), this.type = "LineBasicMaterial", this.color = new Color(16777215),
        this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1,
        this.setValues(parameters);
    }
    function Line(geometry, material, mode) {
        if (1 === mode) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
        new LineSegments(geometry, material);
        Object3D.call(this), this.type = "Line", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(),
        this.material = void 0 !== material ? material : new LineBasicMaterial({
            color: 16777215 * Math.random()
        });
    }
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material), this.type = "LineSegments";
    }
    function LineLoop(geometry, material) {
        Line.call(this, geometry, material), this.type = "LineLoop";
    }
    function PointsMaterial(parameters) {
        Material.call(this), this.type = "PointsMaterial", this.color = new Color(16777215),
        this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(parameters);
    }
    function Points(geometry, material) {
        Object3D.call(this), this.type = "Points", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(),
        this.material = void 0 !== material ? material : new PointsMaterial({
            color: 16777215 * Math.random()
        });
    }
    function Group() {
        Object3D.call(this), this.type = "Group";
    }
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        function update() {
            var video = scope.image;
            video.readyState >= video.HAVE_CURRENT_DATA && (scope.needsUpdate = !0), requestAnimationFrame(update);
        }
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy),
        this.generateMipmaps = !1;
        var scope = this;
        requestAnimationFrame(update);
    }
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
        this.image = {
            width: width,
            height: height
        }, this.mipmaps = mipmaps, this.flipY = !1, this.generateMipmaps = !1;
    }
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        if ((format = void 0 !== format ? format : DepthFormat) !== DepthFormat && format !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === type && format === DepthFormat && (type = UnsignedShortType), void 0 === type && format === DepthStencilFormat && (type = UnsignedInt248Type),
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy),
        this.image = {
            width: width,
            height: height
        }, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter,
        this.flipY = !1, this.generateMipmaps = !1;
    }
    function WireframeGeometry(geometry) {
        BufferGeometry.call(this), this.type = "WireframeGeometry";
        var i, j, l, o, ol, e, edge1, edge2, key, vertex, vertices = [], edge = [ 0, 0 ], edges = {}, keys = [ "a", "b", "c" ];
        if (geometry && geometry.isGeometry) {
            var faces = geometry.faces;
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) edge1 = face[keys[j]], edge2 = face[keys[(j + 1) % 3]],
                edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2), key = edge[0] + "," + edge[1],
                void 0 === edges[key] && (edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                });
            }
            for (key in edges) e = edges[key], vertex = geometry.vertices[e.index1], vertices.push(vertex.x, vertex.y, vertex.z),
            vertex = geometry.vertices[e.index2], vertices.push(vertex.x, vertex.y, vertex.z);
        } else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups, group, start, count, index1, index2;
            if (vertex = new Vector3(), null !== geometry.index) {
                for (position = geometry.attributes.position, indices = geometry.index, groups = geometry.groups,
                0 === groups.length && (groups = [ {
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                } ]), o = 0, ol = groups.length; o < ol; ++o) for (group = groups[o], start = group.start,
                count = group.count, i = start, l = start + count; i < l; i += 3) for (j = 0; j < 3; j++) edge1 = indices.getX(i + j),
                edge2 = indices.getX(i + (j + 1) % 3), edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2),
                key = edge[0] + "," + edge[1], void 0 === edges[key] && (edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                });
                for (key in edges) e = edges[key], vertex.fromBufferAttribute(position, e.index1),
                vertices.push(vertex.x, vertex.y, vertex.z), vertex.fromBufferAttribute(position, e.index2),
                vertices.push(vertex.x, vertex.y, vertex.z);
            } else for (position = geometry.attributes.position, i = 0, l = position.count / 3; i < l; i++) for (j = 0; j < 3; j++) index1 = 3 * i + j,
            vertex.fromBufferAttribute(position, index1), vertices.push(vertex.x, vertex.y, vertex.z),
            index2 = 3 * i + (j + 1) % 3, vertex.fromBufferAttribute(position, index2), vertices.push(vertex.x, vertex.y, vertex.z);
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        }, this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks)),
        this.mergeVertices();
    }
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var i, j, indices = [], vertices = [], normals = [], uvs = [], normal = new Vector3(), p0 = new Vector3(), p1 = new Vector3(), pu = new Vector3(), pv = new Vector3(), sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                p0 = func(u, v, p0), vertices.push(p0.x, p0.y, p0.z), u - 1e-5 >= 0 ? (p1 = func(u - 1e-5, v, p1),
                pu.subVectors(p0, p1)) : (p1 = func(u + 1e-5, v, p1), pu.subVectors(p1, p0)), v - 1e-5 >= 0 ? (p1 = func(u, v - 1e-5, p1),
                pv.subVectors(p0, p1)) : (p1 = func(u, v + 1e-5, p1), pv.subVectors(p1, p0)), normal.crossVectors(pu, pv).normalize(),
                normals.push(normal.x, normal.y, normal.z), uvs.push(u, v);
            }
        }
        for (i = 0; i < stacks; i++) for (j = 0; j < slices; j++) {
            var a = i * sliceCount + j, b = i * sliceCount + j + 1, c = (i + 1) * sliceCount + j + 1, d = (i + 1) * sliceCount + j;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail)),
        this.mergeVertices();
    }
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        function subdivideFace(a, b, c, detail) {
            var i, j, cols = Math.pow(2, detail), v = [];
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols), bj = b.clone().lerp(c, i / cols), rows = cols - i;
                for (j = 0; j <= rows; j++) v[i][j] = 0 === j && i === cols ? aj : aj.clone().lerp(bj, j / rows);
            }
            for (i = 0; i < cols; i++) for (j = 0; j < 2 * (cols - i) - 1; j++) {
                var k = Math.floor(j / 2);
                j % 2 == 0 ? (pushVertex(v[i][k + 1]), pushVertex(v[i + 1][k]), pushVertex(v[i][k])) : (pushVertex(v[i][k + 1]),
                pushVertex(v[i + 1][k + 1]), pushVertex(v[i + 1][k]));
            }
        }
        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0], x1 = uvBuffer[i + 2], x2 = uvBuffer[i + 4], max = Math.max(x0, x1, x2), min = Math.min(x0, x1, x2);
                max > .9 && min < .1 && (x0 < .2 && (uvBuffer[i + 0] += 1), x1 < .2 && (uvBuffer[i + 2] += 1),
                x2 < .2 && (uvBuffer[i + 4] += 1));
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = 3 * index;
            vertex.x = vertices[stride + 0], vertex.y = vertices[stride + 1], vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), centroid = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), i = 0, j = 0; i < vertexBuffer.length; i += 9,
            j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]), b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]),
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]), uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]),
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]), uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]),
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi), correctUV(uvB, j + 2, b, azi), correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            azimuth < 0 && 1 === uv.x && (uvBuffer[stride] = uv.x - 1), 0 === vector.x && 0 === vector.z && (uvBuffer[stride] = azimuth / 2 / Math.PI + .5);
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
        BufferGeometry.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, radius = radius || 1, detail = detail || 0;
        var vertexBuffer = [], uvBuffer = [];
        !function(detail) {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), i = 0; i < indices.length; i += 3) getVertexByIndex(indices[i + 0], a),
            getVertexByIndex(indices[i + 1], b), getVertexByIndex(indices[i + 2], c), subdivideFace(a, b, c, detail);
        }(detail), function(radius) {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) vertex.x = vertexBuffer[i + 0],
            vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2], vertex.normalize().multiplyScalar(radius),
            vertexBuffer[i + 0] = vertex.x, vertexBuffer[i + 1] = vertex.y, vertexBuffer[i + 2] = vertex.z;
        }(radius), function() {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0], vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + .5, v = inclination(vertex) / Math.PI + .5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs(), correctSeam();
        }(), this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3)),
        this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2)), 0 === detail ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], indices = [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1 ], indices = [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, r = 1 / t, vertices = [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r ], indices = [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, void 0 !== taper && console.warn("THREE.TubeGeometry: taper has been removed.");
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents, this.normals = bufferGeometry.normals,
        this.binormals = bufferGeometry.binormals, this.fromBufferGeometry(bufferGeometry),
        this.mergeVertices();
    }
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        function generateSegment(i) {
            P = path.getPointAt(i / tubularSegments, P);
            var N = frames.normals[i], B = frames.binormals[i];
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2, sin = Math.sin(v), cos = -Math.cos(v);
                normal.x = cos * N.x + sin * B.x, normal.y = cos * N.y + sin * B.y, normal.z = cos * N.z + sin * B.z,
                normal.normalize(), normals.push(normal.x, normal.y, normal.z), vertex.x = P.x + radius * normal.x,
                vertex.y = P.y + radius * normal.y, vertex.z = P.z + radius * normal.z, vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d), indices.push(b, c, d);
            }
        }
        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) for (j = 0; j <= radialSegments; j++) uv.x = i / tubularSegments,
            uv.y = j / radialSegments, uvs.push(uv.x, uv.y);
        }
        BufferGeometry.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, tubularSegments = tubularSegments || 64, radius = radius || 1, radialSegments = radialSegments || 8,
        closed = closed || !1;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents, this.normals = frames.normals, this.binormals = frames.binormals;
        var i, j, vertex = new Vector3(), normal = new Vector3(), uv = new Vector2(), P = new Vector3(), vertices = [], normals = [], uvs = [], indices = [];
        !function() {
            for (i = 0; i < tubularSegments; i++) generateSegment(i);
            generateSegment(!1 === closed ? tubularSegments : 0), generateUVs(), generateIndices();
        }(), this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, void 0 !== heightScale && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q)),
        this.mergeVertices();
    }
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u), su = Math.sin(u), quOverP = q / p * u, cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * .5 * cu, position.y = radius * (2 + cs) * su * .5,
            position.z = radius * Math.sin(quOverP) * .5;
        }
        BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, radius = radius || 1, tube = tube || .4, tubularSegments = Math.floor(tubularSegments) || 64,
        radialSegments = Math.floor(radialSegments) || 8, p = p || 2, q = q || 3;
        var i, j, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3(), normal = new Vector3(), P1 = new Vector3(), P2 = new Vector3(), B = new Vector3(), T = new Vector3(), N = new Vector3();
        for (i = 0; i <= tubularSegments; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            for (calculatePositionOnCurve(u, p, q, radius, P1), calculatePositionOnCurve(u + .01, p, q, radius, P2),
            T.subVectors(P2, P1), N.addVectors(P2, P1), B.crossVectors(T, N), N.crossVectors(B, T),
            B.normalize(), N.normalize(), j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2, cx = -tube * Math.cos(v), cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x), vertex.y = P1.y + (cx * N.y + cy * B.y),
                vertex.z = P1.z + (cx * N.z + cy * B.z), vertices.push(vertex.x, vertex.y, vertex.z),
                normal.subVectors(vertex, P1).normalize(), normals.push(normal.x, normal.y, normal.z),
                uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= tubularSegments; j++) for (i = 1; i <= radialSegments; i++) {
            var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc)),
        this.mergeVertices();
    }
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, radius = radius || 1, tube = tube || .4, radialSegments = Math.floor(radialSegments) || 8,
        tubularSegments = Math.floor(tubularSegments) || 6, arc = arc || 2 * Math.PI;
        var j, i, indices = [], vertices = [], normals = [], uvs = [], center = new Vector3(), vertex = new Vector3(), normal = new Vector3();
        for (j = 0; j <= radialSegments; j++) for (i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc, v = j / radialSegments * Math.PI * 2;
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u), vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u),
            vertex.z = tube * Math.sin(v), vertices.push(vertex.x, vertex.y, vertex.z), center.x = radius * Math.cos(u),
            center.y = radius * Math.sin(u), normal.subVectors(vertex, center).normalize(),
            normals.push(normal.x, normal.y, normal.z), uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
        }
        for (j = 1; j <= radialSegments; j++) for (i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1, b = (tubularSegments + 1) * (j - 1) + i - 1, c = (tubularSegments + 1) * (j - 1) + i, d = (tubularSegments + 1) * j + i;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ExtrudeGeometry(shapes, options) {
        Geometry.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: shapes,
            options: options
        }, this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options)), this.mergeVertices();
    }
    function ExtrudeBufferGeometry(shapes, options) {
        void 0 !== shapes && (BufferGeometry.call(this), this.type = "ExtrudeBufferGeometry",
        shapes = Array.isArray(shapes) ? shapes : [ shapes ], this.addShapeList(shapes, options),
        this.computeVertexNormals());
    }
    function TextGeometry(text, parameters) {
        Geometry.call(this), this.type = "TextGeometry", this.parameters = {
            text: text,
            parameters: parameters
        }, this.fromBufferGeometry(new TextBufferGeometry(text, parameters)), this.mergeVertices();
    }
    function TextBufferGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if (!font || !font.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
        new Geometry();
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.amount = void 0 !== parameters.height ? parameters.height : 50, void 0 === parameters.bevelThickness && (parameters.bevelThickness = 10),
        void 0 === parameters.bevelSize && (parameters.bevelSize = 8), void 0 === parameters.bevelEnabled && (parameters.bevelEnabled = !1),
        ExtrudeBufferGeometry.call(this, shapes, parameters), this.type = "TextBufferGeometry";
    }
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)),
        this.mergeVertices();
    }
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 1, widthSegments = Math.max(3, Math.floor(widthSegments) || 8),
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6), phiStart = void 0 !== phiStart ? phiStart : 0,
        phiLength = void 0 !== phiLength ? phiLength : 2 * Math.PI, thetaStart = void 0 !== thetaStart ? thetaStart : 0,
        thetaLength = void 0 !== thetaLength ? thetaLength : Math.PI;
        var ix, iy, thetaEnd = thetaStart + thetaLength, index = 0, grid = [], vertex = new Vector3(), normal = new Vector3(), indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [], v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength),
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength), vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength),
                vertices.push(vertex.x, vertex.y, vertex.z), normal.set(vertex.x, vertex.y, vertex.z).normalize(),
                normals.push(normal.x, normal.y, normal.z), uvs.push(u, 1 - v), verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        for (iy = 0; iy < heightSegments; iy++) for (ix = 0; ix < widthSegments; ix++) {
            var a = grid[iy][ix + 1], b = grid[iy][ix], c = grid[iy + 1][ix], d = grid[iy + 1][ix + 1];
            (0 !== iy || thetaStart > 0) && indices.push(a, b, d), (iy !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength)),
        this.mergeVertices();
    }
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, innerRadius = innerRadius || .5, outerRadius = outerRadius || 1, thetaStart = void 0 !== thetaStart ? thetaStart : 0,
        thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI, thetaSegments = void 0 !== thetaSegments ? Math.max(3, thetaSegments) : 8,
        phiSegments = void 0 !== phiSegments ? Math.max(1, phiSegments) : 1;
        var segment, j, i, indices = [], vertices = [], normals = [], uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex = new Vector3(), uv = new Vector2();
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) segment = thetaStart + i / thetaSegments * thetaLength,
            vertex.x = radius * Math.cos(segment), vertex.y = radius * Math.sin(segment), vertices.push(vertex.x, vertex.y, vertex.z),
            normals.push(0, 0, 1), uv.x = (vertex.x / outerRadius + 1) / 2, uv.y = (vertex.y / outerRadius + 1) / 2,
            uvs.push(uv.x, uv.y);
            radius += radiusStep;
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment, b = segment + thetaSegments + 1, c = segment + thetaSegments + 2, d = segment + 1;
                indices.push(a, b, d), indices.push(b, c, d);
            }
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength)),
        this.mergeVertices();
    }
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, segments = Math.floor(segments) || 12, phiStart = phiStart || 0, phiLength = phiLength || 2 * Math.PI,
        phiLength = _Math.clamp(phiLength, 0, 2 * Math.PI);
        var base, i, j, indices = [], vertices = [], uvs = [], inverseSegments = 1 / segments, vertex = new Vector3(), uv = new Vector2();
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength, sin = Math.sin(phi), cos = Math.cos(phi);
            for (j = 0; j <= points.length - 1; j++) vertex.x = points[j].x * sin, vertex.y = points[j].y,
            vertex.z = points[j].x * cos, vertices.push(vertex.x, vertex.y, vertex.z), uv.x = i / segments,
            uv.y = j / (points.length - 1), uvs.push(uv.x, uv.y);
        }
        for (i = 0; i < segments; i++) for (j = 0; j < points.length - 1; j++) {
            base = j + i * points.length;
            var a = base, b = base + points.length, c = base + points.length + 1, d = base + 1;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        if (this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2)), this.computeVertexNormals(),
        phiLength === 2 * Math.PI) {
            var normals = this.attributes.normal.array, n1 = new Vector3(), n2 = new Vector3(), n = new Vector3();
            for (base = segments * points.length * 3, i = 0, j = 0; i < points.length; i++,
            j += 3) n1.x = normals[j + 0], n1.y = normals[j + 1], n1.z = normals[j + 2], n2.x = normals[base + j + 0],
            n2.y = normals[base + j + 1], n2.z = normals[base + j + 2], n.addVectors(n1, n2).normalize(),
            normals[j + 0] = normals[base + j + 0] = n.x, normals[j + 1] = normals[base + j + 1] = n.y,
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this), this.type = "ShapeGeometry", "object" == typeof curveSegments && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        curveSegments = curveSegments.curveSegments), this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        }, this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments)), this.mergeVertices();
    }
    function ShapeBufferGeometry(shapes, curveSegments) {
        function addShape(shape) {
            var i, l, shapeHole, indexOffset = vertices.length / 3, points = shape.extractPoints(curveSegments), shapeVertices = points.shape, shapeHoles = points.holes;
            if (!1 === ShapeUtils.isClockWise(shapeVertices)) for (shapeVertices = shapeVertices.reverse(),
            i = 0, l = shapeHoles.length; i < l; i++) shapeHole = shapeHoles[i], !0 === ShapeUtils.isClockWise(shapeHole) && (shapeHoles[i] = shapeHole.reverse());
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (i = 0, l = shapeHoles.length; i < l; i++) shapeHole = shapeHoles[i], shapeVertices = shapeVertices.concat(shapeHole);
            for (i = 0, l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0), normals.push(0, 0, 1), uvs.push(vertex.x, vertex.y);
            }
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i], a = face[0] + indexOffset, b = face[1] + indexOffset, c = face[2] + indexOffset;
                indices.push(a, b, c), groupCount += 3;
            }
        }
        BufferGeometry.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        }, curveSegments = curveSegments || 12;
        var indices = [], vertices = [], normals = [], uvs = [], groupStart = 0, groupCount = 0;
        if (!1 === Array.isArray(shapes)) addShape(shapes); else for (var i = 0; i < shapes.length; i++) addShape(shapes[i]),
        this.addGroup(groupStart, groupCount, i), groupStart += groupCount, groupCount = 0;
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: thresholdAngle
        }, thresholdAngle = void 0 !== thresholdAngle ? thresholdAngle : 1;
        var edge1, edge2, key, geometry2, vertices = [], thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle), edge = [ 0, 0 ], edges = {}, keys = [ "a", "b", "c" ];
        geometry.isBufferGeometry ? (geometry2 = new Geometry(), geometry2.fromBufferGeometry(geometry)) : geometry2 = geometry.clone(),
        geometry2.mergeVertices(), geometry2.computeFaceNormals();
        for (var sourceVertices = geometry2.vertices, faces = geometry2.faces, i = 0, l = faces.length; i < l; i++) for (var face = faces[i], j = 0; j < 3; j++) edge1 = face[keys[j]],
        edge2 = face[keys[(j + 1) % 3]], edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2),
        key = edge[0] + "," + edge[1], void 0 === edges[key] ? edges[key] = {
            index1: edge[0],
            index2: edge[1],
            face1: i,
            face2: void 0
        } : edges[key].face2 = i;
        for (key in edges) {
            var e = edges[key];
            if (void 0 === e.face2 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z), vertex = sourceVertices[e.index2],
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)),
        this.mergeVertices();
    }
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd, uv = new Vector2(), vertex = new Vector3(), groupCount = 0, radius = !0 === top ? radiusTop : radiusBottom, sign = !0 === top ? 1 : -1;
            for (centerIndexStart = index, x = 1; x <= radialSegments; x++) vertices.push(0, halfHeight * sign, 0),
            normals.push(0, sign, 0), uvs.push(.5, .5), index++;
            for (centerIndexEnd = index, x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments, theta = u * thetaLength + thetaStart, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta, vertex.y = halfHeight * sign, vertex.z = radius * cosTheta,
                vertices.push(vertex.x, vertex.y, vertex.z), normals.push(0, sign, 0), uv.x = .5 * cosTheta + .5,
                uv.y = .5 * sinTheta * sign + .5, uvs.push(uv.x, uv.y), index++;
            }
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x, i = centerIndexEnd + x;
                !0 === top ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c), groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, !0 === top ? 1 : 2), groupStart += groupCount;
        }
        BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = void 0 !== radiusTop ? radiusTop : 1, radiusBottom = void 0 !== radiusBottom ? radiusBottom : 1,
        height = height || 1, radialSegments = Math.floor(radialSegments) || 8, heightSegments = Math.floor(heightSegments) || 1,
        openEnded = void 0 !== openEnded && openEnded, thetaStart = void 0 !== thetaStart ? thetaStart : 0,
        thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var indices = [], vertices = [], normals = [], uvs = [], index = 0, indexArray = [], halfHeight = height / 2, groupStart = 0;
        !function() {
            var x, y, normal = new Vector3(), vertex = new Vector3(), groupCount = 0, slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [], v = y / heightSegments, radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments, theta = u * thetaLength + thetaStart, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta, vertex.y = -v * height + halfHeight, vertex.z = radius * cosTheta,
                    vertices.push(vertex.x, vertex.y, vertex.z), normal.set(sinTheta, slope, cosTheta).normalize(),
                    normals.push(normal.x, normal.y, normal.z), uvs.push(u, 1 - v), indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for (x = 0; x < radialSegments; x++) for (y = 0; y < heightSegments; y++) {
                var a = indexArray[y][x], b = indexArray[y + 1][x], c = indexArray[y + 1][x + 1], d = indexArray[y][x + 1];
                indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, 0), groupStart += groupCount;
        }(), !1 === openEnded && (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)),
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength),
        this.type = "ConeGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength),
        this.type = "ConeBufferGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength)),
        this.mergeVertices();
    }
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 1, segments = void 0 !== segments ? Math.max(3, segments) : 8,
        thetaStart = void 0 !== thetaStart ? thetaStart : 0, thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var i, s, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3(), uv = new Vector2();
        for (vertices.push(0, 0, 0), normals.push(0, 0, 1), uvs.push(.5, .5), s = 0, i = 3; s <= segments; s++,
        i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment), vertex.y = radius * Math.sin(segment), vertices.push(vertex.x, vertex.y, vertex.z),
            normals.push(0, 0, 1), uv.x = (vertices[i] / radius + 1) / 2, uv.y = (vertices[i + 1] / radius + 1) / 2,
            uvs.push(uv.x, uv.y);
        }
        for (i = 1; i <= segments; i++) indices.push(i, i + 1, 0);
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ShadowMaterial(parameters) {
        Material.call(this), this.type = "ShadowMaterial", this.color = new Color(0), this.opacity = 1,
        this.lights = !0, this.transparent = !0, this.setValues(parameters);
    }
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters), this.type = "RawShaderMaterial";
    }
    function MeshStandardMaterial(parameters) {
        Material.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = .5,
        this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1,
        this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1,
        this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null,
        this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1,
        this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null,
        this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1,
        this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round",
        this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(parameters);
    }
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0,
        this.clearCoatRoughness = 0, this.setValues(parameters);
    }
    function MeshPhongMaterial(parameters) {
        Material.call(this), this.type = "MeshPhongMaterial", this.color = new Color(16777215),
        this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null,
        this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0),
        this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1,
        this.normalMap = null, this.normalScale = new Vector2(1, 1), this.displacementMap = null,
        this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null,
        this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1,
        this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1,
        this.setValues(parameters);
    }
    function MeshToonMaterial(parameters) {
        MeshPhongMaterial.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(parameters);
    }
    function MeshNormalMaterial(parameters) {
        Material.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1,
        this.normalMap = null, this.normalScale = new Vector2(1, 1), this.displacementMap = null,
        this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1,
        this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1,
        this.setValues(parameters);
    }
    function MeshLambertMaterial(parameters) {
        Material.call(this), this.type = "MeshLambertMaterial", this.color = new Color(16777215),
        this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null,
        this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1,
        this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null,
        this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98,
        this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1,
        this.setValues(parameters);
    }
    function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this), this.type = "LineDashedMaterial", this.scale = 1,
        this.dashSize = 3, this.gapSize = 1, this.setValues(parameters);
    }
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this, isLoading = !1, itemsLoaded = 0, itemsTotal = 0, urlModifier = void 0;
        this.onStart = void 0, this.onLoad = onLoad, this.onProgress = onProgress, this.onError = onError,
        this.itemStart = function(url) {
            itemsTotal++, !1 === isLoading && void 0 !== scope.onStart && scope.onStart(url, itemsLoaded, itemsTotal),
            isLoading = !0;
        }, this.itemEnd = function(url) {
            itemsLoaded++, void 0 !== scope.onProgress && scope.onProgress(url, itemsLoaded, itemsTotal),
            itemsLoaded === itemsTotal && (isLoading = !1, void 0 !== scope.onLoad && scope.onLoad());
        }, this.itemError = function(url) {
            void 0 !== scope.onError && scope.onError(url);
        }, this.resolveURL = function(url) {
            return urlModifier ? urlModifier(url) : url;
        }, this.setURLModifier = function(transform) {
            urlModifier = transform;
        };
    }
    function FileLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CompressedTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function DataTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function ImageLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CubeTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function TextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Light(color, intensity) {
        Object3D.call(this), this.type = "Light", this.color = new Color(color), this.intensity = void 0 !== intensity ? intensity : 1,
        this.receiveShadow = void 0;
    }
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity), this.type = "HemisphereLight", this.castShadow = void 0,
        this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(groundColor);
    }
    function LightShadow(camera) {
        this.camera = camera, this.bias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512),
        this.map = null, this.matrix = new Matrix4();
    }
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500));
    }
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp),
        this.updateMatrix(), this.target = new Object3D(), Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / Math.PI;
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.angle = void 0 !== angle ? angle : Math.PI / 3,
        this.penumbra = void 0 !== penumbra ? penumbra : 0, this.decay = void 0 !== decay ? decay : 1,
        this.shadow = new SpotLightShadow();
    }
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / (4 * Math.PI);
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.decay = void 0 !== decay ? decay : 1,
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, .5, 500));
    }
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500));
    }
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp),
        this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
    }
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "AmbientLight", this.castShadow = void 0;
    }
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity), this.type = "RectAreaLight", this.position.set(0, 1, 0),
        this.updateMatrix(), this.width = void 0 !== width ? width : 10, this.height = void 0 !== height ? height : 10;
    }
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions, this._cachedIndex = 0, this.resultBuffer = void 0 !== resultBuffer ? resultBuffer : new sampleValues.constructor(sampleSize),
        this.sampleValues = sampleValues, this.valueSize = sampleSize;
    }
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer),
        this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
    }
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function KeyframeTrackConstructor(name, times, values, interpolation) {
        if (void 0 === name) throw new Error("track name is undefined");
        if (void 0 === times || 0 === times.length) throw new Error("no keyframes in track named " + name);
        this.name = name, this.times = AnimationUtils.convertArray(times, this.TimeBufferType),
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType), this.setInterpolation(interpolation || this.DefaultInterpolation),
        this.validate(), this.optimize();
    }
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrackConstructor.call(this, name, times, values);
    }
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function KeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.apply(this, name, times, values, interpolation);
    }
    function AnimationClip(name, duration, tracks) {
        this.name = name, this.tracks = tracks, this.duration = void 0 !== duration ? duration : -1,
        this.uuid = _Math.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize();
    }
    function MaterialLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.textures = {};
    }
    function BufferGeometryLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Loader() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {};
    }
    function JSONLoader(manager) {
        "boolean" == typeof manager && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
        manager = void 0), this.manager = void 0 !== manager ? manager : DefaultLoadingManager,
        this.withCredentials = !1;
    }
    function ObjectLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.texturePath = "";
    }
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t;
        return (2 * p1 - 2 * p2 + v0 + v1) * (t * t2) + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function Curve() {
        this.type = "Curve", this.arcLengthDivisions = 200;
    }
    function LineCurve(v1, v2) {
        Curve.call(this), this.type = "LineCurve", this.v1 = v1 || new Vector2(), this.v2 = v2 || new Vector2();
    }
    function CurvePath() {
        Curve.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
    }
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this), this.type = "EllipseCurve", this.aX = aX || 0, this.aY = aY || 0,
        this.xRadius = xRadius || 1, this.yRadius = yRadius || 1, this.aStartAngle = aStartAngle || 0,
        this.aEndAngle = aEndAngle || 2 * Math.PI, this.aClockwise = aClockwise || !1, this.aRotation = aRotation || 0;
    }
    function SplineCurve(points) {
        Curve.call(this), this.type = "SplineCurve", this.points = points || [];
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        Curve.call(this), this.type = "CubicBezierCurve", this.v0 = v0 || new Vector2(),
        this.v1 = v1 || new Vector2(), this.v2 = v2 || new Vector2(), this.v3 = v3 || new Vector2();
    }
    function QuadraticBezierCurve(v0, v1, v2) {
        Curve.call(this), this.type = "QuadraticBezierCurve", this.v0 = v0 || new Vector2(),
        this.v1 = v1 || new Vector2(), this.v2 = v2 || new Vector2();
    }
    function Path(points) {
        CurvePath.call(this), this.type = "Path", this.currentPoint = new Vector2(), points && this.setFromPoints(points);
    }
    function Shape(points) {
        Path.call(this, points), this.type = "Shape", this.holes = [];
    }
    function ShapePath() {
        this.type = "ShapePath", this.subPaths = [], this.currentPath = null;
    }
    function Font(data) {
        this.type = "Font", this.data = data;
    }
    function FontLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function AudioLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function StereoCamera() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera(),
        this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(),
        this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
    }
    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this), this.type = "CubeCamera";
        var cameraPX = new PerspectiveCamera(90, 1, near, far);
        cameraPX.up.set(0, -1, 0), cameraPX.lookAt(new Vector3(1, 0, 0)), this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(90, 1, near, far);
        cameraNX.up.set(0, -1, 0), cameraNX.lookAt(new Vector3(-1, 0, 0)), this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(90, 1, near, far);
        cameraPY.up.set(0, 0, 1), cameraPY.lookAt(new Vector3(0, 1, 0)), this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(90, 1, near, far);
        cameraNY.up.set(0, 0, -1), cameraNY.lookAt(new Vector3(0, -1, 0)), this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(90, 1, near, far);
        cameraPZ.up.set(0, -1, 0), cameraPZ.lookAt(new Vector3(0, 0, 1)), this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(90, 1, near, far);
        cameraNZ.up.set(0, -1, 0), cameraNZ.lookAt(new Vector3(0, 0, -1)), this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options),
        this.renderTarget.texture.name = "CubeCamera", this.update = function(renderer, scene) {
            null === this.parent && this.updateMatrixWorld();
            var renderTarget = this.renderTarget, generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = !1, renderTarget.activeCubeFace = 0, renderer.render(scene, cameraPX, renderTarget),
            renderTarget.activeCubeFace = 1, renderer.render(scene, cameraNX, renderTarget),
            renderTarget.activeCubeFace = 2, renderer.render(scene, cameraPY, renderTarget),
            renderTarget.activeCubeFace = 3, renderer.render(scene, cameraNY, renderTarget),
            renderTarget.activeCubeFace = 4, renderer.render(scene, cameraPZ, renderTarget),
            renderTarget.texture.generateMipmaps = generateMipmaps, renderTarget.activeCubeFace = 5,
            renderer.render(scene, cameraNZ, renderTarget), renderer.setRenderTarget(null);
        }, this.clear = function(renderer, color, depth, stencil) {
            for (var renderTarget = this.renderTarget, i = 0; i < 6; i++) renderTarget.activeCubeFace = i,
            renderer.setRenderTarget(renderTarget), renderer.clear(color, depth, stencil);
            renderer.setRenderTarget(null);
        };
    }
    function AudioListener() {
        Object3D.call(this), this.type = "AudioListener", this.context = AudioContext.getContext(),
        this.gain = this.context.createGain(), this.gain.connect(this.context.destination),
        this.filter = null;
    }
    function Audio(listener) {
        Object3D.call(this), this.type = "Audio", this.context = listener.context, this.gain = this.context.createGain(),
        this.gain.connect(listener.getInput()), this.autoplay = !1, this.buffer = null,
        this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1,
        this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
    }
    function PositionalAudio(listener) {
        Audio.call(this, listener), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
    }
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser(), this.analyser.fftSize = void 0 !== fftSize ? fftSize : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount), audio.getOutput().connect(this.analyser);
    }
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding, this.valueSize = valueSize;
        var mixFunction, bufferType = Float64Array;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            break;

          case "string":
          case "bool":
            bufferType = Array, mixFunction = this._select;
            break;

          default:
            mixFunction = this._lerp;
        }
        this.buffer = new bufferType(4 * valueSize), this._mixBufferRegion = mixFunction,
        this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
    }
    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup, this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path, this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path),
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode,
        this.rootNode = rootNode;
    }
    function AnimationObjectGroup() {
        this.uuid = _Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) indices[arguments[i].uuid] = i;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer, this._clip = clip, this._localRoot = localRoot || null;
        for (var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks), interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }, i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant, interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings, this._interpolants = interpolants,
        this._propertyBindings = new Array(nTracks), this._cacheIndex = null, this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat,
        this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1,
        this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0,
        this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0;
    }
    function AnimationMixer(root) {
        this._root = root, this._initMemoryManager(), this._accuIndex = 0, this.time = 0,
        this.timeScale = 1;
    }
    function Uniform(value) {
        "string" == typeof value && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        value = arguments[1]), this.value = value;
    }
    function InstancedBufferGeometry() {
        BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
    }
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID(), this.data = interleavedBuffer, this.itemSize = itemSize,
        this.offset = offset, this.normalized = !0 === normalized;
    }
    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID(), this.array = array, this.stride = stride, this.count = void 0 !== array ? array.length / stride : 0,
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0;
    }
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction), this.near = near || 0, this.far = far || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (!1 !== object.visible && (object.raycast(raycaster, intersects), !0 === recursive)) for (var children = object.children, i = 0, l = children.length; i < l; i++) intersectObject(children[i], raycaster, intersects, !0);
    }
    function Clock(autoStart) {
        this.autoStart = void 0 === autoStart || autoStart, this.startTime = 0, this.oldTime = 0,
        this.elapsedTime = 0, this.running = !1;
    }
    function Spherical(radius, phi, theta) {
        return this.radius = void 0 !== radius ? radius : 1, this.phi = void 0 !== phi ? phi : 0,
        this.theta = void 0 !== theta ? theta : 0, this;
    }
    function Cylindrical(radius, theta, y) {
        return this.radius = void 0 !== radius ? radius : 1, this.theta = void 0 !== theta ? theta : 0,
        this.y = void 0 !== y ? y : 0, this;
    }
    function ImmediateRenderObject(material) {
        Object3D.call(this), this.material = material, this.render = function() {};
    }
    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16711680, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = 3 * objGeometry.faces.length : objGeometry && objGeometry.isBufferGeometry && (nNormals = objGeometry.attributes.normal.count);
        var geometry = new BufferGeometry(), positions = new Float32BufferAttribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function SpotLightHelper(light, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld,
        this.matrixAutoUpdate = !1, this.color = color;
        for (var geometry = new BufferGeometry(), positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ], i = 0, j = 1; i < 32; i++,
        j++) {
            var p1 = i / 32 * Math.PI * 2, p2 = j / 32 * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.cone = new LineSegments(geometry, material), this.add(this.cone), this.update();
    }
    function getBoneList(object) {
        var boneList = [];
        object && object.isBone && boneList.push(object);
        for (var i = 0; i < object.children.length; i++) boneList.push.apply(boneList, getBoneList(object.children[i]));
        return boneList;
    }
    function SkeletonHelper(object) {
        for (var bones = getBoneList(object), geometry = new BufferGeometry(), vertices = [], colors = [], color1 = new Color(0, 0, 1), color2 = new Color(0, 1, 0), i = 0; i < bones.length; i++) {
            var bone = bones[i];
            bone.parent && bone.parent.isBone && (vertices.push(0, 0, 0), vertices.push(0, 0, 0),
            colors.push(color1.r, color1.g, color1.b), colors.push(color2.r, color2.g, color2.b));
        }
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        LineSegments.call(this, geometry, material), this.root = object, this.bones = bones,
        this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1;
    }
    function PointLightHelper(light, sphereSize, color) {
        this.light = light, this.light.updateMatrixWorld(), this.color = color;
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2), material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        Mesh.call(this, geometry, material), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1,
        this.update();
    }
    function RectAreaLightHelper(light, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld,
        this.matrixAutoUpdate = !1, this.color = color;
        var material = new LineBasicMaterial({
            fog: !1
        }), geometry = new BufferGeometry();
        geometry.addAttribute("position", new BufferAttribute(new Float32Array(15), 3)),
        this.line = new Line(geometry, material), this.add(this.line), this.update();
    }
    function HemisphereLightHelper(light, size, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld,
        this.matrixAutoUpdate = !1, this.color = color;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(.5 * Math.PI), this.material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = VertexColors);
        var position = geometry.getAttribute("position"), colors = new Float32Array(3 * position.count);
        geometry.addAttribute("color", new BufferAttribute(colors, 3)), this.add(new Mesh(geometry, this.material)),
        this.update();
    }
    function GridHelper(size, divisions, color1, color2) {
        size = size || 10, divisions = divisions || 10, color1 = new Color(void 0 !== color1 ? color1 : 4473924),
        color2 = new Color(void 0 !== color2 ? color2 : 8947848);
        for (var center = divisions / 2, step = size / divisions, halfSize = size / 2, vertices = [], colors = [], i = 0, j = 0, k = -halfSize; i <= divisions; i++,
        k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k), vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3, color.toArray(colors, j),
            j += 3, color.toArray(colors, j), j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10, radials = radials || 16, circles = circles || 8, divisions = divisions || 64,
        color1 = new Color(void 0 !== color1 ? color1 : 4473924), color2 = new Color(void 0 !== color2 ? color2 : 8947848);
        var x, z, v, i, j, r, color, vertices = [], colors = [];
        for (i = 0; i <= radials; i++) v = i / radials * (2 * Math.PI), x = Math.sin(v) * radius,
        z = Math.cos(v) * radius, vertices.push(0, 0, 0), vertices.push(x, 0, z), color = 1 & i ? color1 : color2,
        colors.push(color.r, color.g, color.b), colors.push(color.r, color.g, color.b);
        for (i = 0; i <= circles; i++) for (color = 1 & i ? color1 : color2, r = radius - radius / circles * i,
        j = 0; j < divisions; j++) v = j / divisions * (2 * Math.PI), x = Math.sin(v) * r,
        z = Math.cos(v) * r, vertices.push(x, 0, z), colors.push(color.r, color.g, color.b),
        v = (j + 1) / divisions * (2 * Math.PI), x = Math.sin(v) * r, z = Math.cos(v) * r,
        vertices.push(x, 0, z), colors.push(color.r, color.g, color.b);
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16776960, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = objGeometry.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var geometry = new BufferGeometry(), positions = new Float32BufferAttribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function DirectionalLightHelper(light, size, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld,
        this.matrixAutoUpdate = !1, this.color = color, void 0 === size && (size = 1);
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ -size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0 ], 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.lightPlane = new Line(geometry, material), this.add(this.lightPlane), geometry = new BufferGeometry(),
        geometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3)),
        this.targetLine = new Line(geometry, material), this.add(this.targetLine), this.update();
    }
    function CameraHelper(camera) {
        function addLine(a, b, color) {
            addPoint(a, color), addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0), colors.push(color.r, color.g, color.b), void 0 === pointMap[id] && (pointMap[id] = []),
            pointMap[id].push(vertices.length / 3 - 1);
        }
        var geometry = new BufferGeometry(), material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: FaceColors
        }), vertices = [], colors = [], pointMap = {}, colorFrustum = new Color(16755200), colorCone = new Color(16711680), colorUp = new Color(43775), colorTarget = new Color(16777215), colorCross = new Color(3355443);
        addLine("n1", "n2", colorFrustum), addLine("n2", "n4", colorFrustum), addLine("n4", "n3", colorFrustum),
        addLine("n3", "n1", colorFrustum), addLine("f1", "f2", colorFrustum), addLine("f2", "f4", colorFrustum),
        addLine("f4", "f3", colorFrustum), addLine("f3", "f1", colorFrustum), addLine("n1", "f1", colorFrustum),
        addLine("n2", "f2", colorFrustum), addLine("n3", "f3", colorFrustum), addLine("n4", "f4", colorFrustum),
        addLine("p", "n1", colorCone), addLine("p", "n2", colorCone), addLine("p", "n3", colorCone),
        addLine("p", "n4", colorCone), addLine("u1", "u2", colorUp), addLine("u2", "u3", colorUp),
        addLine("u3", "u1", colorUp), addLine("c", "t", colorTarget), addLine("p", "c", colorCross),
        addLine("cn1", "cn2", colorCross), addLine("cn3", "cn4", colorCross), addLine("cf1", "cf2", colorCross),
        addLine("cf3", "cf4", colorCross), geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)),
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3)), LineSegments.call(this, geometry, material),
        this.camera = camera, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = camera.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = pointMap,
        this.update();
    }
    function BoxHelper(object, color) {
        this.object = object, void 0 === color && (color = 16776960);
        var indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), positions = new Float32Array(24), geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1)), geometry.addAttribute("position", new BufferAttribute(positions, 3)),
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function Box3Helper(box, hex) {
        this.type = "Box3Helper", this.box = box;
        var color = void 0 !== hex ? hex : 16776960, indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), positions = [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 ], geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1)), geometry.addAttribute("position", new Float32BufferAttribute(positions, 3)),
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        })), this.geometry.computeBoundingSphere();
    }
    function PlaneHelper(plane, size, hex) {
        this.type = "PlaneHelper", this.plane = plane, this.size = void 0 === size ? 1 : size;
        var color = void 0 !== hex ? hex : 16776960, positions = [ 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ], geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(positions, 3)), geometry.computeBoundingSphere(),
        Line.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        var positions2 = [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1 ], geometry2 = new BufferGeometry();
        geometry2.addAttribute("position", new Float32BufferAttribute(positions2, 3)), geometry2.computeBoundingSphere(),
        this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color: color,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })));
    }
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this), void 0 === color && (color = 16776960), void 0 === length && (length = 1),
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength),
        void 0 === lineGeometry && (lineGeometry = new BufferGeometry(), lineGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 1, 0 ], 3)),
        coneGeometry = new CylinderBufferGeometry(0, .5, 1, 5, 1), coneGeometry.translate(0, -.5, 0)),
        this.position.copy(origin), this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(dir),
        this.setLength(length, headLength, headWidth);
    }
    function AxesHelper(size) {
        size = size || 1;
        var vertices = [ 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size ], colors = [ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ], geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function CubicPoly() {
        function init(x0, x1, t0, t1) {
            c0 = x0, c1 = t0, c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1, c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        return {
            initCatmullRom: function(x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1, t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                t1 *= dt1, t2 *= dt1, init(x1, x2, t1, t2);
            },
            calc: function(t) {
                var t2 = t * t;
                return c0 + c1 * t + c2 * t2 + c3 * (t2 * t);
            }
        };
    }
    function CatmullRomCurve3(points, closed, curveType, tension) {
        Curve.call(this), this.type = "CatmullRomCurve3", this.points = points || [], this.closed = closed || !1,
        this.curveType = curveType || "centripetal", this.tension = tension || .5;
    }
    function CubicBezierCurve3(v0, v1, v2, v3) {
        Curve.call(this), this.type = "CubicBezierCurve3", this.v0 = v0 || new Vector3(),
        this.v1 = v1 || new Vector3(), this.v2 = v2 || new Vector3(), this.v3 = v3 || new Vector3();
    }
    function QuadraticBezierCurve3(v0, v1, v2) {
        Curve.call(this), this.type = "QuadraticBezierCurve3", this.v0 = v0 || new Vector3(),
        this.v1 = v1 || new Vector3(), this.v2 = v2 || new Vector3();
    }
    function LineCurve3(v1, v2) {
        Curve.call(this), this.type = "LineCurve3", this.v1 = v1 || new Vector3(), this.v2 = v2 || new Vector3();
    }
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise),
        this.type = "ArcCurve";
    }
    function Face4(a, b, c, d, normal, color, materialIndex) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new Face3(a, b, c, normal, color, materialIndex);
    }
    function MeshFaceMaterial(materials) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        materials;
    }
    function MultiMaterial(materials) {
        return void 0 === materials && (materials = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        materials.isMultiMaterial = !0, materials.materials = materials, materials.clone = function() {
            return materials.slice();
        }, materials;
    }
    function PointCloud(geometry, material) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function Particle(material) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(material);
    }
    function ParticleSystem(geometry, material) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function PointCloudMaterial(parameters) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new PointsMaterial(parameters);
    }
    function Vertex(x, y, z) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new Vector3(x, y, z);
    }
    function DynamicBufferAttribute(array, itemSize) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new BufferAttribute(array, itemSize).setDynamic(!0);
    }
    function Int8Attribute(array, itemSize) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new Int8BufferAttribute(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new Uint8BufferAttribute(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new Uint8ClampedBufferAttribute(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new Int16BufferAttribute(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new Uint16BufferAttribute(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new Int32BufferAttribute(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new Uint32BufferAttribute(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new Float32BufferAttribute(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new Float64BufferAttribute(array, itemSize);
    }
    function ClosedSplineCurve3(points) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        CatmullRomCurve3.call(this, points), this.type = "catmullrom", this.closed = !0;
    }
    function SplineCurve3(points) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        CatmullRomCurve3.call(this, points), this.type = "catmullrom";
    }
    function Spline(points) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        CatmullRomCurve3.call(this, points), this.type = "catmullrom";
    }
    function AxisHelper(size) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new AxesHelper(size);
    }
    function BoundingBoxHelper(object, color) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new BoxHelper(object, color);
    }
    function EdgesHelper(object, hex) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function WireframeHelper(object, hex) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function XHRLoader(manager) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(manager);
    }
    function BinaryTextureLoader(manager) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new DataTextureLoader(manager);
    }
    function Projector() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
        this.projectVector = function(vector, camera) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), vector.project(camera);
        }, this.unprojectVector = function(vector, camera) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
            vector.unproject(camera);
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
    }
    function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {},
        this.setSize = function() {};
    }
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: !0
    }), __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() {
        return WebGLRenderTargetCube;
    }), __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() {
        return WebGLRenderTarget;
    }), __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() {
        return WebGLRenderer;
    }), __webpack_require__.d(__webpack_exports__, "ShaderLib", function() {
        return ShaderLib;
    }), __webpack_require__.d(__webpack_exports__, "UniformsLib", function() {
        return UniformsLib;
    }), __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() {
        return UniformsUtils;
    }), __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() {
        return ShaderChunk;
    }), __webpack_require__.d(__webpack_exports__, "FogExp2", function() {
        return FogExp2;
    }), __webpack_require__.d(__webpack_exports__, "Fog", function() {
        return Fog;
    }), __webpack_require__.d(__webpack_exports__, "Scene", function() {
        return Scene;
    }), __webpack_require__.d(__webpack_exports__, "LensFlare", function() {
        return LensFlare;
    }), __webpack_require__.d(__webpack_exports__, "Sprite", function() {
        return Sprite;
    }), __webpack_require__.d(__webpack_exports__, "LOD", function() {
        return LOD;
    }), __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() {
        return SkinnedMesh;
    }), __webpack_require__.d(__webpack_exports__, "Skeleton", function() {
        return Skeleton;
    }), __webpack_require__.d(__webpack_exports__, "Bone", function() {
        return Bone;
    }), __webpack_require__.d(__webpack_exports__, "Mesh", function() {
        return Mesh;
    }), __webpack_require__.d(__webpack_exports__, "LineSegments", function() {
        return LineSegments;
    }), __webpack_require__.d(__webpack_exports__, "LineLoop", function() {
        return LineLoop;
    }), __webpack_require__.d(__webpack_exports__, "Line", function() {
        return Line;
    }), __webpack_require__.d(__webpack_exports__, "Points", function() {
        return Points;
    }), __webpack_require__.d(__webpack_exports__, "Group", function() {
        return Group;
    }), __webpack_require__.d(__webpack_exports__, "VideoTexture", function() {
        return VideoTexture;
    }), __webpack_require__.d(__webpack_exports__, "DataTexture", function() {
        return DataTexture;
    }), __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() {
        return CompressedTexture;
    }), __webpack_require__.d(__webpack_exports__, "CubeTexture", function() {
        return CubeTexture;
    }), __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() {
        return CanvasTexture;
    }), __webpack_require__.d(__webpack_exports__, "DepthTexture", function() {
        return DepthTexture;
    }), __webpack_require__.d(__webpack_exports__, "Texture", function() {
        return Texture;
    }), __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() {
        return CompressedTextureLoader;
    }), __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() {
        return DataTextureLoader;
    }), __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() {
        return CubeTextureLoader;
    }), __webpack_require__.d(__webpack_exports__, "TextureLoader", function() {
        return TextureLoader;
    }), __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() {
        return ObjectLoader;
    }), __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() {
        return MaterialLoader;
    }), __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() {
        return BufferGeometryLoader;
    }), __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() {
        return DefaultLoadingManager;
    }), __webpack_require__.d(__webpack_exports__, "LoadingManager", function() {
        return LoadingManager;
    }), __webpack_require__.d(__webpack_exports__, "JSONLoader", function() {
        return JSONLoader;
    }), __webpack_require__.d(__webpack_exports__, "ImageLoader", function() {
        return ImageLoader;
    }), __webpack_require__.d(__webpack_exports__, "FontLoader", function() {
        return FontLoader;
    }), __webpack_require__.d(__webpack_exports__, "FileLoader", function() {
        return FileLoader;
    }), __webpack_require__.d(__webpack_exports__, "Loader", function() {
        return Loader;
    }), __webpack_require__.d(__webpack_exports__, "Cache", function() {
        return Cache;
    }), __webpack_require__.d(__webpack_exports__, "AudioLoader", function() {
        return AudioLoader;
    }), __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() {
        return SpotLightShadow;
    }), __webpack_require__.d(__webpack_exports__, "SpotLight", function() {
        return SpotLight;
    }), __webpack_require__.d(__webpack_exports__, "PointLight", function() {
        return PointLight;
    }), __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() {
        return RectAreaLight;
    }), __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() {
        return HemisphereLight;
    }), __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() {
        return DirectionalLightShadow;
    }), __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() {
        return DirectionalLight;
    }), __webpack_require__.d(__webpack_exports__, "AmbientLight", function() {
        return AmbientLight;
    }), __webpack_require__.d(__webpack_exports__, "LightShadow", function() {
        return LightShadow;
    }), __webpack_require__.d(__webpack_exports__, "Light", function() {
        return Light;
    }), __webpack_require__.d(__webpack_exports__, "StereoCamera", function() {
        return StereoCamera;
    }), __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() {
        return PerspectiveCamera;
    }), __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() {
        return OrthographicCamera;
    }), __webpack_require__.d(__webpack_exports__, "CubeCamera", function() {
        return CubeCamera;
    }), __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() {
        return ArrayCamera;
    }), __webpack_require__.d(__webpack_exports__, "Camera", function() {
        return Camera;
    }), __webpack_require__.d(__webpack_exports__, "AudioListener", function() {
        return AudioListener;
    }), __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() {
        return PositionalAudio;
    }), __webpack_require__.d(__webpack_exports__, "AudioContext", function() {
        return AudioContext;
    }), __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() {
        return AudioAnalyser;
    }), __webpack_require__.d(__webpack_exports__, "Audio", function() {
        return Audio;
    }), __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() {
        return VectorKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() {
        return StringKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() {
        return QuaternionKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() {
        return NumberKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() {
        return ColorKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() {
        return BooleanKeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() {
        return PropertyMixer;
    }), __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() {
        return PropertyBinding;
    }), __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() {
        return KeyframeTrack;
    }), __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() {
        return AnimationUtils;
    }), __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() {
        return AnimationObjectGroup;
    }), __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() {
        return AnimationMixer;
    }), __webpack_require__.d(__webpack_exports__, "AnimationClip", function() {
        return AnimationClip;
    }), __webpack_require__.d(__webpack_exports__, "Uniform", function() {
        return Uniform;
    }), __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() {
        return InstancedBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() {
        return BufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "Geometry", function() {
        return Geometry;
    }), __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() {
        return InterleavedBufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() {
        return InstancedInterleavedBuffer;
    }), __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() {
        return InterleavedBuffer;
    }), __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() {
        return InstancedBufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Face3", function() {
        return Face3;
    }), __webpack_require__.d(__webpack_exports__, "Object3D", function() {
        return Object3D;
    }), __webpack_require__.d(__webpack_exports__, "Raycaster", function() {
        return Raycaster;
    }), __webpack_require__.d(__webpack_exports__, "Layers", function() {
        return Layers;
    }), __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() {
        return EventDispatcher;
    }), __webpack_require__.d(__webpack_exports__, "Clock", function() {
        return Clock;
    }), __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() {
        return QuaternionLinearInterpolant;
    }), __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() {
        return LinearInterpolant;
    }), __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() {
        return DiscreteInterpolant;
    }), __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() {
        return CubicInterpolant;
    }), __webpack_require__.d(__webpack_exports__, "Interpolant", function() {
        return Interpolant;
    }), __webpack_require__.d(__webpack_exports__, "Triangle", function() {
        return Triangle;
    }), __webpack_require__.d(__webpack_exports__, "Math", function() {
        return _Math;
    }), __webpack_require__.d(__webpack_exports__, "Spherical", function() {
        return Spherical;
    }), __webpack_require__.d(__webpack_exports__, "Cylindrical", function() {
        return Cylindrical;
    }), __webpack_require__.d(__webpack_exports__, "Plane", function() {
        return Plane;
    }), __webpack_require__.d(__webpack_exports__, "Frustum", function() {
        return Frustum;
    }), __webpack_require__.d(__webpack_exports__, "Sphere", function() {
        return Sphere;
    }), __webpack_require__.d(__webpack_exports__, "Ray", function() {
        return Ray;
    }), __webpack_require__.d(__webpack_exports__, "Matrix4", function() {
        return Matrix4;
    }), __webpack_require__.d(__webpack_exports__, "Matrix3", function() {
        return Matrix3;
    }), __webpack_require__.d(__webpack_exports__, "Box3", function() {
        return Box3;
    }), __webpack_require__.d(__webpack_exports__, "Box2", function() {
        return Box2;
    }), __webpack_require__.d(__webpack_exports__, "Line3", function() {
        return Line3;
    }), __webpack_require__.d(__webpack_exports__, "Euler", function() {
        return Euler;
    }), __webpack_require__.d(__webpack_exports__, "Vector4", function() {
        return Vector4;
    }), __webpack_require__.d(__webpack_exports__, "Vector3", function() {
        return Vector3;
    }), __webpack_require__.d(__webpack_exports__, "Vector2", function() {
        return Vector2;
    }), __webpack_require__.d(__webpack_exports__, "Quaternion", function() {
        return Quaternion;
    }), __webpack_require__.d(__webpack_exports__, "Color", function() {
        return Color;
    }), __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() {
        return ImmediateRenderObject;
    }), __webpack_require__.d(__webpack_exports__, "VertexNormalsHelper", function() {
        return VertexNormalsHelper;
    }), __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() {
        return SpotLightHelper;
    }), __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() {
        return SkeletonHelper;
    }), __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() {
        return PointLightHelper;
    }), __webpack_require__.d(__webpack_exports__, "RectAreaLightHelper", function() {
        return RectAreaLightHelper;
    }), __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() {
        return HemisphereLightHelper;
    }), __webpack_require__.d(__webpack_exports__, "GridHelper", function() {
        return GridHelper;
    }), __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() {
        return PolarGridHelper;
    }), __webpack_require__.d(__webpack_exports__, "FaceNormalsHelper", function() {
        return FaceNormalsHelper;
    }), __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() {
        return DirectionalLightHelper;
    }), __webpack_require__.d(__webpack_exports__, "CameraHelper", function() {
        return CameraHelper;
    }), __webpack_require__.d(__webpack_exports__, "BoxHelper", function() {
        return BoxHelper;
    }), __webpack_require__.d(__webpack_exports__, "Box3Helper", function() {
        return Box3Helper;
    }), __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() {
        return PlaneHelper;
    }), __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() {
        return ArrowHelper;
    }), __webpack_require__.d(__webpack_exports__, "AxesHelper", function() {
        return AxesHelper;
    }), __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() {
        return CatmullRomCurve3;
    }), __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() {
        return CubicBezierCurve3;
    }), __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() {
        return QuadraticBezierCurve3;
    }), __webpack_require__.d(__webpack_exports__, "LineCurve3", function() {
        return LineCurve3;
    }), __webpack_require__.d(__webpack_exports__, "ArcCurve", function() {
        return ArcCurve;
    }), __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() {
        return EllipseCurve;
    }), __webpack_require__.d(__webpack_exports__, "SplineCurve", function() {
        return SplineCurve;
    }), __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() {
        return CubicBezierCurve;
    }), __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() {
        return QuadraticBezierCurve;
    }), __webpack_require__.d(__webpack_exports__, "LineCurve", function() {
        return LineCurve;
    }), __webpack_require__.d(__webpack_exports__, "Shape", function() {
        return Shape;
    }), __webpack_require__.d(__webpack_exports__, "Path", function() {
        return Path;
    }), __webpack_require__.d(__webpack_exports__, "ShapePath", function() {
        return ShapePath;
    }), __webpack_require__.d(__webpack_exports__, "Font", function() {
        return Font;
    }), __webpack_require__.d(__webpack_exports__, "CurvePath", function() {
        return CurvePath;
    }), __webpack_require__.d(__webpack_exports__, "Curve", function() {
        return Curve;
    }), __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() {
        return ShapeUtils;
    }), __webpack_require__.d(__webpack_exports__, "SceneUtils", function() {
        return SceneUtils;
    }), __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() {
        return WebGLUtils;
    }), __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() {
        return WireframeGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() {
        return ParametricGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() {
        return ParametricBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() {
        return TetrahedronGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() {
        return TetrahedronBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() {
        return OctahedronGeometry;
    }), __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() {
        return OctahedronBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() {
        return IcosahedronGeometry;
    }), __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() {
        return IcosahedronBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() {
        return DodecahedronGeometry;
    }), __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() {
        return DodecahedronBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() {
        return PolyhedronGeometry;
    }), __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() {
        return PolyhedronBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() {
        return TubeGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() {
        return TubeBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() {
        return TorusKnotGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() {
        return TorusKnotBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() {
        return TorusGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() {
        return TorusBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TextGeometry", function() {
        return TextGeometry;
    }), __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() {
        return TextBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() {
        return SphereGeometry;
    }), __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() {
        return SphereBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "RingGeometry", function() {
        return RingGeometry;
    }), __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() {
        return RingBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() {
        return PlaneGeometry;
    }), __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() {
        return PlaneBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() {
        return LatheGeometry;
    }), __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() {
        return LatheBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() {
        return ShapeGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() {
        return ShapeBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() {
        return ExtrudeGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() {
        return ExtrudeBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() {
        return EdgesGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() {
        return ConeGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() {
        return ConeBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() {
        return CylinderGeometry;
    }), __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() {
        return CylinderBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() {
        return CircleGeometry;
    }), __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() {
        return CircleBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() {
        return BoxGeometry;
    }), __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() {
        return BoxBufferGeometry;
    }), __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() {
        return ShadowMaterial;
    }), __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() {
        return SpriteMaterial;
    }), __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() {
        return RawShaderMaterial;
    }), __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() {
        return ShaderMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() {
        return PointsMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() {
        return MeshPhysicalMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() {
        return MeshStandardMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() {
        return MeshPhongMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() {
        return MeshToonMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() {
        return MeshNormalMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() {
        return MeshLambertMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() {
        return MeshDepthMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() {
        return MeshDistanceMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() {
        return MeshBasicMaterial;
    }), __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() {
        return LineDashedMaterial;
    }), __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() {
        return LineBasicMaterial;
    }), __webpack_require__.d(__webpack_exports__, "Material", function() {
        return Material;
    }), __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() {
        return Float64BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() {
        return Float32BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() {
        return Uint32BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() {
        return Int32BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() {
        return Uint16BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() {
        return Int16BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() {
        return Uint8ClampedBufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() {
        return Uint8BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() {
        return Int8BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() {
        return BufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "REVISION", function() {
        return REVISION;
    }), __webpack_require__.d(__webpack_exports__, "MOUSE", function() {
        return MOUSE;
    }), __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() {
        return CullFaceNone;
    }), __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() {
        return CullFaceBack;
    }), __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() {
        return CullFaceFront;
    }), __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() {
        return CullFaceFrontBack;
    }), __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() {
        return FrontFaceDirectionCW;
    }), __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() {
        return FrontFaceDirectionCCW;
    }), __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() {
        return BasicShadowMap;
    }), __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() {
        return PCFShadowMap;
    }), __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() {
        return PCFSoftShadowMap;
    }), __webpack_require__.d(__webpack_exports__, "FrontSide", function() {
        return FrontSide;
    }), __webpack_require__.d(__webpack_exports__, "BackSide", function() {
        return BackSide;
    }), __webpack_require__.d(__webpack_exports__, "DoubleSide", function() {
        return DoubleSide;
    }), __webpack_require__.d(__webpack_exports__, "FlatShading", function() {
        return FlatShading;
    }), __webpack_require__.d(__webpack_exports__, "SmoothShading", function() {
        return SmoothShading;
    }), __webpack_require__.d(__webpack_exports__, "NoColors", function() {
        return NoColors;
    }), __webpack_require__.d(__webpack_exports__, "FaceColors", function() {
        return FaceColors;
    }), __webpack_require__.d(__webpack_exports__, "VertexColors", function() {
        return VertexColors;
    }), __webpack_require__.d(__webpack_exports__, "NoBlending", function() {
        return NoBlending;
    }), __webpack_require__.d(__webpack_exports__, "NormalBlending", function() {
        return NormalBlending;
    }), __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() {
        return AdditiveBlending;
    }), __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() {
        return SubtractiveBlending;
    }), __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() {
        return MultiplyBlending;
    }), __webpack_require__.d(__webpack_exports__, "CustomBlending", function() {
        return CustomBlending;
    }), __webpack_require__.d(__webpack_exports__, "AddEquation", function() {
        return AddEquation;
    }), __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() {
        return SubtractEquation;
    }), __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() {
        return ReverseSubtractEquation;
    }), __webpack_require__.d(__webpack_exports__, "MinEquation", function() {
        return MinEquation;
    }), __webpack_require__.d(__webpack_exports__, "MaxEquation", function() {
        return MaxEquation;
    }), __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() {
        return ZeroFactor;
    }), __webpack_require__.d(__webpack_exports__, "OneFactor", function() {
        return OneFactor;
    }), __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() {
        return SrcColorFactor;
    }), __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() {
        return OneMinusSrcColorFactor;
    }), __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() {
        return SrcAlphaFactor;
    }), __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() {
        return OneMinusSrcAlphaFactor;
    }), __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() {
        return DstAlphaFactor;
    }), __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() {
        return OneMinusDstAlphaFactor;
    }), __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() {
        return DstColorFactor;
    }), __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() {
        return OneMinusDstColorFactor;
    }), __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() {
        return SrcAlphaSaturateFactor;
    }), __webpack_require__.d(__webpack_exports__, "NeverDepth", function() {
        return NeverDepth;
    }), __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() {
        return AlwaysDepth;
    }), __webpack_require__.d(__webpack_exports__, "LessDepth", function() {
        return LessDepth;
    }), __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() {
        return LessEqualDepth;
    }), __webpack_require__.d(__webpack_exports__, "EqualDepth", function() {
        return EqualDepth;
    }), __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() {
        return GreaterEqualDepth;
    }), __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() {
        return GreaterDepth;
    }), __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() {
        return NotEqualDepth;
    }), __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() {
        return MultiplyOperation;
    }), __webpack_require__.d(__webpack_exports__, "MixOperation", function() {
        return MixOperation;
    }), __webpack_require__.d(__webpack_exports__, "AddOperation", function() {
        return AddOperation;
    }), __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() {
        return NoToneMapping;
    }), __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() {
        return LinearToneMapping;
    }), __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() {
        return ReinhardToneMapping;
    }), __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() {
        return Uncharted2ToneMapping;
    }), __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() {
        return CineonToneMapping;
    }), __webpack_require__.d(__webpack_exports__, "UVMapping", function() {
        return UVMapping;
    }), __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() {
        return CubeReflectionMapping;
    }), __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() {
        return CubeRefractionMapping;
    }), __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() {
        return EquirectangularReflectionMapping;
    }), __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() {
        return EquirectangularRefractionMapping;
    }), __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() {
        return SphericalReflectionMapping;
    }), __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() {
        return CubeUVReflectionMapping;
    }), __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() {
        return CubeUVRefractionMapping;
    }), __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() {
        return RepeatWrapping;
    }), __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() {
        return ClampToEdgeWrapping;
    }), __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() {
        return MirroredRepeatWrapping;
    }), __webpack_require__.d(__webpack_exports__, "NearestFilter", function() {
        return NearestFilter;
    }), __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() {
        return NearestMipMapNearestFilter;
    }), __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() {
        return NearestMipMapLinearFilter;
    }), __webpack_require__.d(__webpack_exports__, "LinearFilter", function() {
        return LinearFilter;
    }), __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() {
        return LinearMipMapNearestFilter;
    }), __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() {
        return LinearMipMapLinearFilter;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() {
        return UnsignedByteType;
    }), __webpack_require__.d(__webpack_exports__, "ByteType", function() {
        return ByteType;
    }), __webpack_require__.d(__webpack_exports__, "ShortType", function() {
        return ShortType;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() {
        return UnsignedShortType;
    }), __webpack_require__.d(__webpack_exports__, "IntType", function() {
        return IntType;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() {
        return UnsignedIntType;
    }), __webpack_require__.d(__webpack_exports__, "FloatType", function() {
        return FloatType;
    }), __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() {
        return HalfFloatType;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() {
        return UnsignedShort4444Type;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() {
        return UnsignedShort5551Type;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() {
        return UnsignedShort565Type;
    }), __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() {
        return UnsignedInt248Type;
    }), __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() {
        return AlphaFormat;
    }), __webpack_require__.d(__webpack_exports__, "RGBFormat", function() {
        return RGBFormat;
    }), __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() {
        return RGBAFormat;
    }), __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() {
        return LuminanceFormat;
    }), __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() {
        return LuminanceAlphaFormat;
    }), __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() {
        return RGBEFormat;
    }), __webpack_require__.d(__webpack_exports__, "DepthFormat", function() {
        return DepthFormat;
    }), __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() {
        return DepthStencilFormat;
    }), __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() {
        return RGB_S3TC_DXT1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() {
        return RGBA_S3TC_DXT1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() {
        return RGBA_S3TC_DXT3_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() {
        return RGBA_S3TC_DXT5_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() {
        return RGB_PVRTC_4BPPV1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() {
        return RGB_PVRTC_2BPPV1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() {
        return RGBA_PVRTC_4BPPV1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() {
        return RGBA_PVRTC_2BPPV1_Format;
    }), __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() {
        return RGB_ETC1_Format;
    }), __webpack_require__.d(__webpack_exports__, "LoopOnce", function() {
        return LoopOnce;
    }), __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() {
        return LoopRepeat;
    }), __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() {
        return LoopPingPong;
    }), __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() {
        return InterpolateDiscrete;
    }), __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() {
        return InterpolateLinear;
    }), __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() {
        return InterpolateSmooth;
    }), __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() {
        return ZeroCurvatureEnding;
    }), __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() {
        return ZeroSlopeEnding;
    }), __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() {
        return WrapAroundEnding;
    }), __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() {
        return TrianglesDrawMode;
    }), __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() {
        return TriangleStripDrawMode;
    }), __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() {
        return TriangleFanDrawMode;
    }), __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() {
        return LinearEncoding;
    }), __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() {
        return sRGBEncoding;
    }), __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() {
        return GammaEncoding;
    }), __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() {
        return RGBEEncoding;
    }), __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() {
        return LogLuvEncoding;
    }), __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() {
        return RGBM7Encoding;
    }), __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() {
        return RGBM16Encoding;
    }), __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() {
        return RGBDEncoding;
    }), __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() {
        return BasicDepthPacking;
    }), __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() {
        return RGBADepthPacking;
    }), __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() {
        return BoxGeometry;
    }), __webpack_require__.d(__webpack_exports__, "Face4", function() {
        return Face4;
    }), __webpack_require__.d(__webpack_exports__, "LineStrip", function() {
        return LineStrip;
    }), __webpack_require__.d(__webpack_exports__, "LinePieces", function() {
        return LinePieces;
    }), __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() {
        return MeshFaceMaterial;
    }), __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() {
        return MultiMaterial;
    }), __webpack_require__.d(__webpack_exports__, "PointCloud", function() {
        return PointCloud;
    }), __webpack_require__.d(__webpack_exports__, "Particle", function() {
        return Particle;
    }), __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() {
        return ParticleSystem;
    }), __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() {
        return PointCloudMaterial;
    }), __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() {
        return ParticleBasicMaterial;
    }), __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() {
        return ParticleSystemMaterial;
    }), __webpack_require__.d(__webpack_exports__, "Vertex", function() {
        return Vertex;
    }), __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() {
        return DynamicBufferAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() {
        return Int8Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() {
        return Uint8Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() {
        return Uint8ClampedAttribute;
    }), __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() {
        return Int16Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() {
        return Uint16Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() {
        return Int32Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() {
        return Uint32Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() {
        return Float32Attribute;
    }), __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() {
        return Float64Attribute;
    }), __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() {
        return ClosedSplineCurve3;
    }), __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() {
        return SplineCurve3;
    }), __webpack_require__.d(__webpack_exports__, "Spline", function() {
        return Spline;
    }), __webpack_require__.d(__webpack_exports__, "AxisHelper", function() {
        return AxisHelper;
    }), __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() {
        return BoundingBoxHelper;
    }), __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() {
        return EdgesHelper;
    }), __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() {
        return WireframeHelper;
    }), __webpack_require__.d(__webpack_exports__, "XHRLoader", function() {
        return XHRLoader;
    }), __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() {
        return BinaryTextureLoader;
    }), __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() {
        return GeometryUtils;
    }), __webpack_require__.d(__webpack_exports__, "ImageUtils", function() {
        return ImageUtils;
    }), __webpack_require__.d(__webpack_exports__, "Projector", function() {
        return Projector;
    }), __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() {
        return CanvasRenderer;
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(value) {
        return "number" == typeof value && isFinite(value) && Math.floor(value) === value;
    }), void 0 === Math.sign && (Math.sign = function(x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
    }), void 0 === Object.assign && function() {
        Object.assign = function(target) {
            if (void 0 === target || null === target) throw new TypeError("Cannot convert undefined or null to object");
            for (var output = Object(target), index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (void 0 !== source && null !== source) for (var nextKey in source) Object.prototype.hasOwnProperty.call(source, nextKey) && (output[nextKey] = source[nextKey]);
            }
            return output;
        };
    }(), Object.assign(EventDispatcher.prototype, {
        addEventListener: function(type, listener) {
            void 0 === this._listeners && (this._listeners = {});
            var listeners = this._listeners;
            void 0 === listeners[type] && (listeners[type] = []), -1 === listeners[type].indexOf(listener) && listeners[type].push(listener);
        },
        hasEventListener: function(type, listener) {
            if (void 0 === this._listeners) return !1;
            var listeners = this._listeners;
            return void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener);
        },
        removeEventListener: function(type, listener) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[type];
                if (void 0 !== listenerArray) {
                    var index = listenerArray.indexOf(listener);
                    -1 !== index && listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function(event) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[event.type];
                if (void 0 !== listenerArray) {
                    event.target = this;
                    for (var array = listenerArray.slice(0), i = 0, l = array.length; i < l; i++) array[i].call(this, event);
                }
            }
        }
    });
    var REVISION = "88", MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, FrontFaceDirectionCW = 0, FrontFaceDirectionCCW = 1, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoColors = 0, FaceColors = 1, VertexColors = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, Uncharted2ToneMapping = 3, CineonToneMapping = 4, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, SphericalReflectionMapping = 305, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipMapNearestFilter = 1004, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipMapNearestFilter = 1007, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RGB_S3TC_DXT1_Format = 2001, RGBA_S3TC_DXT1_Format = 2002, RGBA_S3TC_DXT3_Format = 2003, RGBA_S3TC_DXT5_Format = 2004, RGB_PVRTC_4BPPV1_Format = 2100, RGB_PVRTC_2BPPV1_Format = 2101, RGBA_PVRTC_4BPPV1_Format = 2102, RGBA_PVRTC_2BPPV1_Format = 2103, RGB_ETC1_Format = 2151, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var r, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), rnd = 0;
            return function() {
                for (var uuid = "", i = 0; i < 36; i++) 8 === i || 13 === i || 18 === i || 23 === i ? uuid += "-" : 14 === i ? uuid += "4" : (rnd <= 2 && (rnd = 33554432 + 16777216 * Math.random() | 0),
                r = 15 & rnd, rnd >>= 4, uuid += chars[19 === i ? 3 & r | 8 : r]);
                return uuid;
            };
        }(),
        clamp: function(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function(n, m) {
            return (n % m + m) % m;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function(x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * x * (x * (6 * x - 15) + 10);
        },
        randInt: function(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function(low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function(range) {
            return range * (.5 - Math.random());
        },
        degToRad: function(degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function(radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function(value) {
            return 0 == (value & value - 1) && 0 !== value;
        },
        ceilPowerOfTwo: function(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        },
        floorPowerOfTwo: function(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
    };
    Object.defineProperties(Vector2.prototype, {
        width: {
            get: function() {
                return this.x;
            },
            set: function(value) {
                this.x = value;
            }
        },
        height: {
            get: function() {
                return this.y;
            },
            set: function(value) {
                this.y = value;
            }
        }
    }), Object.assign(Vector2.prototype, {
        isVector2: !0,
        set: function(x, y) {
            return this.x = x, this.y = y, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this;
        },
        multiply: function(v) {
            return this.x *= v.x, this.y *= v.y, this;
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this;
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        applyMatrix3: function(m) {
            var x = this.x, y = this.y, e = m.elements;
            return this.x = e[0] * x + e[3] * y + e[6], this.y = e[1] * x + e[4] * y + e[7],
            this;
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)),
            this;
        },
        clampScalar: function() {
            var min = new Vector2(), max = new Vector2();
            return function(minVal, maxVal) {
                return min.set(minVal, minVal), max.set(maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        angle: function() {
            var angle = Math.atan2(this.y, this.x);
            return angle < 0 && (angle += 2 * Math.PI), angle;
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        manhattanDistanceTo: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1],
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x,
            array[offset + 1] = this.y, array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = attribute.getX(index), this.y = attribute.getY(index), this;
        },
        rotateAround: function(center, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), x = this.x - center.x, y = this.y - center.y;
            return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this;
        }
    }), Object.assign(Matrix4.prototype, {
        isMatrix4: !0,
        set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            return te[0] = n11, te[4] = n12, te[8] = n13, te[12] = n14, te[1] = n21, te[5] = n22,
            te[9] = n23, te[13] = n24, te[2] = n31, te[6] = n32, te[10] = n33, te[14] = n34,
            te[3] = n41, te[7] = n42, te[11] = n43, te[15] = n44, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements, me = m.elements;
            return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4],
            te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], te[9] = me[9], te[10] = me[10],
            te[11] = me[11], te[12] = me[12], te[13] = me[13], te[14] = me[14], te[15] = me[15],
            this;
        },
        copyPosition: function(m) {
            var te = this.elements, me = m.elements;
            return te[12] = me[12], te[13] = me[13], te[14] = me[14], this;
        },
        extractBasis: function(xAxis, yAxis, zAxis) {
            return xAxis.setFromMatrixColumn(this, 0), yAxis.setFromMatrixColumn(this, 1), zAxis.setFromMatrixColumn(this, 2),
            this;
        },
        makeBasis: function(xAxis, yAxis, zAxis) {
            return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1),
            this;
        },
        extractRotation: function() {
            var v1 = new Vector3();
            return function(m) {
                var te = this.elements, me = m.elements, scaleX = 1 / v1.setFromMatrixColumn(m, 0).length(), scaleY = 1 / v1.setFromMatrixColumn(m, 1).length(), scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                return te[0] = me[0] * scaleX, te[1] = me[1] * scaleX, te[2] = me[2] * scaleX, te[4] = me[4] * scaleY,
                te[5] = me[5] * scaleY, te[6] = me[6] * scaleY, te[8] = me[8] * scaleZ, te[9] = me[9] * scaleZ,
                te[10] = me[10] * scaleZ, this;
            };
        }(),
        makeRotationFromEuler: function(euler) {
            euler && euler.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var te = this.elements, x = euler.x, y = euler.y, z = euler.z, a = Math.cos(x), b = Math.sin(x), c = Math.cos(y), d = Math.sin(y), e = Math.cos(z), f = Math.sin(z);
            if ("XYZ" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = -c * f, te[8] = d, te[1] = af + be * d, te[5] = ae - bf * d,
                te[9] = -b * c, te[2] = bf - ae * d, te[6] = be + af * d, te[10] = a * c;
            } else if ("YXZ" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b, te[4] = de * b - cf, te[8] = a * d, te[1] = a * f, te[5] = a * e,
                te[9] = -b, te[2] = cf * b - de, te[6] = df + ce * b, te[10] = a * c;
            } else if ("ZXY" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b, te[4] = -a * f, te[8] = de + cf * b, te[1] = cf + de * b, te[5] = a * e,
                te[9] = df - ce * b, te[2] = -a * d, te[6] = b, te[10] = a * c;
            } else if ("ZYX" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = be * d - af, te[8] = ae * d + bf, te[1] = c * f, te[5] = bf * d + ae,
                te[9] = af * d - be, te[2] = -d, te[6] = b * c, te[10] = a * c;
            } else if ("YZX" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = bd - ac * f, te[8] = bc * f + ad, te[1] = f, te[5] = a * e,
                te[9] = -b * e, te[2] = -d * e, te[6] = ad * f + bc, te[10] = ac - bd * f;
            } else if ("XZY" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = -f, te[8] = d * e, te[1] = ac * f + bd, te[5] = a * e, te[9] = ad * f - bc,
                te[2] = bc * f - ad, te[6] = b * e, te[10] = bd * f + ac;
            }
            return te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1,
            this;
        },
        makeRotationFromQuaternion: function(q) {
            var te = this.elements, x = q._x, y = q._y, z = q._z, w = q._w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return te[0] = 1 - (yy + zz), te[4] = xy - wz, te[8] = xz + wy, te[1] = xy + wz,
            te[5] = 1 - (xx + zz), te[9] = yz - wx, te[2] = xz - wy, te[6] = yz + wx, te[10] = 1 - (xx + yy),
            te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1,
            this;
        },
        lookAt: function() {
            var x = new Vector3(), y = new Vector3(), z = new Vector3();
            return function(eye, target, up) {
                var te = this.elements;
                return z.subVectors(eye, target), 0 === z.lengthSq() && (z.z = 1), z.normalize(),
                x.crossVectors(up, z), 0 === x.lengthSq() && (1 === Math.abs(up.z) ? z.x += 1e-4 : z.z += 1e-4,
                z.normalize(), x.crossVectors(up, z)), x.normalize(), y.crossVectors(z, x), te[0] = x.x,
                te[4] = y.x, te[8] = z.x, te[1] = x.y, te[5] = y.y, te[9] = z.y, te[2] = x.z, te[6] = y.z,
                te[10] = z.z, this;
            };
        }(),
        multiply: function(m, n) {
            return void 0 !== n ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(m, n)) : this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12], a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13], a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14], a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15], b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12], b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13], b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14], b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42,
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44,
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42,
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44,
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42,
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44,
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42,
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44,
            this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[4] *= s, te[8] *= s, te[12] *= s, te[1] *= s, te[5] *= s,
            te[9] *= s, te[13] *= s, te[2] *= s, te[6] *= s, te[10] *= s, te[14] *= s, te[3] *= s,
            te[7] *= s, te[11] *= s, te[15] *= s, this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) v1.x = attribute.getX(i), v1.y = attribute.getY(i),
                v1.z = attribute.getZ(i), v1.applyMatrix4(this), attribute.setXYZ(i, v1.x, v1.y, v1.z);
                return attribute;
            };
        }(),
        determinant: function() {
            var te = this.elements, n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12], n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13], n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            return te[3] * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + te[7] * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + te[11] * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + te[15] * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        },
        transpose: function() {
            var tmp, te = this.elements;
            return tmp = te[1], te[1] = te[4], te[4] = tmp, tmp = te[2], te[2] = te[8], te[8] = tmp,
            tmp = te[6], te[6] = te[9], te[9] = tmp, tmp = te[3], te[3] = te[12], te[12] = tmp,
            tmp = te[7], te[7] = te[13], te[13] = tmp, tmp = te[11], te[11] = te[14], te[14] = tmp,
            this;
        },
        setPosition: function(v) {
            var te = this.elements;
            return te[12] = v.x, te[13] = v.y, te[14] = v.z, this;
        },
        getInverse: function(m, throwOnDegenerate) {
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34, det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (0 === det) {
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === throwOnDegenerate) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv,
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv,
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv,
            te[4] = t12 * detInv, te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv,
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv,
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv,
            te[8] = t13 * detInv, te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv,
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv,
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv,
            te[12] = t14 * detInv, te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv,
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv,
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv,
            this;
        },
        scale: function(v) {
            var te = this.elements, x = v.x, y = v.y, z = v.z;
            return te[0] *= x, te[4] *= y, te[8] *= z, te[1] *= x, te[5] *= y, te[9] *= z, te[2] *= x,
            te[6] *= y, te[10] *= z, te[3] *= x, te[7] *= y, te[11] *= z, this;
        },
        getMaxScaleOnAxis: function() {
            var te = this.elements, scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2], scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6], scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function(x, y, z) {
            return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
        },
        makeRotationX: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationY: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationZ: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), t = 1 - c, x = axis.x, y = axis.y, z = axis.z, tx = t * x, ty = t * y;
            return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1),
            this;
        },
        makeScale: function(x, y, z) {
            return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
        },
        makeShear: function(x, y, z) {
            return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1), this;
        },
        compose: function(position, quaternion, scale) {
            return this.makeRotationFromQuaternion(quaternion), this.scale(scale), this.setPosition(position),
            this;
        },
        decompose: function() {
            var vector = new Vector3(), matrix = new Matrix4();
            return function(position, quaternion, scale) {
                var te = this.elements, sx = vector.set(te[0], te[1], te[2]).length(), sy = vector.set(te[4], te[5], te[6]).length(), sz = vector.set(te[8], te[9], te[10]).length();
                this.determinant() < 0 && (sx = -sx), position.x = te[12], position.y = te[13],
                position.z = te[14], matrix.copy(this);
                var invSX = 1 / sx, invSY = 1 / sy, invSZ = 1 / sz;
                return matrix.elements[0] *= invSX, matrix.elements[1] *= invSX, matrix.elements[2] *= invSX,
                matrix.elements[4] *= invSY, matrix.elements[5] *= invSY, matrix.elements[6] *= invSY,
                matrix.elements[8] *= invSZ, matrix.elements[9] *= invSZ, matrix.elements[10] *= invSZ,
                quaternion.setFromRotationMatrix(matrix), scale.x = sx, scale.y = sy, scale.z = sz,
                this;
            };
        }(),
        makePerspective: function(left, right, top, bottom, near, far) {
            void 0 === far && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var te = this.elements, x = 2 * near / (right - left), y = 2 * near / (top - bottom), a = (right + left) / (right - left), b = (top + bottom) / (top - bottom), c = -(far + near) / (far - near), d = -2 * far * near / (far - near);
            return te[0] = x, te[4] = 0, te[8] = a, te[12] = 0, te[1] = 0, te[5] = y, te[9] = b,
            te[13] = 0, te[2] = 0, te[6] = 0, te[10] = c, te[14] = d, te[3] = 0, te[7] = 0,
            te[11] = -1, te[15] = 0, this;
        },
        makeOrthographic: function(left, right, top, bottom, near, far) {
            var te = this.elements, w = 1 / (right - left), h = 1 / (top - bottom), p = 1 / (far - near), x = (right + left) * w, y = (top + bottom) * h, z = (far + near) * p;
            return te[0] = 2 * w, te[4] = 0, te[8] = 0, te[12] = -x, te[1] = 0, te[5] = 2 * h,
            te[9] = 0, te[13] = -y, te[2] = 0, te[6] = 0, te[10] = -2 * p, te[14] = -z, te[3] = 0,
            te[7] = 0, te[11] = 0, te[15] = 1, this;
        },
        equals: function(matrix) {
            for (var te = this.elements, me = matrix.elements, i = 0; i < 16; i++) if (te[i] !== me[i]) return !1;
            return !0;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; i < 16; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2],
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5],
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8],
            array[offset + 9] = te[9], array[offset + 10] = te[10], array[offset + 11] = te[11],
            array[offset + 12] = te[12], array[offset + 13] = te[13], array[offset + 14] = te[14],
            array[offset + 15] = te[15], array;
        }
    }), Object.assign(Quaternion, {
        slerp: function(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir,
                s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f, y0 *= f, z0 *= f, w0 *= f;
                }
            }
            dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
        }
    }), Object.defineProperties(Quaternion.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value, this.onChangeCallback();
            }
        },
        w: {
            get: function() {
                return this._w;
            },
            set: function(value) {
                this._w = value, this.onChangeCallback();
            }
        }
    }), Object.assign(Quaternion.prototype, {
        set: function(x, y, z, w) {
            return this._x = x, this._y = y, this._z = z, this._w = w, this.onChangeCallback(),
            this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(quaternion) {
            return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w,
            this.onChangeCallback(), this;
        },
        setFromEuler: function(euler, update) {
            if (!euler || !euler.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var x = euler._x, y = euler._y, z = euler._z, order = euler.order, cos = Math.cos, sin = Math.sin, c1 = cos(x / 2), c2 = cos(y / 2), c3 = cos(z / 2), s1 = sin(x / 2), s2 = sin(y / 2), s3 = sin(z / 2);
            return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3,
            this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3),
            !1 !== update && this.onChangeCallback(), this;
        },
        setFromAxisAngle: function(axis, angle) {
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle),
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m) {
            var s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
            return trace > 0 ? (s = .5 / Math.sqrt(trace + 1), this._w = .25 / s, this._x = (m32 - m23) * s,
            this._y = (m13 - m31) * s, this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33),
            this._w = (m32 - m23) / s, this._x = .25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33),
            this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = .25 * s, this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22),
            this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s,
            this._z = .25 * s), this.onChangeCallback(), this;
        },
        setFromUnitVectors: function() {
            var r, v1 = new Vector3();
            return function(vFrom, vTo) {
                return void 0 === v1 && (v1 = new Vector3()), r = vFrom.dot(vTo) + 1, r < 1e-6 ? (r = 0,
                Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo),
                this._x = v1.x, this._y = v1.y, this._z = v1.z, this._w = r, this.normalize();
            };
        }(),
        inverse: function() {
            return this.conjugate().normalize();
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
        },
        dot: function(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var l = this.length();
            return 0 === l ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l,
            this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l),
            this.onChangeCallback(), this;
        },
        multiply: function(q, p) {
            return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q);
        },
        premultiply: function(q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function(a, b) {
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w, qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz,
            this.onChangeCallback(), this;
        },
        slerp: function(qb, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w, cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0 ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z,
            cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1) return this._w = w,
            this._x = x, this._y = y, this._z = z, this;
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < .001) return this._w = .5 * (w + this._w), this._x = .5 * (x + this._x),
            this._y = .5 * (y + this._y), this._z = .5 * (z + this._z), this;
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta), ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB,
            this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB,
            this.onChangeCallback(), this;
        },
        equals: function(quaternion) {
            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this._x = array[offset], this._y = array[offset + 1],
            this._z = array[offset + 2], this._w = array[offset + 3], this.onChangeCallback(),
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x,
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w,
            array;
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(Vector3.prototype, {
        isVector3: !0,
        set: function(x, y, z) {
            return this.x = x, this.y = y, this.z = z, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
        },
        multiply: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(v, w)) : (this.x *= v.x, this.y *= v.y, this.z *= v.z, this);
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this.z *= scalar, this;
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
        },
        applyEuler: function() {
            var quaternion = new Quaternion();
            return function(euler) {
                return euler && euler.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),
        applyAxisAngle: function() {
            var quaternion = new Quaternion();
            return function(axis, angle) {
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),
        applyMatrix3: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z,
            this.z = e[2] * x + e[5] * y + e[8] * z, this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements, w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w,
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w, this;
        },
        applyQuaternion: function(q) {
            var x = this.x, y = this.y, z = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz,
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
        },
        project: function() {
            var matrix = new Matrix4();
            return function(camera) {
                return matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)),
                this.applyMatrix4(matrix);
            };
        }(),
        unproject: function() {
            var matrix = new Matrix4();
            return function(camera) {
                return matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)),
                this.applyMatrix4(matrix);
            };
        }(),
        transformDirection: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z,
            this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize();
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this.z /= v.z, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z),
            this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z),
            this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)),
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this;
        },
        clampScalar: function() {
            var min = new Vector3(), max = new Vector3();
            return function(minVal, maxVal) {
                return min.set(minVal, minVal, minVal), max.set(maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z),
            this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z),
            this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z),
            this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha,
            this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(v, w)) : this.crossVectors(this, v);
        },
        crossVectors: function(a, b) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx,
            this;
        },
        projectOnVector: function(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function() {
            var v1 = new Vector3();
            return function(planeNormal) {
                return v1.copy(this).projectOnVector(planeNormal), this.sub(v1);
            };
        }(),
        reflect: function() {
            var v1 = new Vector3();
            return function(normal) {
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),
        angleTo: function(v) {
            var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        manhattanDistanceTo: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            return this.x = sinPhiRadius * Math.sin(s.theta), this.y = Math.cos(s.phi) * s.radius,
            this.z = sinPhiRadius * Math.cos(s.theta), this;
        },
        setFromCylindrical: function(c) {
            return this.x = c.radius * Math.sin(c.theta), this.y = c.y, this.z = c.radius * Math.cos(c.theta),
            this;
        },
        setFromMatrixPosition: function(m) {
            var e = m.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this;
        },
        setFromMatrixScale: function(m) {
            var sx = this.setFromMatrixColumn(m, 0).length(), sy = this.setFromMatrixColumn(m, 1).length(), sz = this.setFromMatrixColumn(m, 2).length();
            return this.x = sx, this.y = sy, this.z = sz, this;
        },
        setFromMatrixColumn: function(m, index) {
            return this.fromArray(m.elements, 4 * index);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1],
            this.z = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x,
            array[offset + 1] = this.y, array[offset + 2] = this.z, array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index),
            this;
        }
    }), Object.assign(Matrix3.prototype, {
        isMatrix3: !0,
        set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            return te[0] = n11, te[1] = n21, te[2] = n31, te[3] = n12, te[4] = n22, te[5] = n32,
            te[6] = n13, te[7] = n23, te[8] = n33, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements, me = m.elements;
            return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4],
            te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], this;
        },
        setFromMatrix4: function(m) {
            var me = m.elements;
            return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]),
            this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) v1.x = attribute.getX(i), v1.y = attribute.getY(i),
                v1.z = attribute.getZ(i), v1.applyMatrix3(this), attribute.setXYZ(i, v1.x, v1.y, v1.z);
                return attribute;
            };
        }(),
        multiply: function(m) {
            return this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[3], a13 = ae[6], a21 = ae[1], a22 = ae[4], a23 = ae[7], a31 = ae[2], a32 = ae[5], a33 = ae[8], b11 = be[0], b12 = be[3], b13 = be[6], b21 = be[1], b22 = be[4], b23 = be[7], b31 = be[2], b32 = be[5], b33 = be[8];
            return te[0] = a11 * b11 + a12 * b21 + a13 * b31, te[3] = a11 * b12 + a12 * b22 + a13 * b32,
            te[6] = a11 * b13 + a12 * b23 + a13 * b33, te[1] = a21 * b11 + a22 * b21 + a23 * b31,
            te[4] = a21 * b12 + a22 * b22 + a23 * b32, te[7] = a21 * b13 + a22 * b23 + a23 * b33,
            te[2] = a31 * b11 + a32 * b21 + a33 * b31, te[5] = a31 * b12 + a32 * b22 + a33 * b32,
            te[8] = a31 * b13 + a32 * b23 + a33 * b33, this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[3] *= s, te[6] *= s, te[1] *= s, te[4] *= s, te[7] *= s, te[2] *= s,
            te[5] *= s, te[8] *= s, this;
        },
        determinant: function() {
            var te = this.elements, a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function(matrix, throwOnDegenerate) {
            matrix && matrix.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (0 === det) {
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === throwOnDegenerate) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n31 * n23 - n33 * n21) * detInv, te[2] = (n32 * n21 - n31 * n22) * detInv,
            te[3] = t12 * detInv, te[4] = (n33 * n11 - n31 * n13) * detInv, te[5] = (n31 * n12 - n32 * n11) * detInv,
            te[6] = t13 * detInv, te[7] = (n21 * n13 - n23 * n11) * detInv, te[8] = (n22 * n11 - n21 * n12) * detInv,
            this;
        },
        transpose: function() {
            var tmp, m = this.elements;
            return tmp = m[1], m[1] = m[3], m[3] = tmp, tmp = m[2], m[2] = m[6], m[6] = tmp,
            tmp = m[5], m[5] = m[7], m[7] = tmp, this;
        },
        getNormalMatrix: function(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function(r) {
            var m = this.elements;
            return r[0] = m[0], r[1] = m[3], r[2] = m[6], r[3] = m[1], r[4] = m[4], r[5] = m[7],
            r[6] = m[2], r[7] = m[5], r[8] = m[8], this;
        },
        setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation), s = Math.sin(rotation);
            this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        },
        scale: function(sx, sy) {
            var te = this.elements;
            return te[0] *= sx, te[3] *= sx, te[6] *= sx, te[1] *= sy, te[4] *= sy, te[7] *= sy,
            this;
        },
        rotate: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta), te = this.elements, a11 = te[0], a12 = te[3], a13 = te[6], a21 = te[1], a22 = te[4], a23 = te[7];
            return te[0] = c * a11 + s * a21, te[3] = c * a12 + s * a22, te[6] = c * a13 + s * a23,
            te[1] = -s * a11 + c * a21, te[4] = -s * a12 + c * a22, te[7] = -s * a13 + c * a23,
            this;
        },
        translate: function(tx, ty) {
            var te = this.elements;
            return te[0] += tx * te[2], te[3] += tx * te[5], te[6] += tx * te[8], te[1] += ty * te[2],
            te[4] += ty * te[5], te[7] += ty * te[8], this;
        },
        equals: function(matrix) {
            for (var te = this.elements, me = matrix.elements, i = 0; i < 9; i++) if (te[i] !== me[i]) return !1;
            return !0;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; i < 9; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2],
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5],
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8],
            array;
        }
    });
    var textureId = 0;
    Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = UVMapping, Object.defineProperty(Texture.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(Texture.prototype, EventDispatcher.prototype, {
        constructor: Texture,
        isTexture: !0,
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.name = source.name, this.image = source.image, this.mipmaps = source.mipmaps.slice(0),
            this.mapping = source.mapping, this.wrapS = source.wrapS, this.wrapT = source.wrapT,
            this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy,
            this.format = source.format, this.type = source.type, this.offset.copy(source.offset),
            this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation,
            this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix),
            this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha,
            this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.encoding = source.encoding,
            this;
        },
        toJSON: function(meta) {
            var isRootObject = void 0 === meta || "string" == typeof meta;
            if (!isRootObject && void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
            var output = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                center: [ this.center.x, this.center.y ],
                rotation: this.rotation,
                wrap: [ this.wrapS, this.wrapT ],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var image = this.image;
                void 0 === image.uuid && (image.uuid = _Math.generateUUID()), isRootObject || void 0 !== meta.images[image.uuid] || (meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: function(image) {
                        var canvas;
                        if (image instanceof HTMLCanvasElement) canvas = image; else {
                            canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), canvas.width = image.width,
                            canvas.height = image.height;
                            var context = canvas.getContext("2d");
                            image instanceof ImageData ? context.putImageData(image, 0, 0) : context.drawImage(image, 0, 0, image.width, image.height);
                        }
                        return canvas.width > 2048 || canvas.height > 2048 ? canvas.toDataURL("image/jpeg", .6) : canvas.toDataURL("image/png");
                    }(image)
                }), output.image = image.uuid;
            }
            return isRootObject || (meta.textures[this.uuid] = output), output;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        },
        transformUv: function(uv) {
            if (this.mapping === UVMapping) {
                if (uv.applyMatrix3(this.matrix), uv.x < 0 || uv.x > 1) switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;

                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.x) % 2) ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x);
                }
                if (uv.y < 0 || uv.y > 1) switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;

                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.y) % 2) ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y);
                }
                this.flipY && (uv.y = 1 - uv.y);
            }
        }
    }), Object.assign(Vector4.prototype, {
        isVector4: !0,
        set: function(x, y, z, w) {
            return this.x = x, this.y = y, this.z = z, this.w = w, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setW: function(w) {
            return this.w = w, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              case 3:
                this.w = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              case 3:
                return this.w;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this.w = void 0 !== v.w ? v.w : 1,
            this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this.w += v.w,
            this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this.w += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w,
            this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this.w += v.w * s,
            this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this.w -= v.w,
            this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w,
            this;
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this.z *= scalar, this.w *= scalar, this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w, this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w,
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w, this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w,
            this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function(q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s,
            this.z = q.z / s), this;
        },
        setAxisAngleFromRotationMatrix: function(m) {
            var angle, x, y, z, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if (Math.abs(m12 - m21) < .01 && Math.abs(m13 - m31) < .01 && Math.abs(m23 - m32) < .01) {
                if (Math.abs(m12 + m21) < .1 && Math.abs(m13 + m31) < .1 && Math.abs(m23 + m32) < .1 && Math.abs(m11 + m22 + m33 - 3) < .1) return this.set(1, 0, 0, 0),
                this;
                angle = Math.PI;
                var xx = (m11 + 1) / 2, yy = (m22 + 1) / 2, zz = (m33 + 1) / 2, xy = (m12 + m21) / 4, xz = (m13 + m31) / 4, yz = (m23 + m32) / 4;
                return xx > yy && xx > zz ? xx < .01 ? (x = 0, y = .707106781, z = .707106781) : (x = Math.sqrt(xx),
                y = xy / x, z = xz / x) : yy > zz ? yy < .01 ? (x = .707106781, y = 0, z = .707106781) : (y = Math.sqrt(yy),
                x = xy / y, z = yz / y) : zz < .01 ? (x = .707106781, y = .707106781, z = 0) : (z = Math.sqrt(zz),
                x = xz / z, y = yz / z), this.set(x, y, z, angle), this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
            return Math.abs(s) < .001 && (s = 1), this.x = (m32 - m23) / s, this.y = (m13 - m31) / s,
            this.z = (m21 - m12) / s, this.w = Math.acos((m11 + m22 + m33 - 1) / 2), this;
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z),
            this.w = Math.min(this.w, v.w), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z),
            this.w = Math.max(this.w, v.w), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)),
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this.w = Math.max(min.w, Math.min(max.w, this.w)),
            this;
        },
        clampScalar: function() {
            var min, max;
            return function(minVal, maxVal) {
                return void 0 === min && (min = new Vector4(), max = new Vector4()), min.set(minVal, minVal, minVal, minVal),
                max.set(maxVal, maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z),
            this.w = Math.floor(this.w), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z),
            this.w = Math.round(this.w), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha,
            this.w += (v.w - this.w) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1],
            this.z = array[offset + 2], this.w = array[offset + 3], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x,
            array[offset + 1] = this.y, array[offset + 2] = this.z, array[offset + 3] = this.w,
            array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index),
            this.w = attribute.getW(index), this;
        }
    }), Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function(width, height) {
            this.width === width && this.height === height || (this.width = width, this.height = height,
            this.dispose()), this.viewport.set(0, 0, width, height), this.scissor.set(0, 0, width, height);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.width = source.width, this.height = source.height, this.viewport.copy(source.viewport),
            this.texture = source.texture.clone(), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer,
            this.depthTexture = source.depthTexture, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype),
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube, WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = !0,
    DataTexture.prototype = Object.create(Texture.prototype), DataTexture.prototype.constructor = DataTexture,
    DataTexture.prototype.isDataTexture = !0, CubeTexture.prototype = Object.create(Texture.prototype),
    CubeTexture.prototype.constructor = CubeTexture, CubeTexture.prototype.isCubeTexture = !0,
    Object.defineProperty(CubeTexture.prototype, "images", {
        get: function() {
            return this.image;
        },
        set: function(value) {
            this.image = value;
        }
    });
    var emptyTexture = new Texture(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9);
    StructuredUniform.prototype.setValue = function(gl, value) {
        for (var seq = this.seq, i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    WebGLUniforms.prototype.setValue = function(gl, name, value) {
        var u = this.map[name];
        void 0 !== u && u.setValue(gl, value, this.renderer);
    }, WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        void 0 !== v && this.setValue(gl, name, v);
    }, WebGLUniforms.upload = function(gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i], v = values[u.id];
            !1 !== v.needsUpdate && u.setValue(gl, v.value, renderer);
        }
    }, WebGLUniforms.seqWithValue = function(seq, values) {
        for (var r = [], i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.id in values && r.push(u);
        }
        return r;
    };
    var ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(Color.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(value) {
            return value && value.isColor ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value),
            this;
        },
        setScalar: function(scalar) {
            return this.r = scalar, this.g = scalar, this.b = scalar, this;
        },
        setHex: function(hex) {
            return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255,
            this.b = (255 & hex) / 255, this;
        },
        setRGB: function(r, g, b) {
            return this.r = r, this.g = g, this.b = b, this;
        },
        setHSL: function() {
            function hue2rgb(p, q, t) {
                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p;
            }
            return function(h, s, l) {
                if (h = _Math.euclideanModulo(h, 1), s = _Math.clamp(s, 0, 1), l = _Math.clamp(l, 0, 1),
                0 === s) this.r = this.g = this.b = l; else {
                    var p = l <= .5 ? l * (1 + s) : l + s - l * s, q = 2 * l - p;
                    this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            };
        }(),
        setStyle: function(style) {
            function handleAlpha(string) {
                void 0 !== string && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color, name = m[1], components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(255, parseInt(color[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(color[2], 10)) / 255, this.b = Math.min(255, parseInt(color[3], 10)) / 255,
                    handleAlpha(color[5]), this;
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(100, parseInt(color[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(color[2], 10)) / 100, this.b = Math.min(100, parseInt(color[3], 10)) / 100,
                    handleAlpha(color[5]), this;
                    break;

                  case "hsl":
                  case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        var h = parseFloat(color[1]) / 360, s = parseInt(color[2], 10) / 100, l = parseInt(color[3], 10) / 100;
                        return handleAlpha(color[5]), this.setHSL(h, s, l);
                    }
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1], size = hex.length;
                if (3 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255,
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255, this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255,
                this;
                if (6 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255,
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255, this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255,
                this;
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + style);
            }
            return this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(color) {
            return this.r = color.r, this.g = color.g, this.b = color.b, this;
        },
        copyGammaToLinear: function(color, gammaFactor) {
            return void 0 === gammaFactor && (gammaFactor = 2), this.r = Math.pow(color.r, gammaFactor),
            this.g = Math.pow(color.g, gammaFactor), this.b = Math.pow(color.b, gammaFactor),
            this;
        },
        copyLinearToGamma: function(color, gammaFactor) {
            void 0 === gammaFactor && (gammaFactor = 2);
            var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
            return this.r = Math.pow(color.r, safeInverse), this.g = Math.pow(color.g, safeInverse),
            this.b = Math.pow(color.b, safeInverse), this;
        },
        convertGammaToLinear: function() {
            var r = this.r, g = this.g, b = this.b;
            return this.r = r * r, this.g = g * g, this.b = b * b, this;
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b),
            this;
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(optionalTarget) {
            var hue, saturation, hsl = optionalTarget || {
                h: 0,
                s: 0,
                l: 0
            }, r = this.r, g = this.g, b = this.b, max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
            if (min === max) hue = 0, saturation = 0; else {
                var delta = max - min;
                switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min),
                max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;

                  case g:
                    hue = (b - r) / delta + 2;
                    break;

                  case b:
                    hue = (r - g) / delta + 4;
                }
                hue /= 6;
            }
            return hsl.h = hue, hsl.s = saturation, hsl.l = lightness, hsl;
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        },
        offsetHSL: function(h, s, l) {
            var hsl = this.getHSL();
            return hsl.h += h, hsl.s += s, hsl.l += l, this.setHSL(hsl.h, hsl.s, hsl.l), this;
        },
        add: function(color) {
            return this.r += color.r, this.g += color.g, this.b += color.b, this;
        },
        addColors: function(color1, color2) {
            return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b,
            this;
        },
        addScalar: function(s) {
            return this.r += s, this.g += s, this.b += s, this;
        },
        sub: function(color) {
            return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g),
            this.b = Math.max(0, this.b - color.b), this;
        },
        multiply: function(color) {
            return this.r *= color.r, this.g *= color.g, this.b *= color.b, this;
        },
        multiplyScalar: function(s) {
            return this.r *= s, this.g *= s, this.b *= s, this;
        },
        lerp: function(color, alpha) {
            return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha,
            this.b += (color.b - this.b) * alpha, this;
        },
        equals: function(c) {
            return c.r === this.r && c.g === this.g && c.b === this.b;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.r = array[offset], this.g = array[offset + 1],
            this.b = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.r,
            array[offset + 1] = this.g, array[offset + 2] = this.b, array;
        },
        toJSON: function() {
            return this.getHex();
        }
    });
    var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            }
        }
    }, UniformsUtils = {
        merge: function(uniforms) {
            for (var merged = {}, u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) merged[p] = tmp[p];
            }
            return merged;
        },
        clone: function(uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture) ? uniforms_dst[u][p] = parameter_src.clone() : Array.isArray(parameter_src) ? uniforms_dst[u][p] = parameter_src.slice() : uniforms_dst[u][p] = parameter_src;
                }
            }
            return uniforms_dst;
        }
    }, ShaderChunk = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
    }, ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog ]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                }
            } ]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            } ]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([ UniformsLib.points, UniformsLib.fog ]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap ]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap, {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            } ]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: UniformsUtils.merge([ UniformsLib.lights, UniformsLib.fog, {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        } ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    }, Object.assign(Box2.prototype, {
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector2();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize),
                this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function(point, optionalTarget) {
            return (optionalTarget || new Vector2()).set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y);
        },
        clampPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector2()).copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector2();
            return function(point) {
                return v1.copy(point).clamp(this.min, this.max).sub(point).length();
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }), CanvasTexture.prototype = Object.create(Texture.prototype), CanvasTexture.prototype.constructor = CanvasTexture;
    var materialId = 0;
    Object.assign(Material.prototype, EventDispatcher.prototype, {
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(values) {
            if (void 0 !== values) for (var key in values) {
                var newValue = values[key];
                if (void 0 !== newValue) if ("shading" !== key) {
                    var currentValue = this[key];
                    void 0 !== currentValue ? currentValue && currentValue.isColor ? currentValue.set(newValue) : currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ? currentValue.copy(newValue) : this[key] = "overdraw" === key ? Number(newValue) : newValue : console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = newValue === FlatShading; else console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            }
        },
        toJSON: function(meta) {
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRoot = void 0 === meta || "string" == typeof meta;
            isRoot && (meta = {
                textures: {},
                images: {}
            });
            var data = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name),
            this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness),
            void 0 !== this.metalness && (data.metalness = this.metalness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (data.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (data.specular = this.specular.getHex()),
            void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearCoat && (data.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (data.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid),
            this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid),
            this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid,
            data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid,
            data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid,
            data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid),
            this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid),
            this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid,
            data.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid),
            void 0 !== this.size && (data.size = this.size), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation),
            this.blending !== NormalBlending && (data.blending = this.blending), !0 === this.flatShading && (data.flatShading = this.flatShading),
            this.side !== FrontSide && (data.side = this.side), this.vertexColors !== NoColors && (data.vertexColors = this.vertexColors),
            this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = this.transparent),
            data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite,
            0 !== this.rotation && (data.rotation = this.rotation), 1 !== this.linewidth && (data.linewidth = this.linewidth),
            void 0 !== this.dashSize && (data.dashSize = this.dashSize), void 0 !== this.gapSize && (data.gapSize = this.gapSize),
            void 0 !== this.scale && (data.scale = this.scale), !0 === this.dithering && (data.dithering = !0),
            this.alphaTest > 0 && (data.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (data.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (data.morphTargets = !0), !0 === this.skinning && (data.skinning = !0),
            !1 === this.visible && (data.visible = !1), "{}" !== JSON.stringify(this.userData) && (data.userData = this.userData),
            isRoot) {
                var textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                textures.length > 0 && (data.textures = textures), images.length > 0 && (data.images = images);
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name, this.fog = source.fog, this.lights = source.lights, this.blending = source.blending,
            this.side = source.side, this.flatShading = source.flatShading, this.vertexColors = source.vertexColors,
            this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc,
            this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha,
            this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha,
            this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite,
            this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset,
            this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits,
            this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.premultipliedAlpha = source.premultipliedAlpha,
            this.overdraw = source.overdraw, this.visible = source.visible, this.userData = JSON.parse(JSON.stringify(source.userData)),
            this.clipShadows = source.clipShadows, this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (null !== srcPlanes) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
            }
            return this.clippingPlanes = dstPlanes, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), MeshDepthMaterial.prototype = Object.create(Material.prototype), MeshDepthMaterial.prototype.constructor = MeshDepthMaterial,
    MeshDepthMaterial.prototype.isMeshDepthMaterial = !0, MeshDepthMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.depthPacking = source.depthPacking,
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.map = source.map,
        this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap,
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias,
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth,
        this;
    }, MeshDistanceMaterial.prototype = Object.create(Material.prototype), MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial,
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0, MeshDistanceMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.referencePosition.copy(source.referencePosition),
        this.nearDistance = source.nearDistance, this.farDistance = source.farDistance,
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.map = source.map,
        this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap,
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias,
        this;
    }, Object.assign(Box3.prototype, {
        isBox3: !0,
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromArray: function(array) {
            for (var minX = 1 / 0, minY = 1 / 0, minZ = 1 / 0, maxX = -1 / 0, maxY = -1 / 0, maxZ = -1 / 0, i = 0, l = array.length; i < l; i += 3) {
                var x = array[i], y = array[i + 1], z = array[i + 2];
                x < minX && (minX = x), y < minY && (minY = y), z < minZ && (minZ = z), x > maxX && (maxX = x),
                y > maxY && (maxY = y), z > maxZ && (maxZ = z);
            }
            return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
        },
        setFromBufferAttribute: function(attribute) {
            for (var minX = 1 / 0, minY = 1 / 0, minZ = 1 / 0, maxX = -1 / 0, maxY = -1 / 0, maxZ = -1 / 0, i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i), y = attribute.getY(i), z = attribute.getZ(i);
                x < minX && (minX = x), y < minY && (minY = y), z < minZ && (minZ = z), x > maxX && (maxX = x),
                y > maxY && (maxY = y), z > maxZ && (maxZ = z);
            }
            return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector3();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize),
                this;
            };
        }(),
        setFromObject: function(object) {
            return this.makeEmpty(), this.expandByObject(object);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0,
            this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        expandByObject: function() {
            function traverse(node) {
                var geometry = node.geometry;
                if (void 0 !== geometry) if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    for (i = 0, l = vertices.length; i < l; i++) v1.copy(vertices[i]), v1.applyMatrix4(node.matrixWorld),
                    scope.expandByPoint(v1);
                } else if (geometry.isBufferGeometry) {
                    var attribute = geometry.attributes.position;
                    if (void 0 !== attribute) for (i = 0, l = attribute.count; i < l; i++) v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld),
                    scope.expandByPoint(v1);
                }
            }
            var scope, i, l, v1 = new Vector3();
            return function(object) {
                return scope = this, object.updateMatrixWorld(!0), object.traverse(traverse), this;
            };
        }(),
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z);
        },
        intersectsSphere: function() {
            var closestPoint = new Vector3();
            return function(sphere) {
                return this.clampPoint(sphere.center, closestPoint), closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            };
        }(),
        intersectsPlane: function(plane) {
            var min, max;
            return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x, max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x,
            max = plane.normal.x * this.min.x), plane.normal.y > 0 ? (min += plane.normal.y * this.min.y,
            max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y, max += plane.normal.y * this.min.y),
            plane.normal.z > 0 ? (min += plane.normal.z * this.min.z, max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z,
            max += plane.normal.z * this.min.z), min <= plane.constant && max >= plane.constant;
        },
        clampPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                return v1.copy(point).clamp(this.min, this.max).sub(point).length();
            };
        }(),
        getBoundingSphere: function() {
            var v1 = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Sphere();
                return this.getCenter(result.center), result.radius = .5 * this.getSize(v1).length(),
                result;
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(),
            this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        applyMatrix4: function() {
            var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ];
            return function(matrix) {
                return this.isEmpty() ? this : (points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix),
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix), points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix),
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix), points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix),
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix), points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix),
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix), this.setFromPoints(points),
                this);
            };
        }(),
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }), Object.assign(Sphere.prototype, {
        set: function(center, radius) {
            return this.center.copy(center), this.radius = radius, this;
        },
        setFromPoints: function() {
            var box = new Box3();
            return function(points, optionalCenter) {
                var center = this.center;
                void 0 !== optionalCenter ? center.copy(optionalCenter) : box.setFromPoints(points).getCenter(center);
                for (var maxRadiusSq = 0, i = 0, il = points.length; i < il; i++) maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                return this.radius = Math.sqrt(maxRadiusSq), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(sphere) {
            return this.center.copy(sphere.center), this.radius = sphere.radius, this;
        },
        empty: function() {
            return this.radius <= 0;
        },
        containsPoint: function(point) {
            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function(point) {
            return point.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        },
        intersectsBox: function(box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function(point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point), result = optionalTarget || new Vector3();
            return result.copy(point), deltaLengthSq > this.radius * this.radius && (result.sub(this.center).normalize(),
            result.multiplyScalar(this.radius).add(this.center)), result;
        },
        getBoundingBox: function(optionalTarget) {
            var box = optionalTarget || new Box3();
            return box.set(this.center, this.center), box.expandByScalar(this.radius), box;
        },
        applyMatrix4: function(matrix) {
            return this.center.applyMatrix4(matrix), this.radius = this.radius * matrix.getMaxScaleOnAxis(),
            this;
        },
        translate: function(offset) {
            return this.center.add(offset), this;
        },
        equals: function(sphere) {
            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
    }), Object.assign(Plane.prototype, {
        set: function(normal, constant) {
            return this.normal.copy(normal), this.constant = constant, this;
        },
        setComponents: function(x, y, z, w) {
            return this.normal.set(x, y, z), this.constant = w, this;
        },
        setFromNormalAndCoplanarPoint: function(normal, point) {
            return this.normal.copy(normal), this.constant = -point.dot(this.normal), this;
        },
        setFromCoplanarPoints: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                return this.setFromNormalAndCoplanarPoint(normal, a), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(plane) {
            return this.normal.copy(plane.normal), this.constant = plane.constant, this;
        },
        normalize: function() {
            var inverseNormalLength = 1 / this.normal.length();
            return this.normal.multiplyScalar(inverseNormalLength), this.constant *= inverseNormalLength,
            this;
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this;
        },
        distanceToPoint: function(point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        },
        intersectLine: function() {
            var v1 = new Vector3();
            return function(line, optionalTarget) {
                var result = optionalTarget || new Vector3(), direction = line.delta(v1), denominator = this.normal.dot(direction);
                if (0 !== denominator) {
                    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                    if (!(t < 0 || t > 1)) return result.copy(direction).multiplyScalar(t).add(line.start);
                } else if (0 === this.distanceToPoint(line.start)) return result.copy(line.start);
            };
        }(),
        intersectsLine: function(line) {
            var startSign = this.distanceToPoint(line.start), endSign = this.distanceToPoint(line.end);
            return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        },
        intersectsBox: function(box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function(sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function(optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var v1 = new Vector3(), m1 = new Matrix3();
            return function(matrix, optionalNormalMatrix) {
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix), referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix), normal = this.normal.applyMatrix3(normalMatrix).normalize();
                return this.constant = -referencePoint.dot(normal), this;
            };
        }(),
        translate: function(offset) {
            return this.constant -= offset.dot(this.normal), this;
        },
        equals: function(plane) {
            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
    }), Object.assign(Frustum.prototype, {
        set: function(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            return planes[0].copy(p0), planes[1].copy(p1), planes[2].copy(p2), planes[3].copy(p3),
            planes[4].copy(p4), planes[5].copy(p5), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(frustum) {
            for (var planes = this.planes, i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
            return this;
        },
        setFromMatrix: function(m) {
            var planes = this.planes, me = m.elements, me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3], me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7], me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11], me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            return planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(),
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(),
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(),
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(),
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(),
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(),
            this;
        },
        intersectsObject: function() {
            var sphere = new Sphere();
            return function(object) {
                var geometry = object.geometry;
                return null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSprite: function() {
            var sphere = new Sphere();
            return function(sprite) {
                return sphere.center.set(0, 0, 0), sphere.radius = .7071067811865476, sphere.applyMatrix4(sprite.matrixWorld),
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSphere: function(sphere) {
            for (var planes = this.planes, center = sphere.center, negRadius = -sphere.radius, i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(center) < negRadius) return !1;
            }
            return !0;
        },
        intersectsBox: function() {
            var p1 = new Vector3(), p2 = new Vector3();
            return function(box) {
                for (var planes = this.planes, i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x, p2.x = plane.normal.x > 0 ? box.max.x : box.min.x,
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y, p2.y = plane.normal.y > 0 ? box.max.y : box.min.y,
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z, p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1), d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) return !1;
                }
                return !0;
            };
        }(),
        containsPoint: function(point) {
            for (var planes = this.planes, i = 0; i < 6; i++) if (planes[i].distanceToPoint(point) < 0) return !1;
            return !0;
        }
    }), Euler.RotationOrders = [ "XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX" ], Euler.DefaultOrder = "XYZ",
    Object.defineProperties(Euler.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value, this.onChangeCallback();
            }
        },
        order: {
            get: function() {
                return this._order;
            },
            set: function(value) {
                this._order = value, this.onChangeCallback();
            }
        }
    }), Object.assign(Euler.prototype, {
        isEuler: !0,
        set: function(x, y, z, order) {
            return this._x = x, this._y = y, this._z = z, this._order = order || this._order,
            this.onChangeCallback(), this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(euler) {
            return this._x = euler._x, this._y = euler._y, this._z = euler._z, this._order = euler._order,
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m, order, update) {
            var clamp = _Math.clamp, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            return order = order || this._order, "XYZ" === order ? (this._y = Math.asin(clamp(m13, -1, 1)),
            Math.abs(m13) < .99999 ? (this._x = Math.atan2(-m23, m33), this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22),
            this._z = 0)) : "YXZ" === order ? (this._x = Math.asin(-clamp(m23, -1, 1)), Math.abs(m23) < .99999 ? (this._y = Math.atan2(m13, m33),
            this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11), this._z = 0)) : "ZXY" === order ? (this._x = Math.asin(clamp(m32, -1, 1)),
            Math.abs(m32) < .99999 ? (this._y = Math.atan2(-m31, m33), this._z = Math.atan2(-m12, m22)) : (this._y = 0,
            this._z = Math.atan2(m21, m11))) : "ZYX" === order ? (this._y = Math.asin(-clamp(m31, -1, 1)),
            Math.abs(m31) < .99999 ? (this._x = Math.atan2(m32, m33), this._z = Math.atan2(m21, m11)) : (this._x = 0,
            this._z = Math.atan2(-m12, m22))) : "YZX" === order ? (this._z = Math.asin(clamp(m21, -1, 1)),
            Math.abs(m21) < .99999 ? (this._x = Math.atan2(-m23, m22), this._y = Math.atan2(-m31, m11)) : (this._x = 0,
            this._y = Math.atan2(m13, m33))) : "XZY" === order ? (this._z = Math.asin(-clamp(m12, -1, 1)),
            Math.abs(m12) < .99999 ? (this._x = Math.atan2(m32, m22), this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order),
            this._order = order, !1 !== update && this.onChangeCallback(), this;
        },
        setFromQuaternion: function() {
            var matrix = new Matrix4();
            return function(q, order, update) {
                return matrix.makeRotationFromQuaternion(q), this.setFromRotationMatrix(matrix, order, update);
            };
        }(),
        setFromVector3: function(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function() {
            var q = new Quaternion();
            return function(newOrder) {
                return q.setFromEuler(this), this.setFromQuaternion(q, newOrder);
            };
        }(),
        equals: function(euler) {
            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        },
        fromArray: function(array) {
            return this._x = array[0], this._y = array[1], this._z = array[2], void 0 !== array[3] && (this._order = array[3]),
            this.onChangeCallback(), this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x,
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._order,
            array;
        },
        toVector3: function(optionalResult) {
            return optionalResult ? optionalResult.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(Layers.prototype, {
        set: function(channel) {
            this.mask = 1 << channel | 0;
        },
        enable: function(channel) {
            this.mask |= 1 << channel | 0;
        },
        toggle: function(channel) {
            this.mask ^= 1 << channel | 0;
        },
        disable: function(channel) {
            this.mask &= ~(1 << channel | 0);
        },
        test: function(layers) {
            return 0 != (this.mask & layers.mask);
        }
    });
    var object3DId = 0;
    Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = !0,
    Object.assign(Object3D.prototype, EventDispatcher.prototype, {
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function(q) {
            return this.quaternion.premultiply(q), this;
        },
        setRotationFromAxisAngle: function(axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function(euler) {
            this.quaternion.setFromEuler(euler, !0);
        },
        setRotationFromMatrix: function(m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function(q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function() {
            var q1 = new Quaternion();
            return function(axis, angle) {
                return q1.setFromAxisAngle(axis, angle), this.quaternion.multiply(q1), this;
            };
        }(),
        rotateOnWorldAxis: function() {
            var q1 = new Quaternion();
            return function(axis, angle) {
                return q1.setFromAxisAngle(axis, angle), this.quaternion.premultiply(q1), this;
            };
        }(),
        rotateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        translateOnAxis: function() {
            var v1 = new Vector3();
            return function(axis, distance) {
                return v1.copy(axis).applyQuaternion(this.quaternion), this.position.add(v1.multiplyScalar(distance)),
                this;
            };
        }(),
        translateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        localToWorld: function(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var m1 = new Matrix4();
            return function(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var m1 = new Matrix4(), vector = new Vector3();
            return function(x, y, z) {
                x.isVector3 ? vector.copy(x) : vector.set(x, y, z), this.isCamera ? m1.lookAt(this.position, vector, this.up) : m1.lookAt(vector, this.position, this.up),
                this.quaternion.setFromRotationMatrix(m1);
            };
        }(),
        add: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
                return this;
            }
            return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object),
            this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object),
            object.parent = this, object.dispatchEvent({
                type: "added"
            }), this.children.push(object)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object),
            this);
        },
        remove: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) this.remove(arguments[i]);
                return this;
            }
            var index = this.children.indexOf(object);
            return -1 !== index && (object.parent = null, object.dispatchEvent({
                type: "removed"
            }), this.children.splice(index, 1)), this;
        },
        getObjectById: function(id) {
            return this.getObjectByProperty("id", id);
        },
        getObjectByName: function(name) {
            return this.getObjectByProperty("name", name);
        },
        getObjectByProperty: function(name, value) {
            if (this[name] === value) return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i], object = child.getObjectByProperty(name, value);
                if (void 0 !== object) return object;
            }
        },
        getWorldPosition: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.updateMatrixWorld(!0), result.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var position = new Vector3(), scale = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, result, scale),
                result;
            };
        }(),
        getWorldRotation: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Euler();
                return this.getWorldQuaternion(quaternion), result.setFromQuaternion(quaternion, this.rotation.order, !1);
            };
        }(),
        getWorldScale: function() {
            var position = new Vector3(), quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, quaternion, result),
                result;
            };
        }(),
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.getWorldQuaternion(quaternion), result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),
        raycast: function() {},
        traverse: function(callback) {
            callback(this);
            for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].traverse(callback);
        },
        traverseVisible: function(callback) {
            if (!1 !== this.visible) {
                callback(this);
                for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function(callback) {
            var parent = this.parent;
            null !== parent && (callback(parent), parent.traverseAncestors(callback));
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        },
        updateMatrixWorld: function(force) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || force) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1, force = !0);
            for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].updateMatrixWorld(force);
        },
        toJSON: function(meta) {
            function serialize(library, element) {
                return void 0 === library[element.uuid] && (library[element.uuid] = element.toJSON(meta)),
                element.uuid;
            }
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRootObject = void 0 === meta || "string" == typeof meta, output = {};
            isRootObject && (meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, output.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var object = {};
            if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name),
            !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0),
            !1 === this.visible && (object.visible = !1), "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData),
            object.matrix = this.matrix.toArray(), void 0 !== this.geometry && (object.geometry = serialize(meta.geometries, this.geometry)),
            void 0 !== this.material) if (Array.isArray(this.material)) {
                for (var uuids = [], i = 0, l = this.material.length; i < l; i++) uuids.push(serialize(meta.materials, this.material[i]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object);
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries), materials = extractFromCache(meta.materials), textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                geometries.length > 0 && (output.geometries = geometries), materials.length > 0 && (output.materials = materials),
                textures.length > 0 && (output.textures = textures), images.length > 0 && (output.images = images);
            }
            return output.object = object, output;
        },
        clone: function(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function(source, recursive) {
            if (void 0 === recursive && (recursive = !0), this.name = source.name, this.up.copy(source.up),
            this.position.copy(source.position), this.quaternion.copy(source.quaternion), this.scale.copy(source.scale),
            this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask,
            this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow,
            this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder,
            this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === recursive) for (var i = 0; i < source.children.length; i++) {
                var child = source.children[i];
                this.add(child.clone());
            }
            return this;
        }
    }), Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Camera,
        isCamera: !0,
        copy: function(source, recursive) {
            return Object3D.prototype.copy.call(this, source, recursive), this.matrixWorldInverse.copy(source.matrixWorldInverse),
            this.projectionMatrix.copy(source.projectionMatrix), this;
        },
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.getWorldQuaternion(quaternion), result.set(0, 0, -1).applyQuaternion(quaternion);
            };
        }(),
        updateMatrixWorld: function(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force), this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }), OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: !0,
        copy: function(source, recursive) {
            return Camera.prototype.copy.call(this, source, recursive), this.left = source.left,
            this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near,
            this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view),
            this;
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight,
            this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height,
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var dx = (this.right - this.left) / (2 * this.zoom), dy = (this.top - this.bottom) / (2 * this.zoom), cx = (this.right + this.left) / 2, cy = (this.top + this.bottom) / 2, left = cx - dx, right = cx + dx, top = cy + dy, bottom = cy - dy;
            if (null !== this.view && this.view.enabled) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth), zoomH = this.zoom / (this.view.height / this.view.fullHeight), scaleW = (this.right - this.left) / this.view.width, scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW), right = left + scaleW * (this.view.width / zoomW),
                top -= scaleH * (this.view.offsetY / zoomH), bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right,
            data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near,
            data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)),
            data;
        }
    }), Object.assign(Face3.prototype, {
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.a = source.a, this.b = source.b, this.c = source.c, this.normal.copy(source.normal),
            this.color.copy(source.color), this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) this.vertexNormals[i] = source.vertexNormals[i].clone();
            for (var i = 0, il = source.vertexColors.length; i < il; i++) this.vertexColors[i] = source.vertexColors[i].clone();
            return this;
        }
    });
    var geometryId = 0;
    Object.assign(Geometry.prototype, EventDispatcher.prototype, {
        isGeometry: !0,
        applyMatrix: function(matrix) {
            for (var normalMatrix = new Matrix3().getNormalMatrix(matrix), i = 0, il = this.vertices.length; i < il; i++) {
                this.vertices[i].applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationX(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationY(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationZ(angle), this.applyMatrix(m1), this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeTranslation(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeScale(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function(vector) {
                obj.lookAt(vector), obj.updateMatrix(), this.applyMatrix(obj.matrix);
            };
        }(),
        fromBufferGeometry: function(geometry) {
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = void 0 !== normals ? [ tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone() ] : [], vertexColors = void 0 !== colors ? [ scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone() ] : [], face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face), void 0 !== uvs && scope.faceVertexUvs[0].push([ tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone() ]),
                void 0 !== uvs2 && scope.faceVertexUvs[1].push([ tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone() ]);
            }
            var scope = this, indices = null !== geometry.index ? geometry.index.array : void 0, attributes = geometry.attributes, positions = attributes.position.array, normals = void 0 !== attributes.normal ? attributes.normal.array : void 0, colors = void 0 !== attributes.color ? attributes.color.array : void 0, uvs = void 0 !== attributes.uv ? attributes.uv.array : void 0, uvs2 = void 0 !== attributes.uv2 ? attributes.uv2.array : void 0;
            void 0 !== uvs2 && (this.faceVertexUvs[1] = []);
            for (var tempNormals = [], tempUVs = [], tempUVs2 = [], i = 0, j = 0; i < positions.length; i += 3,
            j += 2) scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2])),
            void 0 !== normals && tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2])),
            void 0 !== colors && scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2])),
            void 0 !== uvs && tempUVs.push(new Vector2(uvs[j], uvs[j + 1])), void 0 !== uvs2 && tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
            var groups = geometry.groups;
            if (groups.length > 0) for (var i = 0; i < groups.length; i++) for (var group = groups[i], start = group.start, count = group.count, j = start, jl = start + count; j < jl; j += 3) void 0 !== indices ? addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex) : addFace(j, j + 1, j + 2, group.materialIndex); else if (void 0 !== indices) for (var i = 0; i < indices.length; i += 3) addFace(indices[i], indices[i + 1], indices[i + 2]); else for (var i = 0; i < positions.length / 3; i += 3) addFace(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()),
            null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
            this;
        },
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        normalize: function() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center, radius = this.boundingSphere.radius, s = 0 === radius ? 1 : 1 / radius, matrix = new Matrix4();
            return matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1),
            this.applyMatrix(matrix), this;
        },
        computeFaceNormals: function() {
            for (var cb = new Vector3(), ab = new Vector3(), f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f], vA = this.vertices[face.a], vB = this.vertices[face.b], vC = this.vertices[face.c];
                cb.subVectors(vC, vB), ab.subVectors(vA, vB), cb.cross(ab), cb.normalize(), face.normal.copy(cb);
            }
        },
        computeVertexNormals: function(areaWeighted) {
            void 0 === areaWeighted && (areaWeighted = !0);
            var v, vl, f, fl, face, vertices;
            for (vertices = new Array(this.vertices.length), v = 0, vl = this.vertices.length; v < vl; v++) vertices[v] = new Vector3();
            if (areaWeighted) {
                var vA, vB, vC, cb = new Vector3(), ab = new Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], vA = this.vertices[face.a],
                vB = this.vertices[face.b], vC = this.vertices[face.c], cb.subVectors(vC, vB), ab.subVectors(vA, vB),
                cb.cross(ab), vertices[face.a].add(cb), vertices[face.b].add(cb), vertices[face.c].add(cb);
            } else for (this.computeFaceNormals(), f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f],
            vertices[face.a].add(face.normal), vertices[face.b].add(face.normal), vertices[face.c].add(face.normal);
            for (v = 0, vl = this.vertices.length; v < vl; v++) vertices[v].normalize();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(vertices[face.a]), vertexNormals[1].copy(vertices[face.b]),
                vertexNormals[2].copy(vertices[face.c])) : (vertexNormals[0] = vertices[face.a].clone(),
                vertexNormals[1] = vertices[face.b].clone(), vertexNormals[2] = vertices[face.c].clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function() {
            var f, fl, face;
            for (this.computeFaceNormals(), f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(face.normal), vertexNormals[1].copy(face.normal),
                vertexNormals[2].copy(face.normal)) : (vertexNormals[0] = face.normal.clone(), vertexNormals[1] = face.normal.clone(),
                vertexNormals[2] = face.normal.clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function() {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; f < fl; f++) for (face = this.faces[f], face.__originalFaceNormal ? face.__originalFaceNormal.copy(face.normal) : face.__originalFaceNormal = face.normal.clone(),
            face.__originalVertexNormals || (face.__originalVertexNormals = []), i = 0, il = face.vertexNormals.length; i < il; i++) face.__originalVertexNormals[i] ? face.__originalVertexNormals[i].copy(face.vertexNormals[i]) : face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            var tmpGeo = new Geometry();
            for (tmpGeo.faces = this.faces, i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {}, this.morphNormals[i].faceNormals = [], this.morphNormals[i].vertexNormals = [];
                    var faceNormal, vertexNormals, dstNormalsFace = this.morphNormals[i].faceNormals, dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) faceNormal = new Vector3(), vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    }, dstNormalsFace.push(faceNormal), dstNormalsVertex.push(vertexNormals);
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices, tmpGeo.computeFaceNormals(), tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], faceNormal = morphNormals.faceNormals[f],
                vertexNormals = morphNormals.vertexNormals[f], faceNormal.copy(face.normal), vertexNormals.a.copy(face.vertexNormals[0]),
                vertexNormals.b.copy(face.vertexNormals[1]), vertexNormals.c.copy(face.vertexNormals[2]);
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], face.normal = face.__originalFaceNormal,
            face.vertexNormals = face.__originalVertexNormals;
        },
        computeLineDistances: function() {
            for (var d = 0, vertices = this.vertices, i = 0, il = vertices.length; i < il; i++) i > 0 && (d += vertices[i].distanceTo(vertices[i - 1])),
            this.lineDistances[i] = d;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(geometry, matrix, materialIndexOffset) {
            if (!geometry || !geometry.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            void 0 === materialIndexOffset && (materialIndexOffset = 0), void 0 !== matrix && (normalMatrix = new Matrix3().getNormalMatrix(matrix));
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i], vertexCopy = vertex.clone();
                void 0 !== matrix && vertexCopy.applyMatrix4(matrix), vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; i < il; i++) colors1.push(colors2[i].clone());
            for (i = 0, il = faces2.length; i < il; i++) {
                var faceCopy, normal, color, face = faces2[i], faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset),
                faceCopy.normal.copy(face.normal), void 0 !== normalMatrix && faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) normal = faceVertexNormals[j].clone(),
                void 0 !== normalMatrix && normal.applyMatrix3(normalMatrix).normalize(), faceCopy.vertexNormals.push(normal);
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) color = faceVertexColors[j],
                faceCopy.vertexColors.push(color.clone());
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset, faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (void 0 !== uv) {
                    for (var j = 0, jl = uv.length; j < jl; j++) uvCopy.push(uv[j].clone());
                    uvs1.push(uvCopy);
                }
            }
        },
        mergeMesh: function(mesh) {
            if (!mesh || !mesh.isMesh) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
            mesh.matrixAutoUpdate && mesh.updateMatrix(), this.merge(mesh.geometry, mesh.matrix);
        },
        mergeVertices: function() {
            var v, key, i, il, face, indices, j, jl, verticesMap = {}, unique = [], changes = [], precision = Math.pow(10, 4);
            for (i = 0, il = this.vertices.length; i < il; i++) v = this.vertices[i], key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision),
            void 0 === verticesMap[key] ? (verticesMap[key] = i, unique.push(this.vertices[i]),
            changes[i] = unique.length - 1) : changes[i] = changes[verticesMap[key]];
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i], face.a = changes[face.a], face.b = changes[face.b], face.c = changes[face.c],
                indices = [ face.a, face.b, face.c ];
                for (var n = 0; n < 3; n++) if (indices[n] === indices[(n + 1) % 3]) {
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                for (this.faces.splice(idx, 1), j = 0, jl = this.faceVertexUvs.length; j < jl; j++) this.faceVertexUvs[j].splice(idx, 1);
            }
            var diff = this.vertices.length - unique.length;
            return this.vertices = unique, diff;
        },
        setFromPoints: function(points) {
            this.vertices = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return this;
        },
        sortFacesByMaterialIndex: function() {
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            for (var faces = this.faces, length = faces.length, i = 0; i < length; i++) faces[i]._id = i;
            faces.sort(materialIndexSort);
            var newUvs1, newUvs2, uvs1 = this.faceVertexUvs[0], uvs2 = this.faceVertexUvs[1];
            uvs1 && uvs1.length === length && (newUvs1 = []), uvs2 && uvs2.length === length && (newUvs2 = []);
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                newUvs1 && newUvs1.push(uvs1[id]), newUvs2 && newUvs2.push(uvs2[id]);
            }
            newUvs1 && (this.faceVertexUvs[0] = newUvs1), newUvs2 && (this.faceVertexUvs[1] = newUvs2);
        },
        toJSON: function() {
            function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                return void 0 !== normalsHash[hash] ? normalsHash[hash] : (normalsHash[hash] = normals.length / 3,
                normals.push(normal.x, normal.y, normal.z), normalsHash[hash]);
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                return void 0 !== colorsHash[hash] ? colorsHash[hash] : (colorsHash[hash] = colors.length,
                colors.push(color.getHex()), colorsHash[hash]);
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                return void 0 !== uvsHash[hash] ? uvsHash[hash] : (uvsHash[hash] = uvs.length / 2,
                uvs.push(uv.x, uv.y), uvsHash[hash]);
            }
            var data = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name),
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            for (var vertices = [], i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            for (var faces = [], normals = [], normalsHash = {}, colors = [], colorsHash = {}, uvs = [], uvsHash = {}, i = 0; i < this.faces.length; i++) {
                var face = this.faces[i], hasFaceVertexUv = void 0 !== this.faceVertexUvs[0][i], hasFaceNormal = face.normal.length() > 0, hasFaceVertexNormal = face.vertexNormals.length > 0, hasFaceColor = 1 !== face.color.r || 1 !== face.color.g || 1 !== face.color.b, hasFaceVertexColor = face.vertexColors.length > 0, faceType = 0;
                if (faceType = setBit(faceType, 0, 0), faceType = setBit(faceType, 1, !0), faceType = setBit(faceType, 2, !1),
                faceType = setBit(faceType, 3, hasFaceVertexUv), faceType = setBit(faceType, 4, hasFaceNormal),
                faceType = setBit(faceType, 5, hasFaceVertexNormal), faceType = setBit(faceType, 6, hasFaceColor),
                faceType = setBit(faceType, 7, hasFaceVertexColor), faces.push(faceType), faces.push(face.a, face.b, face.c),
                faces.push(face.materialIndex), hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal && faces.push(getNormalIndex(face.normal)), hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor && faces.push(getColorIndex(face.color)), hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            return data.data = {}, data.data.vertices = vertices, data.data.normals = normals,
            colors.length > 0 && (data.data.colors = colors), uvs.length > 0 && (data.data.uvs = [ uvs ]),
            data.data.faces = faces, data;
        },
        clone: function() {
            return new Geometry().copy(this);
        },
        copy: function(source) {
            var i, il, j, jl, k, kl;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ],
            this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [],
            this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = source.name;
            var vertices = source.vertices;
            for (i = 0, il = vertices.length; i < il; i++) this.vertices.push(vertices[i].clone());
            var colors = source.colors;
            for (i = 0, il = colors.length; i < il; i++) this.colors.push(colors[i].clone());
            var faces = source.faces;
            for (i = 0, il = faces.length; i < il; i++) this.faces.push(faces[i].clone());
            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                for (void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []), j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j], uvsCopy = [];
                    for (k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            var morphTargets = source.morphTargets;
            for (i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                if (morphTarget.name = morphTargets[i].name, void 0 !== morphTargets[i].vertices) for (morphTarget.vertices = [],
                j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                if (void 0 !== morphTargets[i].normals) for (morphTarget.normals = [], j = 0, jl = morphTargets[i].normals.length; j < jl; j++) morphTarget.normals.push(morphTargets[i].normals[j].clone());
                this.morphTargets.push(morphTarget);
            }
            var morphNormals = source.morphNormals;
            for (i = 0, il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                if (void 0 !== morphNormals[i].vertexNormals) for (morphNormal.vertexNormals = [],
                j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                    var srcVertexNormal = morphNormals[i].vertexNormals[j], destVertexNormal = {};
                    destVertexNormal.a = srcVertexNormal.a.clone(), destVertexNormal.b = srcVertexNormal.b.clone(),
                    destVertexNormal.c = srcVertexNormal.c.clone(), morphNormal.vertexNormals.push(destVertexNormal);
                }
                if (void 0 !== morphNormals[i].faceNormals) for (morphNormal.faceNormals = [], j = 0,
                jl = morphNormals[i].faceNormals.length; j < jl; j++) morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                this.morphNormals.push(morphNormal);
            }
            var skinWeights = source.skinWeights;
            for (i = 0, il = skinWeights.length; i < il; i++) this.skinWeights.push(skinWeights[i].clone());
            var skinIndices = source.skinIndices;
            for (i = 0, il = skinIndices.length; i < il; i++) this.skinIndices.push(skinIndices[i].clone());
            var lineDistances = source.lineDistances;
            for (i = 0, il = lineDistances.length; i < il; i++) this.lineDistances.push(lineDistances[i]);
            var boundingBox = source.boundingBox;
            null !== boundingBox && (this.boundingBox = boundingBox.clone());
            var boundingSphere = source.boundingSphere;
            return null !== boundingSphere && (this.boundingSphere = boundingSphere.clone()),
            this.elementsNeedUpdate = source.elementsNeedUpdate, this.verticesNeedUpdate = source.verticesNeedUpdate,
            this.uvsNeedUpdate = source.uvsNeedUpdate, this.normalsNeedUpdate = source.normalsNeedUpdate,
            this.colorsNeedUpdate = source.colorsNeedUpdate, this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = source.groupsNeedUpdate, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(BufferAttribute.prototype, {
        isBufferAttribute: !0,
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.itemSize : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize,
            this.count = source.count, this.normalized = source.normalized, this.dynamic = source.dynamic,
            this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.itemSize, index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        copyArray: function(array) {
            return this.array.set(array), this;
        },
        copyColorsArray: function(colors) {
            for (var array = this.array, offset = 0, i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                void 0 === color && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                color = new Color()), array[offset++] = color.r, array[offset++] = color.g, array[offset++] = color.b;
            }
            return this;
        },
        copyIndicesArray: function(indices) {
            for (var array = this.array, offset = 0, i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a, array[offset++] = index.b, array[offset++] = index.c;
            }
            return this;
        },
        copyVector2sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                vector = new Vector2()), array[offset++] = vector.x, array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                vector = new Vector3()), array[offset++] = vector.x, array[offset++] = vector.y,
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                vector = new Vector4()), array[offset++] = vector.x, array[offset++] = vector.y,
                array[offset++] = vector.z, array[offset++] = vector.w;
            }
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        getX: function(index) {
            return this.array[index * this.itemSize];
        },
        setX: function(index, x) {
            return this.array[index * this.itemSize] = x, this;
        },
        getY: function(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function(index, y) {
            return this.array[index * this.itemSize + 1] = y, this;
        },
        getZ: function(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function(index, z) {
            return this.array[index * this.itemSize + 2] = z, this;
        },
        getW: function(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function(index, w) {
            return this.array[index * this.itemSize + 3] = w, this;
        },
        setXY: function(index, x, y) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y,
            this;
        },
        setXYZ: function(index, x, y, z) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y,
            this.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y,
            this.array[index + 2] = z, this.array[index + 3] = w, this;
        },
        onUpload: function(callback) {
            return this.onUploadCallback = callback, this;
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    }), Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int8BufferAttribute.prototype.constructor = Int8BufferAttribute,
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute,
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype),
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute,
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int16BufferAttribute.prototype.constructor = Int16BufferAttribute,
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute,
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int32BufferAttribute.prototype.constructor = Int32BufferAttribute,
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute,
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float32BufferAttribute.prototype.constructor = Float32BufferAttribute,
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float64BufferAttribute.prototype.constructor = Float64BufferAttribute,
    Object.assign(DirectGeometry.prototype, {
        computeGroups: function(geometry) {
            for (var group, groups = [], materialIndex = void 0, faces = geometry.faces, i = 0; i < faces.length; i++) {
                var face = faces[i];
                face.materialIndex !== materialIndex && (materialIndex = face.materialIndex, void 0 !== group && (group.count = 3 * i - group.start,
                groups.push(group)), group = {
                    start: 3 * i,
                    materialIndex: materialIndex
                });
            }
            void 0 !== group && (group.count = 3 * i - group.start, groups.push(group)), this.groups = groups;
        },
        fromGeometry: function(geometry) {
            var morphTargetsPosition, faces = geometry.faces, vertices = geometry.vertices, faceVertexUvs = geometry.faceVertexUvs, hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0, hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0, morphTargets = geometry.morphTargets, morphTargetsLength = morphTargets.length;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) morphTargetsPosition[i] = [];
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphTargetsNormal, morphNormals = geometry.morphNormals, morphNormalsLength = morphNormals.length;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) morphTargetsNormal[i] = [];
                this.morphTargets.normal = morphTargetsNormal;
            }
            for (var skinIndices = geometry.skinIndices, skinWeights = geometry.skinWeights, hasSkinIndices = skinIndices.length === vertices.length, hasSkinWeights = skinWeights.length === vertices.length, i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (3 === vertexNormals.length) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]); else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (3 === vertexColors.length) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]); else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (!0 === hasFaceVertexUv) {
                    var vertexUvs = faceVertexUvs[0][i];
                    void 0 !== vertexUvs ? this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i),
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
                }
                if (!0 === hasFaceVertexUv2) {
                    var vertexUvs = faceVertexUvs[1][i];
                    void 0 !== vertexUvs ? this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i),
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                hasSkinIndices && this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]),
                hasSkinWeights && this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
            return this.computeGroups(geometry), this.verticesNeedUpdate = geometry.verticesNeedUpdate,
            this.normalsNeedUpdate = geometry.normalsNeedUpdate, this.colorsNeedUpdate = geometry.colorsNeedUpdate,
            this.uvsNeedUpdate = geometry.uvsNeedUpdate, this.groupsNeedUpdate = geometry.groupsNeedUpdate,
            this;
        }
    });
    var bufferGeometryId = 1;
    Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(index) {
            Array.isArray(index) ? this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1) : this.index = index;
        },
        addAttribute: function(name, attribute) {
            return attribute && attribute.isBufferAttribute || attribute && attribute.isInterleavedBufferAttribute ? "index" === name ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            void this.setIndex(attribute)) : (this.attributes[name] = attribute, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            void this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2])));
        },
        getAttribute: function(name) {
            return this.attributes[name];
        },
        removeAttribute: function(name) {
            return delete this.attributes[name], this;
        },
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: void 0 !== materialIndex ? materialIndex : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(start, count) {
            this.drawRange.start = start, this.drawRange.count = count;
        },
        applyMatrix: function(matrix) {
            var position = this.attributes.position;
            void 0 !== position && (matrix.applyToBufferAttribute(position), position.needsUpdate = !0);
            var normal = this.attributes.normal;
            if (void 0 !== normal) {
                new Matrix3().getNormalMatrix(matrix).applyToBufferAttribute(normal), normal.needsUpdate = !0;
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(),
            this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationX(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationY(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationZ(angle), this.applyMatrix(m1), this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeTranslation(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeScale(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function(vector) {
                obj.lookAt(vector), obj.updateMatrix(), this.applyMatrix(obj.matrix);
            };
        }(),
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        setFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new Float32BufferAttribute(3 * geometry.vertices.length, 3), colors = new Float32BufferAttribute(3 * geometry.colors.length, 3);
                if (this.addAttribute("position", positions.copyVector3sArray(geometry.vertices)),
                this.addAttribute("color", colors.copyColorsArray(geometry.colors)), geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                    this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
                null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone());
            } else object.isMesh && geometry && geometry.isGeometry && this.fromGeometry(geometry);
            return this;
        },
        setFromPoints: function(points) {
            for (var position = [], i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                position.push(point.x, point.y, point.z || 0);
            }
            return this.addAttribute("position", new Float32BufferAttribute(position, 3)), this;
        },
        updateFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (!0 === geometry.elementsNeedUpdate && (direct = void 0, geometry.elementsNeedUpdate = !1),
                void 0 === direct) return this.fromGeometry(geometry);
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate, direct.normalsNeedUpdate = geometry.normalsNeedUpdate,
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate, direct.uvsNeedUpdate = geometry.uvsNeedUpdate,
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate, geometry.verticesNeedUpdate = !1,
                geometry.normalsNeedUpdate = !1, geometry.colorsNeedUpdate = !1, geometry.uvsNeedUpdate = !1,
                geometry.groupsNeedUpdate = !1, geometry = direct;
            }
            var attribute;
            return !0 === geometry.verticesNeedUpdate && (attribute = this.attributes.position,
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.vertices), attribute.needsUpdate = !0),
            geometry.verticesNeedUpdate = !1), !0 === geometry.normalsNeedUpdate && (attribute = this.attributes.normal,
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.normals), attribute.needsUpdate = !0),
            geometry.normalsNeedUpdate = !1), !0 === geometry.colorsNeedUpdate && (attribute = this.attributes.color,
            void 0 !== attribute && (attribute.copyColorsArray(geometry.colors), attribute.needsUpdate = !0),
            geometry.colorsNeedUpdate = !1), geometry.uvsNeedUpdate && (attribute = this.attributes.uv,
            void 0 !== attribute && (attribute.copyVector2sArray(geometry.uvs), attribute.needsUpdate = !0),
            geometry.uvsNeedUpdate = !1), geometry.lineDistancesNeedUpdate && (attribute = this.attributes.lineDistance,
            void 0 !== attribute && (attribute.copyArray(geometry.lineDistances), attribute.needsUpdate = !0),
            geometry.lineDistancesNeedUpdate = !1), geometry.groupsNeedUpdate && (geometry.computeGroups(object.geometry),
            this.groups = geometry.groups, geometry.groupsNeedUpdate = !1), this;
        },
        fromGeometry: function(geometry) {
            return geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry),
            this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function(geometry) {
            var positions = new Float32Array(3 * geometry.vertices.length);
            if (this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices)),
            geometry.normals.length > 0) {
                var normals = new Float32Array(3 * geometry.normals.length);
                this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(3 * geometry.colors.length);
                this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(2 * geometry.uvs.length);
                this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(2 * geometry.uvs2.length);
                this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array, indices = new TypeArray(3 * geometry.indices.length);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                for (var array = [], morphTargets = geometry.morphTargets[name], i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i], attribute = new Float32BufferAttribute(3 * morphTarget.length, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32BufferAttribute(4 * geometry.skinIndices.length, 4);
                this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32BufferAttribute(4 * geometry.skinWeights.length, 4);
                this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            return null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
            null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()),
            this;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3());
            var position = this.attributes.position;
            void 0 !== position ? this.boundingBox.setFromBufferAttribute(position) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        },
        computeBoundingSphere: function() {
            var box = new Box3(), vector = new Vector3();
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Sphere());
                var position = this.attributes.position;
                if (position) {
                    var center = this.boundingSphere.center;
                    box.setFromBufferAttribute(position), box.getCenter(center);
                    for (var maxRadiusSq = 0, i = 0, il = position.count; i < il; i++) vector.x = position.getX(i),
                    vector.y = position.getY(i), vector.z = position.getZ(i), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var index = this.index, attributes = this.attributes, groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (void 0 === attributes.normal) this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3)); else for (var array = attributes.normal.array, i = 0, il = array.length; i < il; i++) array[i] = 0;
                var vA, vB, vC, normals = attributes.normal.array, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    0 === groups.length && this.addGroup(0, indices.length);
                    for (var j = 0, jl = groups.length; j < jl; ++j) for (var group = groups[j], start = group.start, count = group.count, i = start, il = start + count; i < il; i += 3) vA = 3 * indices[i + 0],
                    vB = 3 * indices[i + 1], vC = 3 * indices[i + 2], pA.fromArray(positions, vA), pB.fromArray(positions, vB),
                    pC.fromArray(positions, vC), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab),
                    normals[vA] += cb.x, normals[vA + 1] += cb.y, normals[vA + 2] += cb.z, normals[vB] += cb.x,
                    normals[vB + 1] += cb.y, normals[vB + 2] += cb.z, normals[vC] += cb.x, normals[vC + 1] += cb.y,
                    normals[vC + 2] += cb.z;
                } else for (var i = 0, il = positions.length; i < il; i += 9) pA.fromArray(positions, i),
                pB.fromArray(positions, i + 3), pC.fromArray(positions, i + 6), cb.subVectors(pC, pB),
                ab.subVectors(pA, pB), cb.cross(ab), normals[i] = cb.x, normals[i + 1] = cb.y, normals[i + 2] = cb.z,
                normals[i + 3] = cb.x, normals[i + 4] = cb.y, normals[i + 5] = cb.z, normals[i + 6] = cb.x,
                normals[i + 7] = cb.y, normals[i + 8] = cb.z;
                this.normalizeNormals(), attributes.normal.needsUpdate = !0;
            }
        },
        merge: function(geometry, offset) {
            if (!geometry || !geometry.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            void 0 === offset && (offset = 0);
            var attributes = this.attributes;
            for (var key in attributes) if (void 0 !== geometry.attributes[key]) for (var attribute1 = attributes[key], attributeArray1 = attribute1.array, attribute2 = geometry.attributes[key], attributeArray2 = attribute2.array, attributeSize = attribute2.itemSize, i = 0, j = attributeSize * offset; i < attributeArray2.length; i++,
            j++) attributeArray1[j] = attributeArray2[i];
            return this;
        },
        normalizeNormals: function() {
            var vector = new Vector3();
            return function() {
                for (var normals = this.attributes.normal, i = 0, il = normals.count; i < il; i++) vector.x = normals.getX(i),
                vector.y = normals.getY(i), vector.z = normals.getZ(i), vector.normalize(), normals.setXYZ(i, vector.x, vector.y, vector.z);
            };
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
            this;
            var geometry2 = new BufferGeometry(), indices = this.index.array, attributes = this.attributes;
            for (var name in attributes) {
                for (var attribute = attributes[name], array = attribute.array, itemSize = attribute.itemSize, array2 = new array.constructor(indices.length * itemSize), index = 0, index2 = 0, i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) array2[index2++] = array[index++];
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            return geometry2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name),
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (null !== index) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
            var boundingSphere = this.boundingSphere;
            return null !== boundingSphere && (data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            }), data;
        },
        clone: function() {
            return new BufferGeometry().copy(this);
        },
        copy: function(source) {
            var name, i, l;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [],
            this.boundingBox = null, this.boundingSphere = null, this.name = source.name;
            var index = source.index;
            null !== index && this.setIndex(index.clone());
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [], morphAttribute = morphAttributes[name];
                for (i = 0, l = morphAttribute.length; i < l; i++) array.push(morphAttribute[i].clone());
                this.morphAttributes[name] = array;
            }
            var groups = source.groups;
            for (i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingBox = source.boundingBox;
            null !== boundingBox && (this.boundingBox = boundingBox.clone());
            var boundingSphere = source.boundingSphere;
            return null !== boundingSphere && (this.boundingSphere = boundingSphere.clone()),
            this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count,
            this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), BoxGeometry.prototype = Object.create(Geometry.prototype), BoxGeometry.prototype.constructor = BoxGeometry,
    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype), BoxBufferGeometry.prototype.constructor = BoxBufferGeometry,
    PlaneGeometry.prototype = Object.create(Geometry.prototype), PlaneGeometry.prototype.constructor = PlaneGeometry,
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry,
    MeshBasicMaterial.prototype = Object.create(Material.prototype), MeshBasicMaterial.prototype.constructor = MeshBasicMaterial,
    MeshBasicMaterial.prototype.isMeshBasicMaterial = !0, MeshBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity,
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap,
        this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine,
        this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio,
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth,
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin,
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this;
    }, ShaderMaterial.prototype = Object.create(Material.prototype), ShaderMaterial.prototype.constructor = ShaderMaterial,
    ShaderMaterial.prototype.isShaderMaterial = !0, ShaderMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.fragmentShader = source.fragmentShader,
        this.vertexShader = source.vertexShader, this.uniforms = UniformsUtils.clone(source.uniforms),
        this.defines = source.defines, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth,
        this.lights = source.lights, this.clipping = source.clipping, this.skinning = source.skinning,
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals,
        this.extensions = source.extensions, this;
    }, ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        return data.uniforms = this.uniforms, data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader,
        data;
    }, Object.assign(Ray.prototype, {
        set: function(origin, direction) {
            return this.origin.copy(origin), this.direction.copy(direction), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(ray) {
            return this.origin.copy(ray.origin), this.direction.copy(ray.direction), this;
        },
        at: function(t, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function(v) {
            return this.direction.copy(v).sub(this.origin).normalize(), this;
        },
        recast: function() {
            var v1 = new Vector3();
            return function(t) {
                return this.origin.copy(this.at(t, v1)), this;
            };
        }(),
        closestPointToPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            return directionDistance < 0 ? result.copy(this.origin) : result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                return directionDistance < 0 ? this.origin.distanceToSquared(point) : (v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin),
                v1.distanceToSquared(point));
            };
        }(),
        distanceSqToSegment: function() {
            var segCenter = new Vector3(), segDir = new Vector3(), diff = new Vector3();
            return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(.5), segDir.copy(v1).sub(v0).normalize(),
                diff.copy(this.origin).sub(segCenter);
                var s0, s1, sqrDist, extDet, segExtent = .5 * v0.distanceTo(v1), a01 = -this.direction.dot(segDir), b0 = diff.dot(this.direction), b1 = -diff.dot(segDir), c = diff.lengthSq(), det = Math.abs(1 - a01 * a01);
                if (det > 0) if (s0 = a01 * b1 - b0, s1 = a01 * b0 - b1, extDet = segExtent * det,
                s0 >= 0) if (s1 >= -extDet) if (s1 <= extDet) {
                    var invDet = 1 / det;
                    s0 *= invDet, s1 *= invDet, sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else s1 = segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else s1 = -segExtent,
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else s1 <= -extDet ? (s0 = Math.max(0, -(-a01 * segExtent + b0)),
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0,
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)),
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c); else s1 = a01 > 0 ? -segExtent : segExtent,
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                return optionalPointOnRay && optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin),
                optionalPointOnSegment && optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter),
                sqrDist;
            };
        }(),
        intersectSphere: function() {
            var v1 = new Vector3();
            return function(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction), d2 = v1.dot(v1) - tca * tca, radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2), t0 = tca - thc, t1 = tca + thc;
                return t0 < 0 && t1 < 0 ? null : t0 < 0 ? this.at(t1, optionalTarget) : this.at(t0, optionalTarget);
            };
        }(),
        intersectsSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (0 === denominator) return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function(plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            return null === t ? null : this.at(t, optionalTarget);
        },
        intersectsPlane: function(plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            return 0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0;
        },
        intersectBox: function(box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
            return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx, tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx,
            tmax = (box.min.x - origin.x) * invdirx), invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry,
            tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry,
            tymax = (box.min.y - origin.y) * invdiry), tmin > tymax || tymin > tmax ? null : ((tymin > tmin || tmin !== tmin) && (tmin = tymin),
            (tymax < tmax || tmax !== tmax) && (tmax = tymax), invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz,
            tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz,
            tzmax = (box.min.z - origin.z) * invdirz), tmin > tzmax || tzmin > tmax ? null : ((tzmin > tmin || tmin !== tmin) && (tmin = tzmin),
            (tzmax < tmax || tmax !== tmax) && (tmax = tzmax), tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, optionalTarget)));
        },
        intersectsBox: function() {
            var v = new Vector3();
            return function(box) {
                return null !== this.intersectBox(box, v);
            };
        }(),
        intersectTriangle: function() {
            var diff = new Vector3(), edge1 = new Vector3(), edge2 = new Vector3(), normal = new Vector3();
            return function(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a), edge2.subVectors(c, a), normal.crossVectors(edge1, edge2);
                var sign, DdN = this.direction.dot(normal);
                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else {
                    if (!(DdN < 0)) return null;
                    sign = -1, DdN = -DdN;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) return null;
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) return null;
                if (DdQxE2 + DdE1xQ > DdN) return null;
                var QdN = -sign * diff.dot(normal);
                return QdN < 0 ? null : this.at(QdN / DdN, optionalTarget);
            };
        }(),
        applyMatrix4: function(matrix4) {
            return this.origin.applyMatrix4(matrix4), this.direction.transformDirection(matrix4),
            this;
        },
        equals: function(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    }), Object.assign(Line3.prototype, {
        set: function(start, end) {
            return this.start.copy(start), this.end.copy(end), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(line) {
            return this.start.copy(line.start), this.end.copy(line.end), this;
        },
        getCenter: function(optionalTarget) {
            return (optionalTarget || new Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);
        },
        delta: function(optionalTarget) {
            return (optionalTarget || new Vector3()).subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function() {
            var startP = new Vector3(), startEnd = new Vector3();
            return function(point, clampToLine) {
                startP.subVectors(point, this.start), startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd), startEnd_startP = startEnd.dot(startP), t = startEnd_startP / startEnd2;
                return clampToLine && (t = _Math.clamp(t, 0, 1)), t;
            };
        }(),
        closestPointToPoint: function(point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine), result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function(matrix) {
            return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
        },
        equals: function(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    }), Object.assign(Triangle, {
        normal: function() {
            var v0 = new Vector3();
            return function(a, b, c, optionalTarget) {
                var result = optionalTarget || new Vector3();
                result.subVectors(c, b), v0.subVectors(a, b), result.cross(v0);
                var resultLengthSq = result.lengthSq();
                return resultLengthSq > 0 ? result.multiplyScalar(1 / Math.sqrt(resultLengthSq)) : result.set(0, 0, 0);
            };
        }(),
        barycoordFromPoint: function() {
            var v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3();
            return function(point, a, b, c, optionalTarget) {
                v0.subVectors(c, a), v1.subVectors(b, a), v2.subVectors(point, a);
                var dot00 = v0.dot(v0), dot01 = v0.dot(v1), dot02 = v0.dot(v2), dot11 = v1.dot(v1), dot12 = v1.dot(v2), denom = dot00 * dot11 - dot01 * dot01, result = optionalTarget || new Vector3();
                if (0 === denom) return result.set(-2, -1, -1);
                var invDenom = 1 / denom, u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return result.set(1 - u - v, v, u);
            };
        }(),
        containsPoint: function() {
            var v1 = new Vector3();
            return function(point, a, b, c) {
                var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
                return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
            };
        }()
    }), Object.assign(Triangle.prototype, {
        set: function(a, b, c) {
            return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
        },
        setFromPointsAndIndices: function(points, i0, i1, i2) {
            return this.a.copy(points[i0]), this.b.copy(points[i1]), this.c.copy(points[i2]),
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(triangle) {
            return this.a.copy(triangle.a), this.b.copy(triangle.b), this.c.copy(triangle.c),
            this;
        },
        area: function() {
            var v0 = new Vector3(), v1 = new Vector3();
            return function() {
                return v0.subVectors(this.c, this.b), v1.subVectors(this.a, this.b), .5 * v0.cross(v1).length();
            };
        }(),
        midpoint: function(optionalTarget) {
            return (optionalTarget || new Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        normal: function(optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },
        plane: function(optionalTarget) {
            return (optionalTarget || new Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function(point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },
        containsPoint: function(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        closestPointToPoint: function() {
            var plane = new Plane(), edgeList = [ new Line3(), new Line3(), new Line3() ], projectedPoint = new Vector3(), closestPoint = new Vector3();
            return function(point, optionalTarget) {
                var result = optionalTarget || new Vector3(), minDistance = 1 / 0;
                if (plane.setFromCoplanarPoints(this.a, this.b, this.c), plane.projectPoint(point, projectedPoint),
                !0 === this.containsPoint(projectedPoint)) result.copy(projectedPoint); else {
                    edgeList[0].set(this.a, this.b), edgeList[1].set(this.b, this.c), edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        distance < minDistance && (minDistance = distance, result.copy(closestPoint));
                    }
                }
                return result;
            };
        }(),
        equals: function(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    }), Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: !0,
        setDrawMode: function(value) {
            this.drawMode = value;
        },
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.drawMode = source.drawMode,
            void 0 !== source.morphTargetInfluences && (this.morphTargetInfluences = source.morphTargetInfluences.slice()),
            void 0 !== source.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)),
            this;
        },
        updateMorphTargets: function() {
            var m, ml, name, geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes, keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (void 0 !== morphAttribute) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {},
                    m = 0, ml = morphAttribute.length; m < ml; m++) name = morphAttribute[m].name || String(m),
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (void 0 !== morphTargets && morphTargets.length > 0) for (this.morphTargetInfluences = [],
                this.morphTargetDictionary = {}, m = 0, ml = morphTargets.length; m < ml; m++) name = morphTargets[m].name || String(m),
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
            }
        },
        raycast: function() {
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                return Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord), uv1.multiplyScalar(barycoord.x),
                uv2.multiplyScalar(barycoord.y), uv3.multiplyScalar(barycoord.z), uv1.add(uv2).add(uv3),
                uv1.clone();
            }
            function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                if (null === (material.side === BackSide ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point))) return null;
                intersectionPointWorld.copy(point), intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                return distance < raycaster.near || distance > raycaster.far ? null : {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a), vB.fromBufferAttribute(position, b), vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                return intersection && (uv && (uvA.fromBufferAttribute(uv, a), uvB.fromBufferAttribute(uv, b),
                uvC.fromBufferAttribute(uv, c), intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)),
                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC)), intersection.faceIndex = a),
                intersection;
            }
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere(), vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), tempA = new Vector3(), tempB = new Vector3(), tempC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), barycoord = new Vector3(), intersectionPoint = new Vector3(), intersectionPointWorld = new Vector3();
            return function(raycaster, intersects) {
                var geometry = this.geometry, material = this.material, matrixWorld = this.matrixWorld;
                if (void 0 !== material && (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                sphere.copy(geometry.boundingSphere), sphere.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(sphere) && (inverseMatrix.getInverse(matrixWorld),
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix), null === geometry.boundingBox || !1 !== ray.intersectsBox(geometry.boundingBox)))) {
                    var intersection;
                    if (geometry.isBufferGeometry) {
                        var a, b, c, i, l, index = geometry.index, position = geometry.attributes.position, uv = geometry.attributes.uv;
                        if (null !== index) for (i = 0, l = index.count; i < l; i += 3) a = index.getX(i),
                        b = index.getX(i + 1), c = index.getX(i + 2), (intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c)) && (intersection.faceIndex = Math.floor(i / 3),
                        intersects.push(intersection)); else if (void 0 !== position) for (i = 0, l = position.count; i < l; i += 3) a = i,
                        b = i + 1, c = i + 2, (intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c)) && (intersection.index = a,
                        intersects.push(intersection));
                    } else if (geometry.isGeometry) {
                        var fvA, fvB, fvC, uvs, isMultiMaterial = Array.isArray(material), vertices = geometry.vertices, faces = geometry.faces, faceVertexUvs = geometry.faceVertexUvs[0];
                        faceVertexUvs.length > 0 && (uvs = faceVertexUvs);
                        for (var f = 0, fl = faces.length; f < fl; f++) {
                            var face = faces[f], faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                            if (void 0 !== faceMaterial) {
                                if (fvA = vertices[face.a], fvB = vertices[face.b], fvC = vertices[face.c], !0 === faceMaterial.morphTargets) {
                                    var morphTargets = geometry.morphTargets, morphInfluences = this.morphTargetInfluences;
                                    vA.set(0, 0, 0), vB.set(0, 0, 0), vC.set(0, 0, 0);
                                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                        var influence = morphInfluences[t];
                                        if (0 !== influence) {
                                            var targets = morphTargets[t].vertices;
                                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence), vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence),
                                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                                        }
                                    }
                                    vA.add(fvA), vB.add(fvB), vC.add(fvC), fvA = vA, fvB = vB, fvC = vC;
                                }
                                if (intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint)) {
                                    if (uvs && uvs[f]) {
                                        var uvs_f = uvs[f];
                                        uvA.copy(uvs_f[0]), uvB.copy(uvs_f[1]), uvC.copy(uvs_f[2]), intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                                    }
                                    intersection.face = face, intersection.faceIndex = f, intersects.push(intersection);
                                }
                            }
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    var programIdCount = 0;
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: !0,
        copy: function(source, recursive) {
            return Camera.prototype.copy.call(this, source, recursive), this.fov = source.fov,
            this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus,
            this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view),
            this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this;
        },
        setFocalLength: function(focalLength) {
            var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
            this.fov = 2 * _Math.RAD2DEG * Math.atan(vExtentSlope), this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var vExtentSlope = Math.tan(.5 * _Math.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function() {
            return 2 * _Math.RAD2DEG * Math.atan(Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight,
            this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height,
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var near = this.near, top = near * Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -.5 * width, view = this.view;
            if (null !== this.view && this.view.enabled) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth, top -= view.offsetY * height / fullHeight,
                width *= view.width / fullWidth, height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            0 !== skew && (left += near * skew / this.getFilmWidth()), this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near,
            data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect,
            null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge,
            data.object.filmOffset = this.filmOffset, data;
        }
    }), ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
        constructor: ArrayCamera,
        isArrayCamera: !0
    }), FogExp2.prototype.isFogExp2 = !0, FogExp2.prototype.clone = function() {
        return new FogExp2(this.color.getHex(), this.density);
    }, FogExp2.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }, Fog.prototype.isFog = !0, Fog.prototype.clone = function() {
        return new Fog(this.color.getHex(), this.near, this.far);
    }, Fog.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }, Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Scene,
        copy: function(source, recursive) {
            return Object3D.prototype.copy.call(this, source, recursive), null !== source.background && (this.background = source.background.clone()),
            null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()),
            this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate,
            this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return null !== this.background && (data.object.background = this.background.toJSON(meta)),
            null !== this.fog && (data.object.fog = this.fog.toJSON()), data;
        }
    }), LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LensFlare,
        isLensFlare: !0,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source), this.positionScreen.copy(source.positionScreen),
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; i < l; i++) this.lensFlares.push(source.lensFlares[i]);
            return this;
        },
        add: function(texture, size, distance, blending, color, opacity) {
            void 0 === size && (size = -1), void 0 === distance && (distance = 0), void 0 === opacity && (opacity = 1),
            void 0 === color && (color = new Color(16777215)), void 0 === blending && (blending = NormalBlending),
            distance = Math.min(distance, Math.max(0, distance)), this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
        },
        updateLensFlares: function() {
            var f, flare, fl = this.lensFlares.length, vecX = 2 * -this.positionScreen.x, vecY = 2 * -this.positionScreen.y;
            for (f = 0; f < fl; f++) flare = this.lensFlares[f], flare.x = this.positionScreen.x + vecX * flare.distance,
            flare.y = this.positionScreen.y + vecY * flare.distance, flare.wantedRotation = flare.x * Math.PI * .25,
            flare.rotation += .25 * (flare.wantedRotation - flare.rotation);
        }
    }), SpriteMaterial.prototype = Object.create(Material.prototype), SpriteMaterial.prototype.constructor = SpriteMaterial,
    SpriteMaterial.prototype.isSpriteMaterial = !0, SpriteMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.map = source.map, this.rotation = source.rotation, this;
    }, Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: !0,
        raycast: function() {
            var intersectPoint = new Vector3(), worldPosition = new Vector3(), worldScale = new Vector3();
            return function(raycaster, intersects) {
                worldPosition.setFromMatrixPosition(this.matrixWorld), raycaster.ray.closestPointToPoint(worldPosition, intersectPoint),
                worldScale.setFromMatrixScale(this.matrixWorld);
                var guessSizeSq = worldScale.x * worldScale.y / 4;
                if (!(worldPosition.distanceToSquared(intersectPoint) > guessSizeSq)) {
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    distance < raycaster.near || distance > raycaster.far || intersects.push({
                        distance: distance,
                        point: intersectPoint.clone(),
                        face: null,
                        object: this
                    });
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        }
    }), LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source, !1);
            for (var levels = source.levels, i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function(object, distance) {
            void 0 === distance && (distance = 0), distance = Math.abs(distance);
            for (var levels = this.levels, l = 0; l < levels.length && !(distance < levels[l].distance); l++) ;
            levels.splice(l, 0, {
                distance: distance,
                object: object
            }), this.add(object);
        },
        getObjectForDistance: function(distance) {
            for (var levels = this.levels, i = 1, l = levels.length; i < l && !(distance < levels[i].distance); i++) ;
            return levels[i - 1].object;
        },
        raycast: function() {
            var matrixPosition = new Vector3();
            return function(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }(),
        update: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld), v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = !0;
                    for (var i = 1, l = levels.length; i < l && distance >= levels[i].distance; i++) levels[i - 1].object.visible = !1,
                    levels[i].object.visible = !0;
                    for (;i < l; i++) levels[i].object.visible = !1;
                }
            };
        }(),
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            for (var levels = this.levels, i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    }), Object.assign(Skeleton.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new Matrix4();
                this.bones[i] && inverse.getInverse(this.bones[i].matrixWorld), this.boneInverses.push(inverse);
            }
        },
        pose: function() {
            var bone, i, il;
            for (i = 0, il = this.bones.length; i < il; i++) (bone = this.bones[i]) && bone.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, il = this.bones.length; i < il; i++) (bone = this.bones[i]) && (bone.parent && bone.parent.isBone ? (bone.matrix.getInverse(bone.parent.matrixWorld),
            bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld), bone.matrix.decompose(bone.position, bone.quaternion, bone.scale));
        },
        update: function() {
            var offsetMatrix = new Matrix4(), identityMatrix = new Matrix4();
            return function() {
                for (var bones = this.bones, boneInverses = this.boneInverses, boneMatrices = this.boneMatrices, boneTexture = this.boneTexture, i = 0, il = bones.length; i < il; i++) {
                    var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, boneInverses[i]), offsetMatrix.toArray(boneMatrices, 16 * i);
                }
                void 0 !== boneTexture && (boneTexture.needsUpdate = !0);
            };
        }(),
        clone: function() {
            return new Skeleton(this.bones, this.boneInverses);
        }
    }), Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: !0
    }), SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: !0,
        initBones: function() {
            var bone, gbone, i, il, bones = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, il = this.geometry.bones.length; i < il; i++) gbone = this.geometry.bones[i],
                bone = new Bone(), bones.push(bone), bone.name = gbone.name, bone.position.fromArray(gbone.pos),
                bone.quaternion.fromArray(gbone.rotq), void 0 !== gbone.scl && bone.scale.fromArray(gbone.scl);
                for (i = 0, il = this.geometry.bones.length; i < il; i++) gbone = this.geometry.bones[i],
                -1 !== gbone.parent && null !== gbone.parent && void 0 !== bones[gbone.parent] ? bones[gbone.parent].add(bones[i]) : this.add(bones[i]);
            }
            return this.updateMatrixWorld(!0), bones;
        },
        bind: function(skeleton, bindMatrix) {
            this.skeleton = skeleton, void 0 === bindMatrix && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(), bindMatrix = this.matrixWorld), this.bindMatrix.copy(bindMatrix),
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            var scale, i;
            if (this.geometry && this.geometry.isGeometry) for (i = 0; i < this.geometry.skinWeights.length; i++) {
                var sw = this.geometry.skinWeights[i];
                scale = 1 / sw.manhattanLength(), scale !== 1 / 0 ? sw.multiplyScalar(scale) : sw.set(1, 0, 0, 0);
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4(), skinWeight = this.geometry.attributes.skinWeight;
                for (i = 0; i < skinWeight.count; i++) vec.x = skinWeight.getX(i), vec.y = skinWeight.getY(i),
                vec.z = skinWeight.getZ(i), vec.w = skinWeight.getW(i), scale = 1 / vec.manhattanLength(),
                scale !== 1 / 0 ? vec.multiplyScalar(scale) : vec.set(1, 0, 0, 0), skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
            }
        },
        updateMatrixWorld: function(force) {
            Mesh.prototype.updateMatrixWorld.call(this, force), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), LineBasicMaterial.prototype = Object.create(Material.prototype), LineBasicMaterial.prototype.constructor = LineBasicMaterial,
    LineBasicMaterial.prototype.isLineBasicMaterial = !0, LineBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin,
        this;
    }, Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                var precision = raycaster.linePrecision, precisionSq = precision * precision, geometry = this.geometry, matrixWorld = this.matrixWorld;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere),
                sphere.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(sphere)) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var vStart = new Vector3(), vEnd = new Vector3(), interSegment = new Vector3(), interRay = new Vector3(), step = this && this.isLineSegments ? 2 : 1;
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, l = indices.length - 1; i < l; i += step) {
                            var a = indices[i], b = indices[i + 1];
                            vStart.fromArray(positions, 3 * a), vEnd.fromArray(positions, 3 * b);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        } else for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                            vStart.fromArray(positions, 3 * i), vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        }
                    } else if (geometry.isGeometry) for (var vertices = geometry.vertices, nbVertices = vertices.length, i = 0; i < nbVertices - 1; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (!(distSq > precisionSq)) {
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            distance < raycaster.near || distance > raycaster.far || intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: !0
    }), LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineLoop,
        isLineLoop: !0
    }), PointsMaterial.prototype = Object.create(Material.prototype), PointsMaterial.prototype.constructor = PointsMaterial,
    PointsMaterial.prototype.isPointsMaterial = !0, PointsMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.map = source.map, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation,
        this;
    }, Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                var object = this, geometry = this.geometry, matrixWorld = this.matrixWorld, threshold = raycaster.params.Points.threshold;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere),
                sphere.applyMatrix4(matrixWorld), sphere.radius += threshold, !1 !== raycaster.ray.intersectsSphere(sphere)) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3), localThresholdSq = localThreshold * localThreshold, position = new Vector3();
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];
                            position.fromArray(positions, 3 * a), testPoint(position, a);
                        } else for (var i = 0, l = positions.length / 3; i < l; i++) position.fromArray(positions, 3 * i),
                        testPoint(position, i);
                    } else for (var vertices = geometry.vertices, i = 0, l = vertices.length; i < l; i++) testPoint(vertices[i], i);
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group
    }), VideoTexture.prototype = Object.create(Texture.prototype), VideoTexture.prototype.constructor = VideoTexture,
    CompressedTexture.prototype = Object.create(Texture.prototype), CompressedTexture.prototype.constructor = CompressedTexture,
    CompressedTexture.prototype.isCompressedTexture = !0, DepthTexture.prototype = Object.create(Texture.prototype),
    DepthTexture.prototype.constructor = DepthTexture, DepthTexture.prototype.isDepthTexture = !0,
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype), WireframeGeometry.prototype.constructor = WireframeGeometry,
    ParametricGeometry.prototype = Object.create(Geometry.prototype), ParametricGeometry.prototype.constructor = ParametricGeometry,
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry,
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype), PolyhedronGeometry.prototype.constructor = PolyhedronGeometry,
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry,
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype), TetrahedronGeometry.prototype.constructor = TetrahedronGeometry,
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype),
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry, OctahedronGeometry.prototype = Object.create(Geometry.prototype),
    OctahedronGeometry.prototype.constructor = OctahedronGeometry, OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype),
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry, IcosahedronGeometry.prototype = Object.create(Geometry.prototype),
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry, IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype),
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry, DodecahedronGeometry.prototype = Object.create(Geometry.prototype),
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry, DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype),
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry, TubeGeometry.prototype = Object.create(Geometry.prototype),
    TubeGeometry.prototype.constructor = TubeGeometry, TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype),
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry, TorusKnotGeometry.prototype = Object.create(Geometry.prototype),
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry, TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype),
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry, TorusGeometry.prototype = Object.create(Geometry.prototype),
    TorusGeometry.prototype.constructor = TorusGeometry, TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype),
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    var ShapeUtils = {
        area: function(contour) {
            for (var n = contour.length, a = 0, p = n - 1, q = 0; q < n; p = q++) a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            return .5 * a;
        },
        triangulate: function() {
            function snip(contour, u, v, w, n, verts) {
                var p, ax, ay, bx, by, cx, cy, px, py;
                if (ax = contour[verts[u]].x, ay = contour[verts[u]].y, bx = contour[verts[v]].x,
                by = contour[verts[v]].y, cx = contour[verts[w]].x, cy = contour[verts[w]].y, (bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) return !1;
                var aX, aY, bX, bY, cX, cY, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp;
                for (aX = cx - bx, aY = cy - by, bX = ax - cx, bY = ay - cy, cX = bx - ax, cY = by - ay,
                p = 0; p < n; p++) if (px = contour[verts[p]].x, py = contour[verts[p]].y, !(px === ax && py === ay || px === bx && py === by || px === cx && py === cy) && (apx = px - ax,
                apy = py - ay, bpx = px - bx, bpy = py - by, cpx = px - cx, cpy = py - cy, aCROSSbp = aX * bpy - aY * bpx,
                cCROSSap = cX * apy - cY * apx, bCROSScp = bX * cpy - bY * cpx, aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)) return !1;
                return !0;
            }
            return function(contour, indices) {
                var n = contour.length;
                if (n < 3) return null;
                var u, v, w, result = [], verts = [], vertIndices = [];
                if (ShapeUtils.area(contour) > 0) for (v = 0; v < n; v++) verts[v] = v; else for (v = 0; v < n; v++) verts[v] = n - 1 - v;
                var nv = n, count = 2 * nv;
                for (v = nv - 1; nv > 2; ) {
                    if (count-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                    indices ? vertIndices : result;
                    if (u = v, nv <= u && (u = 0), v = u + 1, nv <= v && (v = 0), w = v + 1, nv <= w && (w = 0),
                    snip(contour, u, v, w, nv, verts)) {
                        var a, b, c, s, t;
                        for (a = verts[u], b = verts[v], c = verts[w], result.push([ contour[a], contour[b], contour[c] ]),
                        vertIndices.push([ verts[u], verts[v], verts[w] ]), s = v, t = v + 1; t < nv; s++,
                        t++) verts[s] = verts[t];
                        nv--, count = 2 * nv;
                    }
                }
                return indices ? vertIndices : result;
            };
        }(),
        triangulateShape: function(contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                l > 2 && points[l - 1].equals(points[0]) && points.pop();
            }
            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                return inSegPt1.x !== inSegPt2.x ? inSegPt1.x < inSegPt2.x ? inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x : inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x : inSegPt1.y < inSegPt2.y ? inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y : inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
            }
            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y, seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y, seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x, seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y, limit = seg1dy * seg2dx - seg1dx * seg2dy, perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (Math.abs(limit) > Number.EPSILON) {
                    var perpSeg2;
                    if (limit > 0) {
                        if (perpSeg1 < 0 || perpSeg1 > limit) return [];
                        if ((perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy) < 0 || perpSeg2 > limit) return [];
                    } else {
                        if (perpSeg1 > 0 || perpSeg1 < limit) return [];
                        if ((perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy) > 0 || perpSeg2 < limit) return [];
                    }
                    if (0 === perpSeg2) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt1 ] : [];
                    if (perpSeg2 === limit) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt2 ] : [];
                    if (0 === perpSeg1) return [ inSeg2Pt1 ];
                    if (perpSeg1 === limit) return [ inSeg2Pt2 ];
                    var factorSeg1 = perpSeg2 / limit;
                    return [ {
                        x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy
                    } ];
                }
                if (0 !== perpSeg1 || seg2dy * seg1seg2dx != seg2dx * seg1seg2dy) return [];
                var seg1Pt = 0 === seg1dx && 0 === seg1dy, seg2Pt = 0 === seg2dx && 0 === seg2dy;
                if (seg1Pt && seg2Pt) return inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y ? [] : [ inSeg1Pt1 ];
                if (seg1Pt) return point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1) ? [ inSeg1Pt1 ] : [];
                if (seg2Pt) return point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1) ? [ inSeg2Pt1 ] : [];
                var seg1min, seg1max, seg1minVal, seg1maxVal, seg2min, seg2max, seg2minVal, seg2maxVal;
                return 0 !== seg1dx ? (inSeg1Pt1.x < inSeg1Pt2.x ? (seg1min = inSeg1Pt1, seg1minVal = inSeg1Pt1.x,
                seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.x) : (seg1min = inSeg1Pt2, seg1minVal = inSeg1Pt2.x,
                seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.x), inSeg2Pt1.x < inSeg2Pt2.x ? (seg2min = inSeg2Pt1,
                seg2minVal = inSeg2Pt1.x, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.x) : (seg2min = inSeg2Pt2,
                seg2minVal = inSeg2Pt2.x, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.x)) : (inSeg1Pt1.y < inSeg1Pt2.y ? (seg1min = inSeg1Pt1,
                seg1minVal = inSeg1Pt1.y, seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.y) : (seg1min = inSeg1Pt2,
                seg1minVal = inSeg1Pt2.y, seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.y), inSeg2Pt1.y < inSeg2Pt2.y ? (seg2min = inSeg2Pt1,
                seg2minVal = inSeg2Pt1.y, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.y) : (seg2min = inSeg2Pt2,
                seg2minVal = inSeg2Pt2.y, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.y)), seg1minVal <= seg2minVal ? seg1maxVal < seg2minVal ? [] : seg1maxVal === seg2minVal ? inExcludeAdjacentSegs ? [] : [ seg2min ] : seg1maxVal <= seg2maxVal ? [ seg2min, seg1max ] : [ seg2min, seg2max ] : seg1minVal > seg2maxVal ? [] : seg1minVal === seg2maxVal ? inExcludeAdjacentSegs ? [] : [ seg1min ] : seg1maxVal <= seg2maxVal ? [ seg1min, seg1max ] : [ seg1min, seg2max ];
            }
            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y, legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y, otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y, from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX, from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (Math.abs(from2toAngle) > Number.EPSILON) {
                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    return from2toAngle > 0 ? from2otherAngle >= 0 && other2toAngle >= 0 : from2otherAngle >= 0 || other2toAngle >= 0;
                }
                return from2otherAngle > 0;
            }
            removeDupEndPts(contour), holes.forEach(removeDupEndPts);
            for (var i, il, f, face, key, index, allPointsMap = {}, allpoints = contour.concat(), h = 0, hl = holes.length; h < hl; h++) Array.prototype.push.apply(allpoints, holes[h]);
            for (i = 0, il = allpoints.length; i < il; i++) key = allpoints[i].x + ":" + allpoints[i].y,
            void 0 !== allPointsMap[key] && console.warn("THREE.ShapeUtils: Duplicate point", key, i),
            allPointsMap[key] = i;
            var shapeWithoutHoles = function(contour, holes) {
                for (var hole, holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, tmpShape1, tmpShape2, tmpHole1, tmpHole2, shape = contour.concat(), indepHoles = [], failedCuts = [], h = 0, hl = holes.length; h < hl; h++) indepHoles.push(h);
                for (var minShapeIndex = 0, counter = 2 * indepHoles.length; indepHoles.length > 0; ) {
                    if (--counter < 0) {
                        console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');
                        break;
                    }
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                        shapePt = shape[shapeIndex], holeIndex = -1;
                        for (var h = 0; h < indepHoles.length; h++) if (holeIdx = indepHoles[h], cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx,
                        void 0 === failedCuts[cutKey]) {
                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) if (holePt = hole[h2], function(inShapeIdx, inHoleIdx) {
                                var lastShapeIdx = shape.length - 1, prevShapeIdx = inShapeIdx - 1;
                                prevShapeIdx < 0 && (prevShapeIdx = lastShapeIdx);
                                var nextShapeIdx = inShapeIdx + 1;
                                nextShapeIdx > lastShapeIdx && (nextShapeIdx = 0);
                                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                                if (!insideAngle) return !1;
                                var lastHoleIdx = hole.length - 1, prevHoleIdx = inHoleIdx - 1;
                                prevHoleIdx < 0 && (prevHoleIdx = lastHoleIdx);
                                var nextHoleIdx = inHoleIdx + 1;
                                return nextHoleIdx > lastHoleIdx && (nextHoleIdx = 0), !!(insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]));
                            }(shapeIndex, h2) && !function(inShapePt, inHolePt) {
                                var sIdx, nextIdx, intersection;
                                for (sIdx = 0; sIdx < shape.length; sIdx++) if (nextIdx = sIdx + 1, nextIdx %= shape.length,
                                intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], !0),
                                intersection.length > 0) return !0;
                                return !1;
                            }(shapePt, holePt) && !function(inShapePt, inHolePt) {
                                var ihIdx, chkHole, hIdx, nextIdx, intersection;
                                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) for (chkHole = holes[indepHoles[ihIdx]],
                                hIdx = 0; hIdx < chkHole.length; hIdx++) if (nextIdx = hIdx + 1, nextIdx %= chkHole.length,
                                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], !0),
                                intersection.length > 0) return !0;
                                return !1;
                            }(shapePt, holePt)) {
                                holeIndex = h2, indepHoles.splice(h, 1), tmpShape1 = shape.slice(0, shapeIndex + 1),
                                tmpShape2 = shape.slice(shapeIndex), tmpHole1 = hole.slice(holeIndex), tmpHole2 = hole.slice(0, holeIndex + 1),
                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2), minShapeIndex = shapeIndex;
                                break;
                            }
                            if (holeIndex >= 0) break;
                            failedCuts[cutKey] = !0;
                        }
                        if (holeIndex >= 0) break;
                    }
                }
                return shape;
            }(contour, holes), triangles = ShapeUtils.triangulate(shapeWithoutHoles, !1);
            for (i = 0, il = triangles.length; i < il; i++) for (face = triangles[i], f = 0; f < 3; f++) key = face[f].x + ":" + face[f].y,
            void 0 !== (index = allPointsMap[key]) && (face[f] = index);
            return triangles.concat();
        },
        isClockWise: function(pts) {
            return ShapeUtils.area(pts) < 0;
        }
    };
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype), ExtrudeGeometry.prototype.constructor = ExtrudeGeometry,
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry,
    ExtrudeBufferGeometry.prototype.getArrays = function() {
        var positionAttribute = this.getAttribute("position"), verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [], uvAttribute = this.getAttribute("uv"), uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [], IndexAttribute = this.index;
        return {
            position: verticesArray,
            uv: uvArray,
            index: IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : []
        };
    }, ExtrudeBufferGeometry.prototype.addShapeList = function(shapes, options) {
        var sl = shapes.length;
        options.arrays = this.getArrays();
        for (var s = 0; s < sl; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
        this.setIndex(options.arrays.index), this.addAttribute("position", new Float32BufferAttribute(options.arrays.position, 3)),
        this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2));
    }, ExtrudeBufferGeometry.prototype.addShape = function(shape, options) {
        function scalePt2(pt, vec, size) {
            return vec || console.error("THREE.ExtrudeGeometry: vec does not exist"), vec.clone().multiplyScalar(size).add(pt);
        }
        function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by, v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y, v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y, v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y, collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq), v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y), ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len, ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len, ptNextShift_x = inNext.x - v_next_y / v_next_len, ptNextShift_y = inNext.y + v_next_x / v_next_len, sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x, v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                shrink_by = Math.sqrt(v_trans_lensq / 2);
            } else {
                var direction_eq = !1;
                v_prev_x > Number.EPSILON ? v_next_x > Number.EPSILON && (direction_eq = !0) : v_prev_x < -Number.EPSILON ? v_next_x < -Number.EPSILON && (direction_eq = !0) : Math.sign(v_prev_y) === Math.sign(v_next_y) && (direction_eq = !0),
                direction_eq ? (v_trans_x = -v_prev_y, v_trans_y = v_prev_x, shrink_by = Math.sqrt(v_prev_lensq)) : (v_trans_x = v_prev_x,
                v_trans_y = v_prev_y, shrink_by = Math.sqrt(v_prev_lensq / 2));
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        function sidewalls(contour, layeroffset) {
            var j, k;
            for (i = contour.length; --i >= 0; ) {
                j = i, k = i - 1, k < 0 && (k = contour.length - 1);
                var s = 0, sl = steps + 2 * bevelSegments;
                for (s = 0; s < sl; s++) {
                    var slen1 = vlen * s, slen2 = vlen * (s + 1);
                    f4(layeroffset + j + slen1, layeroffset + k + slen1, layeroffset + k + slen2, layeroffset + j + slen2);
                }
            }
        }
        function v(x, y, z) {
            placeholder.push(x), placeholder.push(y), placeholder.push(z);
        }
        function f3(a, b, c) {
            addVertex(a), addVertex(b), addVertex(c);
            var nextIndex = verticesArray.length / 3, uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
            addVertex(a), addVertex(b), addVertex(d), addVertex(b), addVertex(c), addVertex(d);
            var nextIndex = verticesArray.length / 3, uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[3]), addUV(uvs[1]), addUV(uvs[2]), addUV(uvs[3]);
        }
        function addVertex(index) {
            indicesArray.push(verticesArray.length / 3), verticesArray.push(placeholder[3 * index + 0]),
            verticesArray.push(placeholder[3 * index + 1]), verticesArray.push(placeholder[3 * index + 2]);
        }
        function addUV(vector2) {
            uvArray.push(vector2.x), uvArray.push(vector2.y);
        }
        var extrudePts, splineTube, binormal, normal, position2, arrays = options.arrays ? options.arrays : this.getArrays(), verticesArray = arrays.position, indicesArray = arrays.index, uvArray = arrays.uv, placeholder = [], amount = void 0 !== options.amount ? options.amount : 100, bevelThickness = void 0 !== options.bevelThickness ? options.bevelThickness : 6, bevelSize = void 0 !== options.bevelSize ? options.bevelSize : bevelThickness - 2, bevelSegments = void 0 !== options.bevelSegments ? options.bevelSegments : 3, bevelEnabled = void 0 === options.bevelEnabled || options.bevelEnabled, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, steps = void 0 !== options.steps ? options.steps : 1, extrudePath = options.extrudePath, extrudeByPath = !1, uvgen = void 0 !== options.UVGenerator ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        extrudePath && (extrudePts = extrudePath.getSpacedPoints(steps), extrudeByPath = !0,
        bevelEnabled = !1, splineTube = void 0 !== options.frames ? options.frames : extrudePath.computeFrenetFrames(steps, !1),
        binormal = new Vector3(), normal = new Vector3(), position2 = new Vector3()), bevelEnabled || (bevelSegments = 0,
        bevelThickness = 0, bevelSize = 0);
        var ahole, h, hl, scope = this, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes;
        if (!ShapeUtils.isClockWise(vertices)) for (vertices = vertices.reverse(), h = 0,
        hl = holes.length; h < hl; h++) ahole = holes[h], ShapeUtils.isClockWise(ahole) && (holes[h] = ahole.reverse());
        var faces = ShapeUtils.triangulateShape(vertices, holes), contour = vertices;
        for (h = 0, hl = holes.length; h < hl; h++) ahole = holes[h], vertices = vertices.concat(ahole);
        for (var b, bs, t, z, vert, face, vlen = vertices.length, flen = faces.length, contourMovements = [], i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++,
        j++, k++) j === il && (j = 0), k === il && (k = 0), contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        var oneHoleMovements, holesMovements = [], verticesMovements = contourMovements.concat();
        for (h = 0, hl = holes.length; h < hl; h++) {
            for (ahole = holes[h], oneHoleMovements = [], i = 0, il = ahole.length, j = il - 1,
            k = i + 1; i < il; i++, j++, k++) j === il && (j = 0), k === il && (k = 0), oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            holesMovements.push(oneHoleMovements), verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; b < bevelSegments; b++) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2),
            i = 0, il = contour.length; i < il; i++) vert = scalePt2(contour[i], contourMovements[i], bs),
            v(vert.x, vert.y, -z);
            for (h = 0, hl = holes.length; h < hl; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h],
            i = 0, il = ahole.length; i < il; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs),
            v(vert.x, vert.y, -z);
        }
        for (bs = bevelSize, i = 0; i < vlen; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i],
        extrudeByPath ? (normal.copy(splineTube.normals[0]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y),
        position2.copy(extrudePts[0]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, 0);
        var s;
        for (s = 1; s <= steps; s++) for (i = 0; i < vlen; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i],
        extrudeByPath ? (normal.copy(splineTube.normals[s]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y),
        position2.copy(extrudePts[s]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, amount / steps * s);
        for (b = bevelSegments - 1; b >= 0; b--) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2),
            i = 0, il = contour.length; i < il; i++) vert = scalePt2(contour[i], contourMovements[i], bs),
            v(vert.x, vert.y, amount + z);
            for (h = 0, hl = holes.length; h < hl; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h],
            i = 0, il = ahole.length; i < il; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs),
            extrudeByPath ? v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z) : v(vert.x, vert.y, amount + z);
        }
        !function() {
            var start = verticesArray.length / 3;
            if (bevelEnabled) {
                var layer = 0, offset = vlen * layer;
                for (i = 0; i < flen; i++) face = faces[i], f3(face[2] + offset, face[1] + offset, face[0] + offset);
                for (layer = steps + 2 * bevelSegments, offset = vlen * layer, i = 0; i < flen; i++) face = faces[i],
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
            } else {
                for (i = 0; i < flen; i++) face = faces[i], f3(face[2], face[1], face[0]);
                for (i = 0; i < flen; i++) face = faces[i], f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
            scope.addGroup(start, verticesArray.length / 3 - start, void 0 !== options.material ? options.material : 0);
        }(), function() {
            var start = verticesArray.length / 3, layeroffset = 0;
            for (sidewalls(contour, layeroffset), layeroffset += contour.length, h = 0, hl = holes.length; h < hl; h++) ahole = holes[h],
            sidewalls(ahole, layeroffset), layeroffset += ahole.length;
            scope.addGroup(start, verticesArray.length / 3 - start, void 0 !== options.extrudeMaterial ? options.extrudeMaterial : 1);
        }(), options.arrays || (this.setIndex(indicesArray), this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3)),
        this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2)));
    }, ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[3 * indexA], a_y = vertices[3 * indexA + 1], b_x = vertices[3 * indexB], b_y = vertices[3 * indexB + 1], c_x = vertices[3 * indexC], c_y = vertices[3 * indexC + 1];
            return [ new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y) ];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[3 * indexA], a_y = vertices[3 * indexA + 1], a_z = vertices[3 * indexA + 2], b_x = vertices[3 * indexB], b_y = vertices[3 * indexB + 1], b_z = vertices[3 * indexB + 2], c_x = vertices[3 * indexC], c_y = vertices[3 * indexC + 1], c_z = vertices[3 * indexC + 2], d_x = vertices[3 * indexD], d_y = vertices[3 * indexD + 1], d_z = vertices[3 * indexD + 2];
            return Math.abs(a_y - b_y) < .01 ? [ new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z) ] : [ new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z) ];
        }
    }, TextGeometry.prototype = Object.create(Geometry.prototype), TextGeometry.prototype.constructor = TextGeometry,
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype), TextBufferGeometry.prototype.constructor = TextBufferGeometry,
    SphereGeometry.prototype = Object.create(Geometry.prototype), SphereGeometry.prototype.constructor = SphereGeometry,
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype), SphereBufferGeometry.prototype.constructor = SphereBufferGeometry,
    RingGeometry.prototype = Object.create(Geometry.prototype), RingGeometry.prototype.constructor = RingGeometry,
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype), RingBufferGeometry.prototype.constructor = RingBufferGeometry,
    LatheGeometry.prototype = Object.create(Geometry.prototype), LatheGeometry.prototype.constructor = LatheGeometry,
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype), LatheBufferGeometry.prototype.constructor = LatheBufferGeometry,
    ShapeGeometry.prototype = Object.create(Geometry.prototype), ShapeGeometry.prototype.constructor = ShapeGeometry,
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry,
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype), EdgesGeometry.prototype.constructor = EdgesGeometry,
    CylinderGeometry.prototype = Object.create(Geometry.prototype), CylinderGeometry.prototype.constructor = CylinderGeometry,
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype), CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry,
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype), ConeGeometry.prototype.constructor = ConeGeometry,
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype),
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry, CircleGeometry.prototype = Object.create(Geometry.prototype),
    CircleGeometry.prototype.constructor = CircleGeometry, CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype),
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });
    ShadowMaterial.prototype = Object.create(Material.prototype), ShadowMaterial.prototype.constructor = ShadowMaterial,
    ShadowMaterial.prototype.isShadowMaterial = !0, RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype),
    RawShaderMaterial.prototype.constructor = RawShaderMaterial, RawShaderMaterial.prototype.isRawShaderMaterial = !0,
    MeshStandardMaterial.prototype = Object.create(Material.prototype), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial,
    MeshStandardMaterial.prototype.isMeshStandardMaterial = !0, MeshStandardMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.defines = {
            STANDARD: ""
        }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness,
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity,
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive),
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity,
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap,
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap,
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias,
        this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap,
        this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity,
        this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe,
        this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap,
        this.wireframeLinejoin = source.wireframeLinejoin, this.skinning = source.skinning,
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals,
        this;
    }, MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype),
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0,
    MeshPhysicalMaterial.prototype.copy = function(source) {
        return MeshStandardMaterial.prototype.copy.call(this, source), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = source.reflectivity, this.clearCoat = source.clearCoat, this.clearCoatRoughness = source.clearCoatRoughness,
        this;
    }, MeshPhongMaterial.prototype = Object.create(Material.prototype), MeshPhongMaterial.prototype.constructor = MeshPhongMaterial,
    MeshPhongMaterial.prototype.isMeshPhongMaterial = !0, MeshPhongMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map,
        this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity,
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive),
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity,
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap,
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap,
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias,
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap,
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio,
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth,
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin,
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals,
        this;
    }, MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype), MeshToonMaterial.prototype.constructor = MeshToonMaterial,
    MeshToonMaterial.prototype.isMeshToonMaterial = !0, MeshToonMaterial.prototype.copy = function(source) {
        return MeshPhongMaterial.prototype.copy.call(this, source), this.gradientMap = source.gradientMap,
        this;
    }, MeshNormalMaterial.prototype = Object.create(Material.prototype), MeshNormalMaterial.prototype.constructor = MeshNormalMaterial,
    MeshNormalMaterial.prototype.isMeshNormalMaterial = !0, MeshNormalMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.bumpMap = source.bumpMap,
        this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalScale.copy(source.normalScale),
        this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale,
        this.displacementBias = source.displacementBias, this.wireframe = source.wireframe,
        this.wireframeLinewidth = source.wireframeLinewidth, this.skinning = source.skinning,
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals,
        this;
    }, MeshLambertMaterial.prototype = Object.create(Material.prototype), MeshLambertMaterial.prototype.constructor = MeshLambertMaterial,
    MeshLambertMaterial.prototype.isMeshLambertMaterial = !0, MeshLambertMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color),
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity,
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive),
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity,
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap,
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio,
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth,
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin,
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals,
        this;
    }, LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype), LineDashedMaterial.prototype.constructor = LineDashedMaterial,
    LineDashedMaterial.prototype.isLineDashedMaterial = !0, LineDashedMaterial.prototype.copy = function(source) {
        return LineBasicMaterial.prototype.copy.call(this, source), this.scale = source.scale,
        this.dashSize = source.dashSize, this.gapSize = source.gapSize, this;
    };
    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    }), Cache = {
        enabled: !1,
        files: {},
        add: function(key, file) {
            !1 !== this.enabled && (this.files[key] = file);
        },
        get: function(key) {
            if (!1 !== this.enabled) return this.files[key];
        },
        remove: function(key) {
            delete this.files[key];
        },
        clear: function() {
            this.files = {};
        }
    }, DefaultLoadingManager = new LoadingManager(), loading = {};
    Object.assign(FileLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url), url = this.manager.resolveURL(url);
            var scope = this, cached = Cache.get(url);
            if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
                onLoad && onLoad(cached), scope.manager.itemEnd(url);
            }, 0), cached;
            if (void 0 !== loading[url]) return void loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/, dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1], isBase64 = !!dataUriRegexResult[2], data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data), isBase64 && (data = window.atob(data));
                try {
                    var response, responseType = (this.responseType || "").toLowerCase();
                    switch (responseType) {
                      case "arraybuffer":
                      case "blob":
                        for (var view = new Uint8Array(data.length), i = 0; i < data.length; i++) view[i] = data.charCodeAt(i);
                        response = "blob" === responseType ? new Blob([ view.buffer ], {
                            type: mimeType
                        }) : view.buffer;
                        break;

                      case "document":
                        var parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;

                      case "json":
                        response = JSON.parse(data);
                        break;

                      default:
                        response = data;
                    }
                    window.setTimeout(function() {
                        onLoad && onLoad(response), scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function() {
                        onError && onError(error), scope.manager.itemEnd(url), scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                loading[url] = [], loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                var request = new XMLHttpRequest();
                request.open("GET", url, !0), request.addEventListener("load", function(event) {
                    var response = event.target.response;
                    Cache.add(url, response);
                    var callbacks = loading[url];
                    if (delete loading[url], 200 === this.status) {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            callback.onLoad && callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else if (0 === this.status) {
                        console.warn("THREE.FileLoader: HTTP Status 0 received.");
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            callback.onLoad && callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            callback.onError && callback.onError(event);
                        }
                        scope.manager.itemEnd(url), scope.manager.itemError(url);
                    }
                }, !1), request.addEventListener("progress", function(event) {
                    for (var callbacks = loading[url], i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        callback.onProgress && callback.onProgress(event);
                    }
                }, !1), request.addEventListener("error", function(event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        callback.onError && callback.onError(event);
                    }
                    scope.manager.itemEnd(url), scope.manager.itemError(url);
                }, !1), void 0 !== this.responseType && (request.responseType = this.responseType),
                void 0 !== this.withCredentials && (request.withCredentials = this.withCredentials),
                request.overrideMimeType && request.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (var header in this.requestHeader) request.setRequestHeader(header, this.requestHeader[header]);
                request.send(null);
            }
            return scope.manager.itemStart(url), request;
        },
        setPath: function(value) {
            return this.path = value, this;
        },
        setResponseType: function(value) {
            return this.responseType = value, this;
        },
        setWithCredentials: function(value) {
            return this.withCredentials = value, this;
        },
        setMimeType: function(value) {
            return this.mimeType = value, this;
        },
        setRequestHeader: function(value) {
            return this.requestHeader = value, this;
        }
    }), Object.assign(CompressedTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, images = [], texture = new CompressedTexture();
            texture.image = images;
            var loader = new FileLoader(this.manager);
            if (loader.setPath(this.path), loader.setResponseType("arraybuffer"), Array.isArray(url)) for (var loaded = 0, i = 0, il = url.length; i < il; ++i) !function(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, !0);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    }, 6 === (loaded += 1) && (1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter),
                    texture.format = texDatas.format, texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, onProgress, onError);
            }(i); else loader.load(url, function(buffer) {
                var texDatas = scope._parser(buffer, !0);
                if (texDatas.isCubemap) for (var faces = texDatas.mipmaps.length / texDatas.mipmapCount, f = 0; f < faces; f++) {
                    images[f] = {
                        mipmaps: []
                    };
                    for (var i = 0; i < texDatas.mipmapCount; i++) images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]),
                    images[f].format = texDatas.format, images[f].width = texDatas.width, images[f].height = texDatas.height;
                } else texture.image.width = texDatas.width, texture.image.height = texDatas.height,
                texture.mipmaps = texDatas.mipmaps;
                1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter), texture.format = texDatas.format,
                texture.needsUpdate = !0, onLoad && onLoad(texture);
            }, onProgress, onError);
            return texture;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(DataTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texture = new DataTexture(), loader = new FileLoader(this.manager);
            return loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                texData && (void 0 !== texData.image ? texture.image = texData.image : void 0 !== texData.data && (texture.image.width = texData.width,
                texture.image.height = texData.height, texture.image.data = texData.data), texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping,
                texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping,
                texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : LinearFilter,
                texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter,
                texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1, void 0 !== texData.format && (texture.format = texData.format),
                void 0 !== texData.type && (texture.type = texData.type), void 0 !== texData.mipmaps && (texture.mipmaps = texData.mipmaps),
                1 === texData.mipmapCount && (texture.minFilter = LinearFilter), texture.needsUpdate = !0,
                onLoad && onLoad(texture, texData));
            }, onProgress, onError), texture;
        }
    }), Object.assign(ImageLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(url, onLoad, onProgress, onError) {
            void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url), url = this.manager.resolveURL(url);
            var scope = this, cached = Cache.get(url);
            if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
                onLoad && onLoad(cached), scope.manager.itemEnd(url);
            }, 0), cached;
            var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return image.addEventListener("load", function() {
                Cache.add(url, this), onLoad && onLoad(this), scope.manager.itemEnd(url);
            }, !1), image.addEventListener("error", function(event) {
                onError && onError(event), scope.manager.itemEnd(url), scope.manager.itemError(url);
            }, !1), "data:" !== url.substr(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin),
            scope.manager.itemStart(url), image.src = url, image;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(CubeTextureLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture(), loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
            for (var loaded = 0, i = 0; i < urls.length; ++i) !function(i) {
                loader.load(urls[i], function(image) {
                    texture.images[i] = image, 6 == ++loaded && (texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, void 0, onError);
            }(i);
            return texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(TextureLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(url, onLoad, onProgress, onError) {
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
            var texture = new Texture();
            return texture.image = loader.load(url, function() {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || 0 === url.search(/^data\:image\/jpeg/);
                texture.format = isJPEG ? RGBFormat : RGBAFormat, texture.needsUpdate = !0, void 0 !== onLoad && onLoad(texture);
            }, onProgress, onError), texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: !0,
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.color.copy(source.color),
            this.intensity = source.intensity, this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.color = this.color.getHex(), data.object.intensity = this.intensity,
            void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle),
            void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data;
        }
    }), HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor),
            this;
        }
    }), Object.assign(LightShadow.prototype, {
        copy: function(source) {
            return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius,
            this.mapSize.copy(source.mapSize), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var object = {};
            return 0 !== this.bias && (object.bias = this.bias), 1 !== this.radius && (object.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()),
            object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object;
        }
    }), SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: !0,
        update: function(light) {
            var camera = this.camera, fov = 2 * _Math.RAD2DEG * light.angle, aspect = this.mapSize.width / this.mapSize.height, far = light.distance || camera.far;
            fov === camera.fov && aspect === camera.aspect && far === camera.far || (camera.fov = fov,
            camera.aspect = aspect, camera.far = far, camera.updateProjectionMatrix());
        }
    }), SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance,
            this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay,
            this.target = source.target.clone(), this.shadow = source.shadow.clone(), this;
        }
    }), PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance,
            this.decay = source.decay, this.shadow = source.shadow.clone(), this;
        }
    }), DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    }), DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.target = source.target.clone(),
            this.shadow = source.shadow.clone(), this;
        }
    }), AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: !0
    }), RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.width = source.width, this.height = source.height,
            this;
        },
        toJSON: function(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            return data.object.width = this.width, data.object.height = this.height, data;
        }
    });
    var AnimationUtils = {
        arraySlice: function(array, from, to) {
            return AnimationUtils.isTypedArray(array) ? new array.constructor(array.subarray(from, void 0 !== to ? to : array.length)) : array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
            return !array || !forceClone && array.constructor === type ? array : "number" == typeof type.BYTES_PER_ELEMENT ? new type(array) : Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            for (var n = times.length, result = new Array(n), i = 0; i !== n; ++i) result[i] = i;
            return result.sort(compareTime), result;
        },
        sortedArray: function(values, stride, order) {
            for (var nValues = values.length, result = new values.constructor(nValues), i = 0, dstOffset = 0; dstOffset !== nValues; ++i) for (var srcOffset = order[i] * stride, j = 0; j !== stride; ++j) result[dstOffset++] = values[srcOffset + j];
            return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
            for (var i = 1, key = jsonKeys[0]; void 0 !== key && void 0 === key[valuePropertyName]; ) key = jsonKeys[i++];
            if (void 0 !== key) {
                var value = key[valuePropertyName];
                if (void 0 !== value) if (Array.isArray(value)) do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), values.push.apply(values, value)),
                    key = jsonKeys[i++];
                } while (void 0 !== key); else if (void 0 !== value.toArray) do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), value.toArray(values, values.length)),
                    key = jsonKeys[i++];
                } while (void 0 !== key); else do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), values.push(value)),
                    key = jsonKeys[i++];
                } while (void 0 !== key);
            }
        }
    };
    Object.assign(Interpolant.prototype, {
        evaluate: function(t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2; ;) {
                                if (void 0 === t1) {
                                    if (t < t0) break forward_scan;
                                    return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt) break;
                                if (t0 = t1, t1 = pp[++i1], t < t1) break seek;
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        {
                            if (t >= t0) break validate_interval;
                            var t1global = pp[1];
                            t < t1global && (i1 = 2, t0 = t1global);
                            for (var giveUpAt = i1 - 2; ;) {
                                if (void 0 === t0) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                                if (i1 === giveUpAt) break;
                                if (t1 = t0, t0 = pp[--i1 - 1], t >= t0) break seek;
                            }
                            right = i1, i1 = 0;
                        }
                    }
                    for (;i1 < right; ) {
                        var mid = i1 + right >>> 1;
                        t < pp[mid] ? right = mid : i1 = mid + 1;
                    }
                    if (t1 = pp[i1], void 0 === (t0 = pp[i1 - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                    if (void 0 === t1) return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t0, t);
                }
                this._cachedIndex = i1, this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(index) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride, i = 0; i !== stride; ++i) result[i] = values[offset + i];
            return result;
        },
        interpolate_: function() {
            throw new Error("call to abstract method");
        },
        intervalChanged_: function() {}
    }), //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_
    }), CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function(i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (void 0 === tPrev) switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1, tPrev = 2 * t0 - t1;
                break;

              case WrapAroundEnding:
                iPrev = pp.length - 2, tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;

              default:
                iPrev = i1, tPrev = t1;
            }
            if (void 0 === tNext) switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1, tNext = 2 * t1 - t0;
                break;

              case WrapAroundEnding:
                iNext = 1, tNext = t1 + pp[1] - pp[0];
                break;

              default:
                iNext = i1 - 1, tNext = t0;
            }
            var halfDt = .5 * (t1 - t0), stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev), this._weightNext = halfDt / (tNext - t1),
            this._offsetPrev = iPrev * stride, this._offsetNext = iNext * stride;
        },
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p, sP = -wP * ppp + 2 * wP * pp - wP * p, s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1, s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p, sN = wN * ppp - wN * pp, i = 0; i !== stride; ++i) result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            return result;
        }
    }), LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1, i = 0; i !== stride; ++i) result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            return result;
        }
    }), DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function(i1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    var KeyframeTrackPrototype;
    KeyframeTrackPrototype = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function(interpolation) {
            var factoryMethod;
            switch (interpolation) {
              case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;

              case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;

              case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === factoryMethod) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (interpolation === this.DefaultInterpolation) throw new Error(message);
                    this.setInterpolation(this.DefaultInterpolation);
                }
                return void console.warn("THREE.KeyframeTrackPrototype:", message);
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;

              case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;

              case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(timeOffset) {
            if (0 !== timeOffset) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] += timeOffset;
            return this;
        },
        scale: function(timeScale) {
            if (1 !== timeScale) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] *= timeScale;
            return this;
        },
        trim: function(startTime, endTime) {
            for (var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1; from !== nKeys && times[from] < startTime; ) ++from;
            for (;-1 !== to && times[to] > endTime; ) --to;
            if (++to, 0 !== from || to !== nKeys) {
                from >= to && (to = Math.max(to, 1), from = to - 1);
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to), this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function() {
            var valid = !0, valueSize = this.getValueSize();
            valueSize - Math.floor(valueSize) != 0 && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this),
            valid = !1);
            var times = this.times, values = this.values, nKeys = times.length;
            0 === nKeys && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this),
            valid = !1);
            for (var prevTime = null, i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if ("number" == typeof currTime && isNaN(currTime)) {
                    console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, i, currTime),
                    valid = !1;
                    break;
                }
                if (null !== prevTime && prevTime > currTime) {
                    console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, i, currTime, prevTime),
                    valid = !1;
                    break;
                }
                prevTime = currTime;
            }
            if (void 0 !== values && AnimationUtils.isTypedArray(values)) for (var i = 0, n = values.length; i !== n; ++i) {
                var value = values[i];
                if (isNaN(value)) {
                    console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, i, value),
                    valid = !1;
                    break;
                }
            }
            return valid;
        },
        optimize: function() {
            for (var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1, i = 1; i < lastIndex; ++i) {
                var keep = !1, time = times[i];
                if (time !== times[i + 1] && (1 !== i || time !== time[0])) if (smoothInterpolation) keep = !0; else for (var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride, j = 0; j !== stride; ++j) {
                    var value = values[offset + j];
                    if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = !0;
                        break;
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        for (var readOffset = i * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
            }
            return writeIndex !== times.length && (this.times = AnimationUtils.arraySlice(times, 0, writeIndex),
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)), this;
        }
    }, VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: "vector"
    }), QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0), end = offset + stride; offset !== end; offset += 4) Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            return result;
        }
    }), QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: "quaternion",
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: void 0
    }), NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: "number"
    }), StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: "color"
    }), KeyframeTrack.prototype = KeyframeTrackPrototype, KeyframeTrackPrototype.constructor = KeyframeTrack,
    Object.assign(KeyframeTrack, {
        parse: function(json) {
            if (void 0 === json.type) throw new Error("track type undefined, can not parse");
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (void 0 === json.times) {
                var times = [], values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, "value"), json.times = times,
                json.values = values;
            }
            return void 0 !== trackType.parse ? trackType.parse(json) : new trackType(json.name, json.times, json.values, json.interpolation);
        },
        toJSON: function(track) {
            var json, trackType = track.constructor;
            if (void 0 !== trackType.toJSON) json = trackType.toJSON(track); else {
                json = {
                    name: track.name,
                    times: AnimationUtils.convertArray(track.times, Array),
                    values: AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation);
            }
            return json.type = track.ValueTypeName, json;
        },
        _getTrackTypeForValueTypeName: function(typeName) {
            switch (typeName.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return NumberKeyframeTrack;

              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return VectorKeyframeTrack;

              case "color":
                return ColorKeyframeTrack;

              case "quaternion":
                return QuaternionKeyframeTrack;

              case "bool":
              case "boolean":
                return BooleanKeyframeTrack;

              case "string":
                return StringKeyframeTrack;
            }
            throw new Error("Unsupported typeName: " + typeName);
        }
    }), Object.assign(AnimationClip, {
        parse: function(json) {
            for (var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1), i = 0, n = jsonTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function(clip) {
            for (var tracks = [], clipTracks = clip.tracks, json = {
                name: clip.name,
                duration: clip.duration,
                tracks: tracks
            }, i = 0, n = clipTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            return json;
        },
        CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
            for (var numMorphTargets = morphTargetSequence.length, tracks = [], i = 0; i < numMorphTargets; i++) {
                var times = [], values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets),
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order), values = AnimationUtils.sortedArray(values, 1, order),
                noLoop || 0 !== times[0] || (times.push(numMorphTargets), values.push(values[0])),
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) if (clipArray[i].name === name) return clipArray[i];
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
            for (var animationToMorphTargets = {}, pattern = /^([\w-]*?)([\d]+)$/, i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i], parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1], animationMorphTargets = animationToMorphTargets[name];
                    animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []),
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            return clips;
        },
        parseAnimation: function(animation, bones) {
            if (!animation) return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
            for (var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (0 !== animationKeys.length) {
                    var times = [], values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName), 0 !== times.length && destTracks.push(new trackType(trackName, times, values));
                }
            }, tracks = [], clipName = animation.name || "default", duration = animation.length || -1, fps = animation.fps || 30, hierarchyTracks = animation.hierarchy || [], h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (animationKeys && 0 !== animationKeys.length) if (animationKeys[0].morphTargets) {
                    for (var morphTargetNames = {}, k = 0; k < animationKeys.length; k++) if (animationKeys[k].morphTargets) for (var m = 0; m < animationKeys[k].morphTargets.length; m++) morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                    for (var morphTargetName in morphTargetNames) {
                        for (var times = [], values = [], m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time), values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1);
                } else {
                    var boneName = ".bones[" + bones[h].name + "]";
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks),
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks),
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
                }
            }
            return 0 === tracks.length ? null : new AnimationClip(clipName, duration, tracks);
        }
    }), Object.assign(AnimationClip.prototype, {
        resetDuration: function() {
            for (var tracks = this.tracks, duration = 0, i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
            return this;
        },
        optimize: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
            return this;
        }
    }), Object.assign(MaterialLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function(value) {
            this.textures = value;
        },
        parse: function(json) {
            function getTexture(name) {
                return void 0 === textures[name] && console.warn("THREE.MaterialLoader: Undefined texture", name),
                textures[name];
            }
            var textures = this.textures, material = new Materials[json.type]();
            if (void 0 !== json.uuid && (material.uuid = json.uuid), void 0 !== json.name && (material.name = json.name),
            void 0 !== json.color && material.color.setHex(json.color), void 0 !== json.roughness && (material.roughness = json.roughness),
            void 0 !== json.metalness && (material.metalness = json.metalness), void 0 !== json.emissive && material.emissive.setHex(json.emissive),
            void 0 !== json.specular && material.specular.setHex(json.specular), void 0 !== json.shininess && (material.shininess = json.shininess),
            void 0 !== json.clearCoat && (material.clearCoat = json.clearCoat), void 0 !== json.clearCoatRoughness && (material.clearCoatRoughness = json.clearCoatRoughness),
            void 0 !== json.uniforms && (material.uniforms = json.uniforms), void 0 !== json.vertexShader && (material.vertexShader = json.vertexShader),
            void 0 !== json.fragmentShader && (material.fragmentShader = json.fragmentShader),
            void 0 !== json.vertexColors && (material.vertexColors = json.vertexColors), void 0 !== json.fog && (material.fog = json.fog),
            void 0 !== json.flatShading && (material.flatShading = json.flatShading), void 0 !== json.blending && (material.blending = json.blending),
            void 0 !== json.side && (material.side = json.side), void 0 !== json.opacity && (material.opacity = json.opacity),
            void 0 !== json.transparent && (material.transparent = json.transparent), void 0 !== json.alphaTest && (material.alphaTest = json.alphaTest),
            void 0 !== json.depthTest && (material.depthTest = json.depthTest), void 0 !== json.depthWrite && (material.depthWrite = json.depthWrite),
            void 0 !== json.colorWrite && (material.colorWrite = json.colorWrite), void 0 !== json.wireframe && (material.wireframe = json.wireframe),
            void 0 !== json.wireframeLinewidth && (material.wireframeLinewidth = json.wireframeLinewidth),
            void 0 !== json.wireframeLinecap && (material.wireframeLinecap = json.wireframeLinecap),
            void 0 !== json.wireframeLinejoin && (material.wireframeLinejoin = json.wireframeLinejoin),
            void 0 !== json.rotation && (material.rotation = json.rotation), 1 !== json.linewidth && (material.linewidth = json.linewidth),
            void 0 !== json.dashSize && (material.dashSize = json.dashSize), void 0 !== json.gapSize && (material.gapSize = json.gapSize),
            void 0 !== json.scale && (material.scale = json.scale), void 0 !== json.skinning && (material.skinning = json.skinning),
            void 0 !== json.morphTargets && (material.morphTargets = json.morphTargets), void 0 !== json.dithering && (material.dithering = json.dithering),
            void 0 !== json.visible && (material.visible = json.visible), void 0 !== json.userData && (material.userData = json.userData),
            void 0 !== json.shading && (material.flatShading = 1 === json.shading), void 0 !== json.size && (material.size = json.size),
            void 0 !== json.sizeAttenuation && (material.sizeAttenuation = json.sizeAttenuation),
            void 0 !== json.map && (material.map = getTexture(json.map)), void 0 !== json.alphaMap && (material.alphaMap = getTexture(json.alphaMap),
            material.transparent = !0), void 0 !== json.bumpMap && (material.bumpMap = getTexture(json.bumpMap)),
            void 0 !== json.bumpScale && (material.bumpScale = json.bumpScale), void 0 !== json.normalMap && (material.normalMap = getTexture(json.normalMap)),
            void 0 !== json.normalScale) {
                var normalScale = json.normalScale;
                !1 === Array.isArray(normalScale) && (normalScale = [ normalScale, normalScale ]),
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            return void 0 !== json.displacementMap && (material.displacementMap = getTexture(json.displacementMap)),
            void 0 !== json.displacementScale && (material.displacementScale = json.displacementScale),
            void 0 !== json.displacementBias && (material.displacementBias = json.displacementBias),
            void 0 !== json.roughnessMap && (material.roughnessMap = getTexture(json.roughnessMap)),
            void 0 !== json.metalnessMap && (material.metalnessMap = getTexture(json.metalnessMap)),
            void 0 !== json.emissiveMap && (material.emissiveMap = getTexture(json.emissiveMap)),
            void 0 !== json.emissiveIntensity && (material.emissiveIntensity = json.emissiveIntensity),
            void 0 !== json.specularMap && (material.specularMap = getTexture(json.specularMap)),
            void 0 !== json.envMap && (material.envMap = getTexture(json.envMap)), void 0 !== json.reflectivity && (material.reflectivity = json.reflectivity),
            void 0 !== json.lightMap && (material.lightMap = getTexture(json.lightMap)), void 0 !== json.lightMapIntensity && (material.lightMapIntensity = json.lightMapIntensity),
            void 0 !== json.aoMap && (material.aoMap = getTexture(json.aoMap)), void 0 !== json.aoMapIntensity && (material.aoMapIntensity = json.aoMapIntensity),
            void 0 !== json.gradientMap && (material.gradientMap = getTexture(json.gradientMap)),
            material;
        }
    }), Object.assign(BufferGeometryLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function(json) {
            var geometry = new BufferGeometry(), index = json.data.index;
            if (void 0 !== index) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (void 0 !== groups) for (var i = 0, n = groups.length; i !== n; ++i) {
                var group = groups[i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingSphere = json.data.boundingSphere;
            if (void 0 !== boundingSphere) {
                var center = new Vector3();
                void 0 !== boundingSphere.center && center.fromArray(boundingSphere.center), geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    });
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Loader.Handlers = {
        handlers: [],
        add: function(regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function(file) {
            for (var handlers = this.handlers, i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i], loader = handlers[i + 1];
                if (regex.test(file)) return loader;
            }
            return null;
        }
    }, Object.assign(Loader.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function(url) {
            var parts = url.split("/");
            return 1 === parts.length ? "./" : (parts.pop(), parts.join("/") + "/");
        },
        initMaterials: function(materials, texturePath, crossOrigin) {
            for (var array = [], i = 0; i < materials.length; ++i) array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            return array;
        },
        createMaterial: function() {
            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            }, color = new Color(), textureLoader = new TextureLoader(), materialLoader = new MaterialLoader();
            return function(m, texturePath, crossOrigin) {
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var texture, fullPath = texturePath + path, loader = Loader.Handlers.get(fullPath);
                    null !== loader ? texture = loader.load(fullPath) : (textureLoader.setCrossOrigin(crossOrigin),
                    texture = textureLoader.load(fullPath)), void 0 !== repeat && (texture.repeat.fromArray(repeat),
                    1 !== repeat[0] && (texture.wrapS = RepeatWrapping), 1 !== repeat[1] && (texture.wrapT = RepeatWrapping)),
                    void 0 !== offset && texture.offset.fromArray(offset), void 0 !== wrap && ("repeat" === wrap[0] && (texture.wrapS = RepeatWrapping),
                    "mirror" === wrap[0] && (texture.wrapS = MirroredRepeatWrapping), "repeat" === wrap[1] && (texture.wrapT = RepeatWrapping),
                    "mirror" === wrap[1] && (texture.wrapT = MirroredRepeatWrapping)), void 0 !== anisotropy && (texture.anisotropy = anisotropy);
                    var uuid = _Math.generateUUID();
                    return textures[uuid] = texture, uuid;
                }
                var textures = {}, json = {
                    uuid: _Math.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                      case "DbgColor":
                      case "DbgIndex":
                      case "opticalDensity":
                      case "illumination":
                        break;

                      case "DbgName":
                        json.name = value;
                        break;

                      case "blending":
                        json.blending = BlendingMode[value];
                        break;

                      case "colorAmbient":
                      case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                        break;

                      case "colorDiffuse":
                        json.color = color.fromArray(value).getHex();
                        break;

                      case "colorSpecular":
                        json.specular = color.fromArray(value).getHex();
                        break;

                      case "colorEmissive":
                        json.emissive = color.fromArray(value).getHex();
                        break;

                      case "specularCoef":
                        json.shininess = value;
                        break;

                      case "shading":
                        "basic" === value.toLowerCase() && (json.type = "MeshBasicMaterial"), "phong" === value.toLowerCase() && (json.type = "MeshPhongMaterial"),
                        "standard" === value.toLowerCase() && (json.type = "MeshStandardMaterial");
                        break;

                      case "mapDiffuse":
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;

                      case "mapDiffuseRepeat":
                      case "mapDiffuseOffset":
                      case "mapDiffuseWrap":
                      case "mapDiffuseAnisotropy":
                        break;

                      case "mapEmissive":
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;

                      case "mapEmissiveRepeat":
                      case "mapEmissiveOffset":
                      case "mapEmissiveWrap":
                      case "mapEmissiveAnisotropy":
                        break;

                      case "mapLight":
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;

                      case "mapLightRepeat":
                      case "mapLightOffset":
                      case "mapLightWrap":
                      case "mapLightAnisotropy":
                        break;

                      case "mapAO":
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;

                      case "mapAORepeat":
                      case "mapAOOffset":
                      case "mapAOWrap":
                      case "mapAOAnisotropy":
                        break;

                      case "mapBump":
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;

                      case "mapBumpScale":
                        json.bumpScale = value;
                        break;

                      case "mapBumpRepeat":
                      case "mapBumpOffset":
                      case "mapBumpWrap":
                      case "mapBumpAnisotropy":
                        break;

                      case "mapNormal":
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;

                      case "mapNormalFactor":
                        json.normalScale = [ value, value ];
                        break;

                      case "mapNormalRepeat":
                      case "mapNormalOffset":
                      case "mapNormalWrap":
                      case "mapNormalAnisotropy":
                        break;

                      case "mapSpecular":
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;

                      case "mapSpecularRepeat":
                      case "mapSpecularOffset":
                      case "mapSpecularWrap":
                      case "mapSpecularAnisotropy":
                        break;

                      case "mapMetalness":
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;

                      case "mapMetalnessRepeat":
                      case "mapMetalnessOffset":
                      case "mapMetalnessWrap":
                      case "mapMetalnessAnisotropy":
                        break;

                      case "mapRoughness":
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;

                      case "mapRoughnessRepeat":
                      case "mapRoughnessOffset":
                      case "mapRoughnessWrap":
                      case "mapRoughnessAnisotropy":
                        break;

                      case "mapAlpha":
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;

                      case "mapAlphaRepeat":
                      case "mapAlphaOffset":
                      case "mapAlphaWrap":
                      case "mapAlphaAnisotropy":
                        break;

                      case "flipSided":
                        json.side = BackSide;
                        break;

                      case "doubleSided":
                        json.side = DoubleSide;
                        break;

                      case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                        json.opacity = value;
                        break;

                      case "depthTest":
                      case "depthWrite":
                      case "colorWrite":
                      case "opacity":
                      case "reflectivity":
                      case "transparent":
                      case "visible":
                      case "wireframe":
                        json[name] = value;
                        break;

                      case "vertexColors":
                        !0 === value && (json.vertexColors = VertexColors), "face" === value && (json.vertexColors = FaceColors);
                        break;

                      default:
                        console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                    }
                }
                return "MeshBasicMaterial" === json.type && delete json.emissive, "MeshPhongMaterial" !== json.type && delete json.specular,
                json.opacity < 1 && (json.transparent = !0), materialLoader.setTextures(textures),
                materialLoader.parse(json);
            };
        }()
    }), Object.assign(JSONLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texturePath = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Loader.prototype.extractUrlBase(url), loader = new FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                var json = JSON.parse(text), metadata = json.metadata;
                if (void 0 !== metadata) {
                    var type = metadata.type;
                    if (void 0 !== type) {
                        if ("object" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.");
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        parse: function() {
            function parseModel(json, geometry) {
                function isBitSet(value, position) {
                    return value & 1 << position;
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, scale = json.scale, nUvLayers = 0;
                if (void 0 !== json.uvs) {
                    for (i = 0; i < json.uvs.length; i++) json.uvs[i].length && nUvLayers++;
                    for (i = 0; i < nUvLayers; i++) geometry.faceVertexUvs[i] = [];
                }
                for (offset = 0, zLength = vertices.length; offset < zLength; ) vertex = new Vector3(),
                vertex.x = vertices[offset++] * scale, vertex.y = vertices[offset++] * scale, vertex.z = vertices[offset++] * scale,
                geometry.vertices.push(vertex);
                for (offset = 0, zLength = faces.length; offset < zLength; ) if (type = faces[offset++],
                isQuad = isBitSet(type, 0), hasMaterial = isBitSet(type, 1), hasFaceVertexUv = isBitSet(type, 3),
                hasFaceNormal = isBitSet(type, 4), hasFaceVertexNormal = isBitSet(type, 5), hasFaceColor = isBitSet(type, 6),
                hasFaceVertexColor = isBitSet(type, 7), isQuad) {
                    if (faceA = new Face3(), faceA.a = faces[offset], faceA.b = faces[offset + 1], faceA.c = faces[offset + 3],
                    faceB = new Face3(), faceB.a = faces[offset + 1], faceB.b = faces[offset + 2], faceB.c = faces[offset + 3],
                    offset += 4, hasMaterial && (materialIndex = faces[offset++], faceA.materialIndex = materialIndex,
                    faceB.materialIndex = materialIndex), fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; i < nUvLayers; i++) for (uvLayer = json.uvs[i],
                    geometry.faceVertexUvs[i][fi] = [], geometry.faceVertexUvs[i][fi + 1] = [], j = 0; j < 4; j++) uvIndex = faces[offset++],
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v),
                    2 !== j && geometry.faceVertexUvs[i][fi].push(uv), 0 !== j && geometry.faceVertexUvs[i][fi + 1].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]),
                    faceB.normal.copy(faceA.normal)), hasFaceVertexNormal) for (i = 0; i < 4; i++) normalIndex = 3 * faces[offset++],
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]),
                    2 !== i && faceA.vertexNormals.push(normal), 0 !== i && faceB.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], hex = colors[colorIndex], faceA.color.setHex(hex),
                    faceB.color.setHex(hex)), hasFaceVertexColor) for (i = 0; i < 4; i++) colorIndex = faces[offset++],
                    hex = colors[colorIndex], 2 !== i && faceA.vertexColors.push(new Color(hex)), 0 !== i && faceB.vertexColors.push(new Color(hex));
                    geometry.faces.push(faceA), geometry.faces.push(faceB);
                } else {
                    if (face = new Face3(), face.a = faces[offset++], face.b = faces[offset++], face.c = faces[offset++],
                    hasMaterial && (materialIndex = faces[offset++], face.materialIndex = materialIndex),
                    fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; i < nUvLayers; i++) for (uvLayer = json.uvs[i],
                    geometry.faceVertexUvs[i][fi] = [], j = 0; j < 3; j++) uvIndex = faces[offset++],
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v),
                    geometry.faceVertexUvs[i][fi].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex])),
                    hasFaceVertexNormal) for (i = 0; i < 3; i++) normalIndex = 3 * faces[offset++],
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]),
                    face.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], face.color.setHex(colors[colorIndex])),
                    hasFaceVertexColor) for (i = 0; i < 3; i++) colorIndex = faces[offset++], face.vertexColors.push(new Color(colors[colorIndex]));
                    geometry.faces.push(face);
                }
            }
            function parseSkin(json, geometry) {
                var influencesPerVertex = void 0 !== json.influencesPerVertex ? json.influencesPerVertex : 2;
                if (json.skinWeights) for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                    var x = json.skinWeights[i], y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0, z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0, w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                }
                if (json.skinIndices) for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                    var a = json.skinIndices[i], b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0, c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0, d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                }
                geometry.bones = json.bones, geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length) && console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
            }
            function parseMorphing(json, geometry) {
                var scale = json.scale;
                if (void 0 !== json.morphTargets) for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                    geometry.morphTargets[i] = {}, geometry.morphTargets[i].name = json.morphTargets[i].name,
                    geometry.morphTargets[i].vertices = [];
                    for (var dstVertices = geometry.morphTargets[i].vertices, srcVertices = json.morphTargets[i].vertices, v = 0, vl = srcVertices.length; v < vl; v += 3) {
                        var vertex = new Vector3();
                        vertex.x = srcVertices[v] * scale, vertex.y = srcVertices[v + 1] * scale, vertex.z = srcVertices[v + 2] * scale,
                        dstVertices.push(vertex);
                    }
                }
                if (void 0 !== json.morphColors && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var faces = geometry.faces, morphColors = json.morphColors[0].colors, i = 0, l = faces.length; i < l; i++) faces[i].color.fromArray(morphColors, 3 * i);
                }
            }
            function parseAnimations(json, geometry) {
                var outputAnimations = [], animations = [];
                void 0 !== json.animation && animations.push(json.animation), void 0 !== json.animations && (json.animations.length ? animations = animations.concat(json.animations) : animations.push(json.animations));
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    clip && outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                outputAnimations.length > 0 && (geometry.animations = outputAnimations);
            }
            return function(json, texturePath) {
                void 0 !== json.data && (json = json.data), void 0 !== json.scale ? json.scale = 1 / json.scale : json.scale = 1;
                var geometry = new Geometry();
                return parseModel(json, geometry), parseSkin(json, geometry), parseMorphing(json, geometry),
                parseAnimations(json, geometry), geometry.computeFaceNormals(), geometry.computeBoundingSphere(),
                void 0 === json.materials || 0 === json.materials.length ? {
                    geometry: geometry
                } : {
                    geometry: geometry,
                    materials: Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin)
                };
            };
        }()
    }), Object.assign(ObjectLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            "" === this.texturePath && (this.texturePath = url.substring(0, url.lastIndexOf("/") + 1));
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    return void 0 !== onError && onError(error), void console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                }
                var metadata = json.metadata;
                if (void 0 === metadata || void 0 === metadata.type || "geometry" === metadata.type.toLowerCase()) return void console.error("THREE.ObjectLoader: Can't load " + url + ". Use THREE.JSONLoader instead.");
                scope.parse(json, onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
        },
        parse: function(json, onLoad) {
            var geometries = this.parseGeometries(json.geometries), images = this.parseImages(json.images, function() {
                void 0 !== onLoad && onLoad(object);
            }), textures = this.parseTextures(json.textures, images), materials = this.parseMaterials(json.materials, textures), object = this.parseObject(json.object, geometries, materials);
            return json.animations && (object.animations = this.parseAnimations(json.animations)),
            void 0 !== json.images && 0 !== json.images.length || void 0 !== onLoad && onLoad(object),
            object;
        },
        parseGeometries: function(json) {
            var geometries = {};
            if (void 0 !== json) for (var geometryLoader = new JSONLoader(), bufferGeometryLoader = new BufferGeometryLoader(), i = 0, l = json.length; i < l; i++) {
                var geometry, data = json[i];
                switch (data.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                    break;

                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    break;

                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                    break;

                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    break;

                  case "DodecahedronGeometry":
                  case "DodecahedronBufferGeometry":
                  case "IcosahedronGeometry":
                  case "IcosahedronBufferGeometry":
                  case "OctahedronGeometry":
                  case "OctahedronBufferGeometry":
                  case "TetrahedronGeometry":
                  case "TetrahedronBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.detail);
                    break;

                  case "RingGeometry":
                  case "RingBufferGeometry":
                    geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                    break;

                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    break;

                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                    break;

                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                    break;

                  case "PolyhedronGeometry":
                  case "PolyhedronBufferGeometry":
                    geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                    break;

                  case "BufferGeometry":
                    geometry = bufferGeometryLoader.parse(data);
                    break;

                  case "Geometry":
                    geometry = geometryLoader.parse(data, this.texturePath).geometry;
                    break;

                  default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                    continue;
                }
                geometry.uuid = data.uuid, void 0 !== data.name && (geometry.name = data.name),
                geometries[data.uuid] = geometry;
            }
            return geometries;
        },
        parseMaterials: function(json, textures) {
            var materials = {};
            if (void 0 !== json) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if ("MultiMaterial" === data.type) {
                        for (var array = [], j = 0; j < data.materials.length; j++) array.push(loader.parse(data.materials[j]));
                        materials[data.uuid] = array;
                    } else materials[data.uuid] = loader.parse(data);
                }
            }
            return materials;
        },
        parseAnimations: function(json) {
            for (var animations = [], i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function(json, onLoad) {
            var scope = this, images = {};
            if (void 0 !== json && json.length > 0) {
                var manager = new LoadingManager(onLoad), loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i], path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = function(url) {
                        return scope.manager.itemStart(url), loader.load(url, function() {
                            scope.manager.itemEnd(url);
                        }, void 0, function() {
                            scope.manager.itemEnd(url), scope.manager.itemError(url);
                        });
                    }(path);
                }
            }
            return images;
        },
        parseTextures: function(json, images) {
            function parseConstant(value, type) {
                return "number" == typeof value ? value : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value),
                type[value]);
            }
            var textures = {};
            if (void 0 !== json) for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                void 0 === data.image && console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid),
                void 0 === images[data.image] && console.warn("THREE.ObjectLoader: Undefined image", data.image);
                var texture = new Texture(images[data.image]);
                texture.needsUpdate = !0, texture.uuid = data.uuid, void 0 !== data.name && (texture.name = data.name),
                void 0 !== data.mapping && (texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING)),
                void 0 !== data.offset && texture.offset.fromArray(data.offset), void 0 !== data.repeat && texture.repeat.fromArray(data.repeat),
                void 0 !== data.center && texture.center.fromArray(data.center), void 0 !== data.rotation && (texture.rotation = data.rotation),
                void 0 !== data.wrap && (texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING),
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)), void 0 !== data.minFilter && (texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER)),
                void 0 !== data.magFilter && (texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER)),
                void 0 !== data.anisotropy && (texture.anisotropy = data.anisotropy), void 0 !== data.flipY && (texture.flipY = data.flipY),
                textures[data.uuid] = texture;
            }
            return textures;
        },
        parseObject: function() {
            var matrix = new Matrix4();
            return function(data, geometries, materials) {
                function getGeometry(name) {
                    return void 0 === geometries[name] && console.warn("THREE.ObjectLoader: Undefined geometry", name),
                    geometries[name];
                }
                function getMaterial(name) {
                    if (void 0 !== name) {
                        if (Array.isArray(name)) {
                            for (var array = [], i = 0, l = name.length; i < l; i++) {
                                var uuid = name[i];
                                void 0 === materials[uuid] && console.warn("THREE.ObjectLoader: Undefined material", uuid),
                                array.push(materials[uuid]);
                            }
                            return array;
                        }
                        return void 0 === materials[name] && console.warn("THREE.ObjectLoader: Undefined material", name),
                        materials[name];
                    }
                }
                var object;
                switch (data.type) {
                  case "Scene":
                    object = new Scene(), void 0 !== data.background && Number.isInteger(data.background) && (object.background = new Color(data.background)),
                    void 0 !== data.fog && ("Fog" === data.fog.type ? object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far) : "FogExp2" === data.fog.type && (object.fog = new FogExp2(data.fog.color, data.fog.density)));
                    break;

                  case "PerspectiveCamera":
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far), void 0 !== data.focus && (object.focus = data.focus),
                    void 0 !== data.zoom && (object.zoom = data.zoom), void 0 !== data.filmGauge && (object.filmGauge = data.filmGauge),
                    void 0 !== data.filmOffset && (object.filmOffset = data.filmOffset), void 0 !== data.view && (object.view = Object.assign({}, data.view));
                    break;

                  case "OrthographicCamera":
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;

                  case "AmbientLight":
                    object = new AmbientLight(data.color, data.intensity);
                    break;

                  case "DirectionalLight":
                    object = new DirectionalLight(data.color, data.intensity);
                    break;

                  case "PointLight":
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;

                  case "RectAreaLight":
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;

                  case "SpotLight":
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;

                  case "HemisphereLight":
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;

                  case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");

                  case "Mesh":
                    var geometry = getGeometry(data.geometry), material = getMaterial(data.material);
                    object = geometry.bones && geometry.bones.length > 0 ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
                    break;

                  case "LOD":
                    object = new LOD();
                    break;

                  case "Line":
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;

                  case "LineLoop":
                    object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "LineSegments":
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "PointCloud":
                  case "Points":
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "Sprite":
                    object = new Sprite(getMaterial(data.material));
                    break;

                  case "Group":
                    object = new Group();
                    break;

                  default:
                    object = new Object3D();
                }
                if (object.uuid = data.uuid, void 0 !== data.name && (object.name = data.name),
                void 0 !== data.matrix ? (matrix.fromArray(data.matrix), matrix.decompose(object.position, object.quaternion, object.scale)) : (void 0 !== data.position && object.position.fromArray(data.position),
                void 0 !== data.rotation && object.rotation.fromArray(data.rotation), void 0 !== data.quaternion && object.quaternion.fromArray(data.quaternion),
                void 0 !== data.scale && object.scale.fromArray(data.scale)), void 0 !== data.castShadow && (object.castShadow = data.castShadow),
                void 0 !== data.receiveShadow && (object.receiveShadow = data.receiveShadow), data.shadow && (void 0 !== data.shadow.bias && (object.shadow.bias = data.shadow.bias),
                void 0 !== data.shadow.radius && (object.shadow.radius = data.shadow.radius), void 0 !== data.shadow.mapSize && object.shadow.mapSize.fromArray(data.shadow.mapSize),
                void 0 !== data.shadow.camera && (object.shadow.camera = this.parseObject(data.shadow.camera))),
                void 0 !== data.visible && (object.visible = data.visible), void 0 !== data.userData && (object.userData = data.userData),
                void 0 !== data.children) for (var children = data.children, i = 0; i < children.length; i++) object.add(this.parseObject(children[i], geometries, materials));
                if ("LOD" === data.type) for (var levels = data.levels, l = 0; l < levels.length; l++) {
                    var level = levels[l], child = object.getObjectByProperty("uuid", level.object);
                    void 0 !== child && object.addLevel(child, level.distance);
                }
                return object;
            };
        }()
    });
    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    }, TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    }, TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    Object.assign(Curve.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        },
        getPointAt: function(u, optionalTarget) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t, optionalTarget);
        },
        getPoints: function(divisions) {
            void 0 === divisions && (divisions = 5);
            for (var points = [], d = 0; d <= divisions; d++) points.push(this.getPoint(d / divisions));
            return points;
        },
        getSpacedPoints: function(divisions) {
            void 0 === divisions && (divisions = 5);
            for (var points = [], d = 0; d <= divisions; d++) points.push(this.getPointAt(d / divisions));
            return points;
        },
        getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
            if (void 0 === divisions && (divisions = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var current, p, cache = [], last = this.getPoint(0), sum = 0;
            for (cache.push(0), p = 1; p <= divisions; p++) current = this.getPoint(p / divisions),
            sum += current.distanceTo(last), cache.push(sum), last = current;
            return this.cacheArcLengths = cache, cache;
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths();
        },
        getUtoTmapping: function(u, distance) {
            var targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
            targetArcLength = distance || u * arcLengths[il - 1];
            for (var comparison, low = 0, high = il - 1; low <= high; ) if (i = Math.floor(low + (high - low) / 2),
            (comparison = arcLengths[i] - targetArcLength) < 0) low = i + 1; else {
                if (!(comparison > 0)) {
                    high = i;
                    break;
                }
                high = i - 1;
            }
            if (i = high, arcLengths[i] === targetArcLength) return i / (il - 1);
            var lengthBefore = arcLengths[i];
            return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1);
        },
        getTangent: function(t) {
            var t1 = t - 1e-4, t2 = t + 1e-4;
            t1 < 0 && (t1 = 0), t2 > 1 && (t2 = 1);
            var pt1 = this.getPoint(t1);
            return this.getPoint(t2).clone().sub(pt1).normalize();
        },
        getTangentAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function(segments, closed) {
            var i, u, theta, normal = new Vector3(), tangents = [], normals = [], binormals = [], vec = new Vector3(), mat = new Matrix4();
            for (i = 0; i <= segments; i++) u = i / segments, tangents[i] = this.getTangentAt(u),
            tangents[i].normalize();
            normals[0] = new Vector3(), binormals[0] = new Vector3();
            var min = Number.MAX_VALUE, tx = Math.abs(tangents[0].x), ty = Math.abs(tangents[0].y), tz = Math.abs(tangents[0].z);
            for (tx <= min && (min = tx, normal.set(1, 0, 0)), ty <= min && (min = ty, normal.set(0, 1, 0)),
            tz <= min && normal.set(0, 0, 1), vec.crossVectors(tangents[0], normal).normalize(),
            normals[0].crossVectors(tangents[0], vec), binormals[0].crossVectors(tangents[0], normals[0]),
            i = 1; i <= segments; i++) normals[i] = normals[i - 1].clone(), binormals[i] = binormals[i - 1].clone(),
            vec.crossVectors(tangents[i - 1], tangents[i]), vec.length() > Number.EPSILON && (vec.normalize(),
            theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)), normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))),
            binormals[i].crossVectors(tangents[i], normals[i]);
            if (!0 === closed) for (theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1)),
            theta /= segments, tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0 && (theta = -theta),
            i = 1; i <= segments; i++) normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)),
            binormals[i].crossVectors(tangents[i], normals[i]);
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.arcLengthDivisions = source.arcLengthDivisions, this;
        }
    }), LineCurve.prototype = Object.create(Curve.prototype), LineCurve.prototype.constructor = LineCurve,
    LineCurve.prototype.isLineCurve = !0, LineCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        return 1 === t ? point.copy(this.v2) : (point.copy(this.v2).sub(this.v1), point.multiplyScalar(t).add(this.v1)),
        point;
    }, LineCurve.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }, LineCurve.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize();
    }, LineCurve.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v1.copy(source.v1), this.v2.copy(source.v2),
        this;
    }, CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function(curve) {
            this.curves.push(curve);
        },
        closePath: function() {
            var startPoint = this.curves[0].getPoint(0), endPoint = this.curves[this.curves.length - 1].getPoint(1);
            startPoint.equals(endPoint) || this.curves.push(new LineCurve(endPoint, startPoint));
        },
        getPoint: function(t) {
            for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length; ) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d, curve = this.curves[i], segmentLength = curve.getLength(), u = 0 === segmentLength ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var lengths = [], sums = 0, i = 0, l = this.curves.length; i < l; i++) sums += this.curves[i].getLength(),
            lengths.push(sums);
            return this.cacheLengths = lengths, lengths;
        },
        getSpacedPoints: function(divisions) {
            void 0 === divisions && (divisions = 40);
            for (var points = [], i = 0; i <= divisions; i++) points.push(this.getPoint(i / divisions));
            return this.autoClose && points.push(points[0]), points;
        },
        getPoints: function(divisions) {
            divisions = divisions || 12;
            for (var last, points = [], i = 0, curves = this.curves; i < curves.length; i++) for (var curve = curves[i], resolution = curve && curve.isEllipseCurve ? 2 * divisions : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions, pts = curve.getPoints(resolution), j = 0; j < pts.length; j++) {
                var point = pts[j];
                last && last.equals(point) || (points.push(point), last = point);
            }
            return this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]) && points.push(points[0]),
            points;
        },
        copy: function(source) {
            Curve.prototype.copy.call(this, source), this.curves = [];
            for (var i = 0, l = source.curves.length; i < l; i++) {
                var curve = source.curves[i];
                this.curves.push(curve.clone());
            }
            return this.autoClose = source.autoClose, this;
        }
    }), EllipseCurve.prototype = Object.create(Curve.prototype), EllipseCurve.prototype.constructor = EllipseCurve,
    EllipseCurve.prototype.isEllipseCurve = !0, EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
        for (var point = optionalTarget || new Vector2(), twoPi = 2 * Math.PI, deltaAngle = this.aEndAngle - this.aStartAngle, samePoints = Math.abs(deltaAngle) < Number.EPSILON; deltaAngle < 0; ) deltaAngle += twoPi;
        for (;deltaAngle > twoPi; ) deltaAngle -= twoPi;
        deltaAngle < Number.EPSILON && (deltaAngle = samePoints ? 0 : twoPi), !0 !== this.aClockwise || samePoints || (deltaAngle === twoPi ? deltaAngle = -twoPi : deltaAngle -= twoPi);
        var angle = this.aStartAngle + t * deltaAngle, x = this.aX + this.xRadius * Math.cos(angle), y = this.aY + this.yRadius * Math.sin(angle);
        if (0 !== this.aRotation) {
            var cos = Math.cos(this.aRotation), sin = Math.sin(this.aRotation), tx = x - this.aX, ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX, y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    }, EllipseCurve.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.aX = source.aX, this.aY = source.aY,
        this.xRadius = source.xRadius, this.yRadius = source.yRadius, this.aStartAngle = source.aStartAngle,
        this.aEndAngle = source.aEndAngle, this.aClockwise = source.aClockwise, this.aRotation = source.aRotation,
        this;
    }, SplineCurve.prototype = Object.create(Curve.prototype), SplineCurve.prototype.constructor = SplineCurve,
    SplineCurve.prototype.isSplineCurve = !0, SplineCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2(), points = this.points, p = (points.length - 1) * t, intPoint = Math.floor(p), weight = p - intPoint, p0 = points[0 === intPoint ? intPoint : intPoint - 1], p1 = points[intPoint], p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1], p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        return point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)),
        point;
    }, SplineCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source), this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        return this;
    }, CubicBezierCurve.prototype = Object.create(Curve.prototype), CubicBezierCurve.prototype.constructor = CubicBezierCurve,
    CubicBezierCurve.prototype.isCubicBezierCurve = !0, CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2(), v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y)),
        point;
    }, CubicBezierCurve.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v0.copy(source.v0), this.v1.copy(source.v1),
        this.v2.copy(source.v2), this.v3.copy(source.v3), this;
    }, QuadraticBezierCurve.prototype = Object.create(Curve.prototype), QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve,
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0, QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2(), v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y)),
        point;
    }, QuadraticBezierCurve.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v0.copy(source.v0), this.v1.copy(source.v1),
        this.v2.copy(source.v2), this;
    };
    var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
        setFromPoints: function(points) {
            this.moveTo(points[0].x, points[0].y);
            for (var i = 1, l = points.length; i < l; i++) this.lineTo(points[i].x, points[i].y);
        },
        moveTo: function(x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve), this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        splineThru: function(pts) {
            var npts = [ this.currentPoint.clone() ].concat(pts), curve = new SplineCurve(npts);
            this.curves.push(curve), this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                firstPoint.equals(this.currentPoint) || this.lineTo(firstPoint.x, firstPoint.y);
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        },
        copy: function(source) {
            return CurvePath.prototype.copy.call(this, source), this.currentPoint.copy(source.currentPoint),
            this;
        }
    });
    Path.prototype = PathPrototype, PathPrototype.constructor = Path, Shape.prototype = Object.assign(Object.create(PathPrototype), {
        constructor: Shape,
        getPointsHoles: function(divisions) {
            for (var holesPts = [], i = 0, l = this.holes.length; i < l; i++) holesPts[i] = this.holes[i].getPoints(divisions);
            return holesPts;
        },
        extractPoints: function(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        copy: function(source) {
            Path.prototype.copy.call(this, source), this.holes = [];
            for (var i = 0, l = source.holes.length; i < l; i++) {
                var hole = source.holes[i];
                this.holes.push(hole.clone());
            }
            return this;
        }
    }), Object.assign(ShapePath.prototype, {
        moveTo: function(x, y) {
            this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(x, y);
        },
        lineTo: function(x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function(pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                for (var shapes = [], i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i], tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves, shapes.push(tmpShape);
                }
                return shapes;
            }
            var isClockWise = ShapeUtils.isClockWise, subPaths = this.subPaths;
            if (0 === subPaths.length) return [];
            if (!0 === noHoles) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (1 === subPaths.length) return tmpPath = subPaths[0], tmpShape = new Shape(),
            tmpShape.curves = tmpPath.curves, shapes.push(tmpShape), shapes;
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var tmpPoints, betterShapeHoles = [], newShapes = [], newShapeHoles = [], mainIdx = 0;
            newShapes[mainIdx] = void 0, newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) tmpPath = subPaths[i], tmpPoints = tmpPath.getPoints(),
            solid = isClockWise(tmpPoints), solid = isCCW ? !solid : solid, solid ? (!holesFirst && newShapes[mainIdx] && mainIdx++,
            newShapes[mainIdx] = {
                s: new Shape(),
                p: tmpPoints
            }, newShapes[mainIdx].s.curves = tmpPath.curves, holesFirst && mainIdx++, newShapeHoles[mainIdx] = []) : newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                for (var ambiguous = !1, toChange = [], sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) betterShapeHoles[sIdx] = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) for (var sho = newShapeHoles[sIdx], hIdx = 0; hIdx < sho.length; hIdx++) {
                    for (var ho = sho[hIdx], hole_unassigned = !0, s2Idx = 0; s2Idx < newShapes.length; s2Idx++) (function(inPt, inPolygon) {
                        for (var polyLen = inPolygon.length, inside = !1, p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                            var edgeLowPt = inPolygon[p], edgeHighPt = inPolygon[q], edgeDx = edgeHighPt.x - edgeLowPt.x, edgeDy = edgeHighPt.y - edgeLowPt.y;
                            if (Math.abs(edgeDy) > Number.EPSILON) {
                                if (edgeDy < 0 && (edgeLowPt = inPolygon[q], edgeDx = -edgeDx, edgeHighPt = inPolygon[p],
                                edgeDy = -edgeDy), inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                                if (inPt.y === edgeLowPt.y) {
                                    if (inPt.x === edgeLowPt.x) return !0;
                                } else {
                                    var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                    if (0 === perpEdge) return !0;
                                    if (perpEdge < 0) continue;
                                    inside = !inside;
                                }
                            } else {
                                if (inPt.y !== edgeLowPt.y) continue;
                                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return !0;
                            }
                        }
                        return inside;
                    })(ho.p, newShapes[s2Idx].p) && (sIdx !== s2Idx && toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                    }), hole_unassigned ? (hole_unassigned = !1, betterShapeHoles[s2Idx].push(ho)) : ambiguous = !0);
                    hole_unassigned && betterShapeHoles[sIdx].push(ho);
                }
                toChange.length > 0 && (ambiguous || (newShapeHoles = betterShapeHoles));
            }
            for (var tmpHoles, i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s, shapes.push(tmpShape), tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) tmpShape.holes.push(tmpHoles[j].h);
            }
            return shapes;
        }
    }), Object.assign(Font.prototype, {
        isFont: !0,
        generateShapes: function(text, size, divisions) {
            function createPath(c, scale, offsetX, offsetY) {
                var glyph = data.glyphs[c] || data.glyphs["?"];
                if (glyph) {
                    var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, path = new ShapePath(), pts = [];
                    if (glyph.o) for (var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" ")), i = 0, l = outline.length; i < l; ) {
                        var action = outline[i++];
                        switch (action) {
                          case "m":
                            x = outline[i++] * scale + offsetX, y = outline[i++] * scale + offsetY, path.moveTo(x, y);
                            break;

                          case "l":
                            x = outline[i++] * scale + offsetX, y = outline[i++] * scale + offsetY, path.lineTo(x, y);
                            break;

                          case "q":
                            if (cpx = outline[i++] * scale + offsetX, cpy = outline[i++] * scale + offsetY,
                            cpx1 = outline[i++] * scale + offsetX, cpy1 = outline[i++] * scale + offsetY, path.quadraticCurveTo(cpx1, cpy1, cpx, cpy),
                            laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    QuadraticBezier(t, cpx0, cpx1, cpx), QuadraticBezier(t, cpy0, cpy1, cpy);
                                }
                            }
                            break;

                          case "b":
                            if (cpx = outline[i++] * scale + offsetX, cpy = outline[i++] * scale + offsetY,
                            cpx1 = outline[i++] * scale + offsetX, cpy1 = outline[i++] * scale + offsetY, cpx2 = outline[i++] * scale + offsetX,
                            cpy2 = outline[i++] * scale + offsetY, path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy),
                            laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    CubicBezier(t, cpx0, cpx1, cpx2, cpx), CubicBezier(t, cpy0, cpy1, cpy2, cpy);
                                }
                            }
                        }
                    }
                    return {
                        offsetX: glyph.ha * scale,
                        path: path
                    };
                }
            }
            void 0 === size && (size = 100), void 0 === divisions && (divisions = 4);
            for (var data = this.data, paths = function(text) {
                for (var chars = String(text).split(""), scale = size / data.resolution, line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale, offsetX = 0, offsetY = 0, paths = [], i = 0; i < chars.length; i++) {
                    var char = chars[i];
                    if ("\n" === char) offsetX = 0, offsetY -= line_height; else {
                        var ret = createPath(char, scale, offsetX, offsetY);
                        offsetX += ret.offsetX, paths.push(ret.path);
                    }
                }
                return paths;
            }(text), shapes = [], p = 0, pl = paths.length; p < pl; p++) Array.prototype.push.apply(shapes, paths[p].toShapes());
            return shapes;
        }
    }), Object.assign(FontLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, loader = new FileLoader(this.manager);
            loader.setPath(this.path), loader.load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                onLoad && onLoad(font);
            }, onProgress, onError);
        },
        parse: function(json) {
            return new Font(json);
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    });
    var context, AudioContext = {
        getContext: function() {
            return void 0 === context && (context = new (window.AudioContext || window.webkitAudioContext)()),
            context;
        },
        setContext: function(value) {
            context = value;
        }
    };
    Object.assign(AudioLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var loader = new FileLoader(this.manager);
            loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                AudioContext.getContext().decodeAudioData(buffer, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    }), Object.assign(StereoCamera.prototype, {
        update: function() {
            var instance, focus, fov, aspect, near, far, zoom, eyeSep, eyeRight = new Matrix4(), eyeLeft = new Matrix4();
            return function(camera) {
                if (instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep) {
                    instance = this, focus = camera.focus, fov = camera.fov, aspect = camera.aspect * this.aspect,
                    near = camera.near, far = camera.far, zoom = camera.zoom;
                    var projectionMatrix = camera.projectionMatrix.clone();
                    eyeSep = this.eyeSep / 2;
                    var xmin, xmax, eyeSepOnProjection = eyeSep * near / focus, ymax = near * Math.tan(_Math.DEG2RAD * fov * .5) / zoom;
                    eyeLeft.elements[12] = -eyeSep, eyeRight.elements[12] = eyeSep, xmin = -ymax * aspect + eyeSepOnProjection,
                    xmax = ymax * aspect + eyeSepOnProjection, projectionMatrix.elements[0] = 2 * near / (xmax - xmin),
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), this.cameraL.projectionMatrix.copy(projectionMatrix),
                    xmin = -ymax * aspect - eyeSepOnProjection, xmax = ymax * aspect - eyeSepOnProjection,
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin), projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin),
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft), this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        }()
    }), CubeCamera.prototype = Object.create(Object3D.prototype), CubeCamera.prototype.constructor = CubeCamera,
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination), this.filter = null);
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(value) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = value, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(value) {
            this.gain.gain.value = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3(), quaternion = new Quaternion(), scale = new Vector3(), orientation = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener, up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale), orientation.set(0, 0, -1).applyQuaternion(quaternion),
                listener.positionX ? (listener.positionX.setValueAtTime(position.x, this.context.currentTime),
                listener.positionY.setValueAtTime(position.y, this.context.currentTime), listener.positionZ.setValueAtTime(position.z, this.context.currentTime),
                listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime), listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime),
                listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime), listener.upX.setValueAtTime(up.x, this.context.currentTime),
                listener.upY.setValueAtTime(up.y, this.context.currentTime), listener.upZ.setValueAtTime(up.z, this.context.currentTime)) : (listener.setPosition(position.x, position.y, position.z),
                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z));
            };
        }()
    }), Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(audioNode) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = audioNode,
            this.connect(), this;
        },
        setBuffer: function(audioBuffer) {
            return this.buffer = audioBuffer, this.sourceType = "buffer", this.autoplay && this.play(),
            this;
        },
        play: function() {
            if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
            var source = this.context.createBufferSource();
            return source.buffer = this.buffer, source.loop = this.loop, source.onended = this.onEnded.bind(this),
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime,
            source.start(this.startTime, this.offset), this.isPlaying = !0, this.source = source,
            this.connect();
        },
        pause: function() {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (!0 === this.isPlaying && (this.source.stop(),
            this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
            this.isPlaying = !1), this);
        },
        stop: function() {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
            this.offset = 0, this.isPlaying = !1, this);
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) this.filters[i - 1].connect(this.filters[i]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) this.filters[i - 1].disconnect(this.filters[i]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(value) {
            return value || (value = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = value,
            this.connect()) : this.filters = value, this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(filter) {
            return this.setFilters(filter ? [ filter ] : []);
        },
        setPlaybackRate: function(value) {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = value,
            !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime),
            this);
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = !1;
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop;
        },
        setLoop: function(value) {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = value,
            !0 === this.isPlaying && (this.source.loop = this.loop), this);
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(value) {
            return this.gain.gain.value = value, this;
        }
    }), PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force), position.setFromMatrixPosition(this.matrixWorld),
                this.panner.setPosition(position.x, position.y, position.z);
            };
        }()
    }), Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function() {
            for (var value = 0, data = this.getFrequencyData(), i = 0; i < data.length; i++) value += data[i];
            return value / data.length;
        }
    }), Object.assign(PropertyMixer.prototype, {
        accumulate: function(accuIndex, weight) {
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
            if (0 === currentWeight) {
                for (var i = 0; i !== stride; ++i) buffer[offset + i] = buffer[i];
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
            if (this.cumulativeWeight = 0, weight < 1) {
                var originalValueOffset = 3 * stride;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) if (buffer[i] !== buffer[i + stride]) {
                binding.setValue(buffer, offset);
                break;
            }
        },
        saveOriginalState: function() {
            var binding = this.binding, buffer = this.buffer, stride = this.valueSize, originalValueOffset = 3 * stride;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) buffer[i] = buffer[originalValueOffset + i % stride];
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            var originalValueOffset = 3 * this.valueSize;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= .5) for (var i = 0; i !== stride; ++i) buffer[dstOffset + i] = buffer[srcOffset + i];
        },
        _slerp: function(buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
            for (var s = 1 - t, i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    }), Object.assign(Composite.prototype, {
        getValue: function(array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            void 0 !== binding && binding.getValue(array, offset);
        },
        setValue: function(array, offset) {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].setValue(array, offset);
        },
        bind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].bind();
        },
        unbind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].unbind();
        }
    }), Object.assign(PropertyBinding, {
        Composite: Composite,
        create: function(root, path, parsedPath) {
            return root && root.isAnimationObjectGroup ? new PropertyBinding.Composite(root, path, parsedPath) : new PropertyBinding(root, path, parsedPath);
        },
        sanitizeNodeName: function(name) {
            return name.replace(/\s/g, "_").replace(/[^\w-]/g, "");
        },
        parseTrackName: function() {
            var directoryRe = /((?:[\w-]+[\/:])*)/, nodeRe = /([\w-\.]+)?/, objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/, propertyRe = /\.([\w-]+)(?:\[(.+)\])?/, trackRe = new RegExp("^" + directoryRe.source + nodeRe.source + objectRe.source + propertyRe.source + "$"), supportedObjectNames = [ "material", "materials", "bones" ];
            return function(trackName) {
                var matches = trackRe.exec(trackName);
                if (!matches) throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
                var results = {
                    nodeName: matches[2],
                    objectName: matches[3],
                    objectIndex: matches[4],
                    propertyName: matches[5],
                    propertyIndex: matches[6]
                }, lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
                if (void 0 !== lastDot && -1 !== lastDot) {
                    var objectName = results.nodeName.substring(lastDot + 1);
                    -1 !== supportedObjectNames.indexOf(objectName) && (results.nodeName = results.nodeName.substring(0, lastDot),
                    results.objectName = objectName);
                }
                if (null === results.propertyName || 0 === results.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
                return results;
            };
        }(),
        findNode: function(root, nodeName) {
            if (!nodeName || "" === nodeName || "root" === nodeName || "." === nodeName || -1 === nodeName || nodeName === root.name || nodeName === root.uuid) return root;
            if (root.skeleton) {
                var bone = function(skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        if (bone.name === nodeName) return bone;
                    }
                    return null;
                }(root.skeleton);
                if (bone) return bone;
            }
            if (root.children) {
                var searchNodeSubtree = function(children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                        var result = searchNodeSubtree(childNode.children);
                        if (result) return result;
                    }
                    return null;
                }, subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) return subTreeNode;
            }
            return null;
        }
    }), Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [ function(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }, function(buffer, offset) {
            for (var source = this.resolvedProperty, i = 0, n = source.length; i !== n; ++i) buffer[offset++] = source[i];
        }, function(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        } ],
        SetterByBindingTypeAndVersioning: [ [ function(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
        }, function(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.matrixWorldNeedsUpdate = !0;
        } ] ],
        getValue: function(targetArray, offset) {
            this.bind(), this.getValue(targetArray, offset);
        },
        setValue: function(sourceArray, offset) {
            this.bind(), this.setValue(sourceArray, offset);
        },
        bind: function() {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (targetObject || (targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode,
            this.node = targetObject), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable,
            !targetObject) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!targetObject.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    targetObject = targetObject.material.materials;
                    break;

                  case "bones":
                    if (!targetObject.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    targetObject = targetObject.skeleton.bones;
                    for (var i = 0; i < targetObject.length; i++) if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                    }
                    break;

                  default:
                    if (void 0 === targetObject[objectName]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    targetObject = targetObject[objectName];
                }
                if (void 0 !== objectIndex) {
                    if (void 0 === targetObject[objectIndex]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (void 0 === nodeProperty) {
                var nodeName = parsedPath.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            }
            var versioning = this.Versioning.None;
            void 0 !== targetObject.needsUpdate ? (versioning = this.Versioning.NeedsUpdate,
            this.targetObject = targetObject) : void 0 !== targetObject.matrixWorldNeedsUpdate && (versioning = this.Versioning.MatrixWorldNeedsUpdate,
            this.targetObject = targetObject);
            var bindingType = this.BindingType.Direct;
            if (void 0 !== propertyIndex) {
                if ("morphTargetInfluences" === propertyName) {
                    if (!targetObject.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    } else {
                        if (!targetObject.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement, this.resolvedProperty = nodeProperty,
                this.propertyIndex = propertyIndex;
            } else void 0 !== nodeProperty.fromArray && void 0 !== nodeProperty.toArray ? (bindingType = this.BindingType.HasFromToArray,
            this.resolvedProperty = nodeProperty) : Array.isArray(nodeProperty) ? (bindingType = this.BindingType.EntireArray,
            this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
            this.getValue = this.GetterByBindingType[bindingType], this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }), //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(PropertyBinding.prototype, {
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue
    }), Object.assign(AnimationObjectGroup.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid], knownObject = void 0;
                if (void 0 === index) {
                    index = nObjects++, indicesByUUID[uuid] = index, objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject,
                    indicesByUUID[uuid] = firstActiveIndex, objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached, void 0 === binding && (binding = new PropertyBinding(object, paths[j], parsedPaths[j])),
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else objects[index] !== knownObject && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function() {
            for (var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index, objects[index] = firstActiveObject,
                    indicesByUUID[uuid] = lastCachedIndex, objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive, bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function() {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index) if (delete indicesByUUID[uuid], index < nCachedObjects) {
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject,
                    indicesByUUID[lastObject.uuid] = firstActiveIndex, objects[firstActiveIndex] = lastObject,
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached, bindingsForPath[firstActiveIndex] = last, bindingsForPath.pop();
                    }
                } else {
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index, objects[index] = lastObject, objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex], bindingsForPath.pop();
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function(path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (void 0 !== index) return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length, indicesByPath[path] = index, paths.push(path), parsedPaths.push(parsedPath),
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function(path) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (void 0 !== index) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex];
                indicesByPath[path[lastBindingsIndex]] = index, bindings[index] = lastBindings,
                bindings.pop(), parsedPaths[index] = parsedPaths[lastBindingsIndex], parsedPaths.pop(),
                paths[index] = paths[lastBindingsIndex], paths.pop();
            }
        }
    }), Object.assign(AnimationAction.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this;
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1,
            this._startTime = null, this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(time) {
            return this._startTime = time, this;
        },
        setLoop: function(mode, repetitions) {
            return this.loop = mode, this.repetitions = repetitions, this;
        },
        setEffectiveWeight: function(weight) {
            return this.weight = weight, this._effectiveWeight = this.enabled ? weight : 0,
            this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function(duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function(fadeOutAction, duration, warp) {
            if (fadeOutAction.fadeOut(duration), this.fadeIn(duration), warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration), this.warp(endStartRatio, 1, duration);
            }
            return this;
        },
        crossFadeTo: function(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function() {
            var weightInterpolant = this._weightInterpolant;
            return null !== weightInterpolant && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(weightInterpolant)),
            this;
        },
        setEffectiveTimeScale: function(timeScale) {
            return this.timeScale = timeScale, this._effectiveTimeScale = this.paused ? 0 : timeScale,
            this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(duration) {
            return this.timeScale = this._clip.duration / duration, this.stopWarping();
        },
        syncWith: function(action) {
            return this.time = action.time, this.timeScale = action.timeScale, this.stopWarping();
        },
        halt: function(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, times[1] = now + duration, values[0] = startTimeScale / timeScale,
            values[1] = endTimeScale / timeScale, this;
        },
        stopWarping: function() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            return null !== timeScaleInterpolant && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(timeScaleInterpolant)),
            this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(time, deltaTime, timeDirection, accuIndex) {
            if (!this.enabled) return void this._updateWeight(time);
            var startTime = this._startTime;
            if (null !== startTime) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || 0 === timeDirection) return;
                this._startTime = null, deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime), weight = this._updateWeight(time);
            if (weight > 0) for (var interpolants = this._interpolants, propertyMixers = this._propertyBindings, j = 0, m = interpolants.length; j !== m; ++j) interpolants[j].evaluate(clipTime),
            propertyMixers[j].accumulate(accuIndex, weight);
        },
        _updateWeight: function(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (null !== interpolant) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopFading(),
                    0 === interpolantValue && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = weight, weight;
        },
        _updateTimeScale: function(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (null !== interpolant) {
                    timeScale *= interpolant.evaluate(time)[0], time > interpolant.parameterPositions[1] && (this.stopWarping(),
                    0 === timeScale ? this.paused = !0 : this.timeScale = timeScale);
                }
            }
            return this._effectiveTimeScale = timeScale, timeScale;
        },
        _updateTime: function(deltaTime) {
            var time = this.time + deltaTime;
            if (0 === deltaTime) return time;
            var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
            if (loop === LoopOnce) {
                -1 === loopCount && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                handle_stop: {
                    if (time >= duration) time = duration; else {
                        if (!(time < 0)) break handle_stop;
                        time = 0;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                var pingPong = loop === LoopPingPong;
                if (-1 === loopCount && (deltaTime >= 0 ? (loopCount = 0, this._setEndings(!0, 0 === this.repetitions, pingPong)) : this._setEndings(0 === this.repetitions, !0, pingPong)),
                time >= duration || time < 0) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta, loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    time = deltaTime > 0 ? duration : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    }); else {
                        if (0 === pending) {
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else this._setEndings(!1, !1, pingPong);
                        this._loopCount = loopCount, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && 1 == (1 & loopCount)) return this.time = time, duration - time;
            }
            return this.time = time, time;
        },
        _setEndings: function(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            pingPong ? (settings.endingStart = ZeroSlopeEnding, settings.endingEnd = ZeroSlopeEnding) : (settings.endingStart = atStart ? this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding,
            settings.endingEnd = atEnd ? this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding);
        },
        _scheduleFading: function(duration, weightNow, weightThen) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, values[0] = weightNow, times[1] = now + duration, values[1] = weightThen,
            this;
        }
    }), Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
        _bindAction: function(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            void 0 === bindingsByName && (bindingsByName = {}, bindingsByRoot[rootUuid] = bindingsByName);
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (void 0 !== binding) bindings[i] = binding; else {
                    if (void 0 !== (binding = bindings[i])) {
                        null === binding._cacheIndex && (++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName));
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize()),
                    ++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName),
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function(action) {
            if (!this._isActiveAction(action)) {
                if (null === action._cacheIndex) {
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]), this._addInactiveAction(action, clipUuid, rootUuid);
                }
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 == binding.useCount++ && (this._lendBinding(binding), binding.saveOriginalState());
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function(action) {
            if (this._isActiveAction(action)) {
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 == --binding.useCount && (binding.restoreOriginalState(), this._takeBackBinding(binding));
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [],
            this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(action) {
            var index = action._cacheIndex;
            return null !== index && index < this._nActiveActions;
        },
        _addInactiveAction: function(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 === actionsForClip) actionsForClip = {
                knownActions: [ action ],
                actionByRoot: {}
            }, action._byClipCacheIndex = 0, actionsByClip[clipUuid] = actionsForClip; else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length, knownActions.push(action);
            }
            action._cacheIndex = actions.length, actions.push(action), actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction,
            actions.pop(), action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex, knownActionsForClip[byClipCacheIndex] = lastKnownAction,
            knownActionsForClip.pop(), action._byClipCacheIndex = null, delete actionsForClip.actionByRoot[(action._localRoot || this._root).uuid],
            0 === knownActionsForClip.length && delete actionsByClip[clipUuid], this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function(action) {
            for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                0 == --binding.referenceCount && this._removeInactiveBinding(binding);
            }
        },
        _lendAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex, actions[lastActiveIndex] = action, firstInactiveAction._cacheIndex = prevIndex,
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex, actions[firstInactiveIndex] = action, lastActiveAction._cacheIndex = prevIndex,
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            void 0 === bindingByName && (bindingByName = {}, bindingsByRoot[rootUuid] = bindingByName),
            bindingByName[trackName] = binding, binding._cacheIndex = bindings.length, bindings.push(binding);
        },
        _removeInactiveBinding: function(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex, bindings[cacheIndex] = lastInactiveBinding,
            bindings.pop(), delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName) break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex, bindings[lastActiveIndex] = binding, firstInactiveBinding._cacheIndex = prevIndex,
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex, bindings[firstInactiveIndex] = binding,
            lastActiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            return void 0 === interpolant && (interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer),
            interpolant.__cacheIndex = lastActiveIndex, interpolants[lastActiveIndex] = interpolant),
            interpolant;
        },
        _takeBackControlInterpolant: function(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex, interpolants[firstInactiveIndex] = interpolant,
            lastActiveInterpolant.__cacheIndex = prevIndex, interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = null !== clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (void 0 !== actionsForClip) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (void 0 !== existingAction) return existingAction;
                prototypeAction = actionsForClip.knownActions[0], null === clipObject && (clipObject = prototypeAction._clip);
            }
            if (null === clipObject) return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            return this._bindAction(newAction, prototypeAction), this._addInactiveAction(newAction, clipUuid, rootUuid),
            newAction;
        },
        existingAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            return void 0 !== actionsForClip ? actionsForClip.actionByRoot[rootUuid] || null : null;
        },
        stopAllAction: function() {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) actions[i].reset();
            for (var i = 0; i !== nBindings; ++i) bindings[i].useCount = 0;
            return this;
        },
        update: function(deltaTime) {
            deltaTime *= this.timeScale;
            for (var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1, i = 0; i !== nActions; ++i) {
                actions[i]._update(time, deltaTime, timeDirection, accuIndex);
            }
            for (var bindings = this._bindings, nBindings = this._nActiveBindings, i = 0; i !== nBindings; ++i) bindings[i].apply(accuIndex);
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 !== actionsForClip) {
                for (var actionsToRemove = actionsForClip.knownActions, i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null, action._byClipCacheIndex = null, lastInactiveAction._cacheIndex = cacheIndex,
                    actions[cacheIndex] = lastInactiveAction, actions.pop(), this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                void 0 !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (void 0 !== bindingByName) for (var trackName in bindingByName) {
                var binding = bindingByName[trackName];
                binding.restoreOriginalState(), this._removeInactiveBinding(binding);
            }
        },
        uncacheAction: function(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            null !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
        }
    }), Uniform.prototype.clone = function() {
        return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone());
    }, InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
        constructor: InstancedBufferGeometry,
        isInstancedBufferGeometry: !0,
        copy: function(source) {
            return BufferGeometry.prototype.copy.call(this, source), this.maxInstancedCount = source.maxInstancedCount,
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }), Object.defineProperties(InterleavedBufferAttribute.prototype, {
        count: {
            get: function() {
                return this.data.count;
            }
        },
        array: {
            get: function() {
                return this.data.array;
            }
        }
    }), Object.assign(InterleavedBufferAttribute.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(index, x) {
            return this.data.array[index * this.data.stride + this.offset] = x, this;
        },
        setY: function(index, y) {
            return this.data.array[index * this.data.stride + this.offset + 1] = y, this;
        },
        setZ: function(index, z) {
            return this.data.array[index * this.data.stride + this.offset + 2] = z, this;
        },
        setW: function(index, w) {
            return this.data.array[index * this.data.stride + this.offset + 3] = w, this;
        },
        getX: function(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function(index, x, y) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x,
            this.data.array[index + 1] = y, this;
        },
        setXYZ: function(index, x, y, z) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x,
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x,
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this.data.array[index + 3] = w,
            this;
        }
    }), Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(InterleavedBuffer.prototype, {
        isInterleavedBuffer: !0,
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.stride : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.count = source.count,
            this.stride = source.stride, this.dynamic = source.dynamic, this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.stride, index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        onUpload: function(callback) {
            return this.onUploadCallback = callback, this;
        }
    }), InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
        constructor: InstancedInterleavedBuffer,
        isInstancedInterleavedBuffer: !0,
        copy: function(source) {
            return InterleavedBuffer.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute,
            this;
        }
    }), InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
        constructor: InstancedBufferAttribute,
        isInstancedBufferAttribute: !0,
        copy: function(source) {
            return BufferAttribute.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute,
            this;
        }
    }), Object.assign(Raycaster.prototype, {
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            camera && camera.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld),
            this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()) : camera && camera.isOrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera),
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            return intersectObject(object, this, intersects, recursive), intersects.sort(ascSort),
            intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (!1 === Array.isArray(objects)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
            intersects;
            for (var i = 0, l = objects.length; i < l; i++) intersectObject(objects[i], this, intersects, recursive);
            return intersects.sort(ascSort), intersects;
        }
    }), Object.assign(Clock.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime;
        },
        getDelta: function() {
            var diff = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var newTime = ("undefined" == typeof performance ? Date : performance).now();
                diff = (newTime - this.oldTime) / 1e3, this.oldTime = newTime, this.elapsedTime += diff;
            }
            return diff;
        }
    }), Object.assign(Spherical.prototype, {
        set: function(radius, phi, theta) {
            return this.radius = radius, this.phi = phi, this.theta = theta, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            return this.radius = other.radius, this.phi = other.phi, this.theta = other.theta,
            this;
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
        },
        setFromVector3: function(vec3) {
            return this.radius = vec3.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(vec3.x, vec3.z),
            this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1))), this;
        }
    }), Object.assign(Cylindrical.prototype, {
        set: function(radius, theta, y) {
            return this.radius = radius, this.theta = theta, this.y = y, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            return this.radius = other.radius, this.theta = other.theta, this.y = other.y, this;
        },
        setFromVector3: function(vec3) {
            return this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z), this.theta = Math.atan2(vec3.x, vec3.z),
            this.y = vec3.y, this;
        }
    }), ImmediateRenderObject.prototype = Object.create(Object3D.prototype), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject,
    ImmediateRenderObject.prototype.isImmediateRenderObject = !0, VertexNormalsHelper.prototype = Object.create(LineSegments.prototype),
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper, VertexNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            var keys = [ "a", "b", "c" ];
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) for (var vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++) for (var face = faces[i], j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                var vertex = vertices[face[keys[j]]], normal = face.vertexNormals[j];
                v1.copy(vertex).applyMatrix4(matrixWorld), v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z),
                idx += 1;
            } else if (objGeometry && objGeometry.isBufferGeometry) for (var objPos = objGeometry.attributes.position, objNorm = objGeometry.attributes.normal, idx = 0, j = 0, jl = objPos.count; j < jl; j++) v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld),
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j)), v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
            position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z),
            idx += 1;
            position.needsUpdate = !0;
        };
    }(), SpotLightHelper.prototype = Object.create(Object3D.prototype), SpotLightHelper.prototype.constructor = SpotLightHelper,
    SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }, SpotLightHelper.prototype.update = function() {
        var vector = new Vector3(), vector2 = new Vector3();
        return function() {
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1e3, coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength), vector.setFromMatrixPosition(this.light.matrixWorld),
            vector2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(vector2.sub(vector)),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        };
    }(), SkeletonHelper.prototype = Object.create(LineSegments.prototype), SkeletonHelper.prototype.constructor = SkeletonHelper,
    SkeletonHelper.prototype.updateMatrixWorld = function() {
        var vector = new Vector3(), boneMatrix = new Matrix4(), matrixWorldInv = new Matrix4();
        return function(force) {
            var bones = this.bones, geometry = this.geometry, position = geometry.getAttribute("position");
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                bone.parent && bone.parent.isBone && (boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld),
                vector.setFromMatrixPosition(boneMatrix), position.setXYZ(j, vector.x, vector.y, vector.z),
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld), vector.setFromMatrixPosition(boneMatrix),
                position.setXYZ(j + 1, vector.x, vector.y, vector.z), j += 2);
            }
            geometry.getAttribute("position").needsUpdate = !0, Object3D.prototype.updateMatrixWorld.call(this, force);
        };
    }(), PointLightHelper.prototype = Object.create(Mesh.prototype), PointLightHelper.prototype.constructor = PointLightHelper,
    PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose();
    }, PointLightHelper.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }, RectAreaLightHelper.prototype = Object.create(Object3D.prototype), RectAreaLightHelper.prototype.constructor = RectAreaLightHelper,
    RectAreaLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, RectAreaLightHelper.prototype.update = function() {
        var hx = .5 * this.light.width, hy = .5 * this.light.height, position = this.line.geometry.attributes.position, array = position.array;
        array[0] = hx, array[1] = -hy, array[2] = 0, array[3] = hx, array[4] = hy, array[5] = 0,
        array[6] = -hx, array[7] = hy, array[8] = 0, array[9] = -hx, array[10] = -hy, array[11] = 0,
        array[12] = hx, array[13] = -hy, array[14] = 0, position.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
    }, HemisphereLightHelper.prototype = Object.create(Object3D.prototype), HemisphereLightHelper.prototype.constructor = HemisphereLightHelper,
    HemisphereLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, HemisphereLightHelper.prototype.update = function() {
        var vector = new Vector3(), color1 = new Color(), color2 = new Color();
        return function() {
            var mesh = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color); else {
                var colors = mesh.geometry.getAttribute("color");
                color1.copy(this.light.color), color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                    var color = i < l / 2 ? color1 : color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = !0;
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
    }(), GridHelper.prototype = Object.create(LineSegments.prototype), GridHelper.prototype.constructor = GridHelper,
    PolarGridHelper.prototype = Object.create(LineSegments.prototype), PolarGridHelper.prototype.constructor = PolarGridHelper,
    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype), FaceNormalsHelper.prototype.constructor = FaceNormalsHelper,
    FaceNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry, vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++) {
                var face = faces[i], normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld),
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z),
                idx += 1;
            }
            position.needsUpdate = !0;
        };
    }(), DirectionalLightHelper.prototype = Object.create(Object3D.prototype), DirectionalLightHelper.prototype.constructor = DirectionalLightHelper,
    DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }, DirectionalLightHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3();
        return function() {
            v1.setFromMatrixPosition(this.light.matrixWorld), v2.setFromMatrixPosition(this.light.target.matrixWorld),
            v3.subVectors(v2, v1), this.lightPlane.lookAt(v3), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(v3),
            this.targetLine.scale.z = v3.length();
        };
    }(), CameraHelper.prototype = Object.create(LineSegments.prototype), CameraHelper.prototype.constructor = CameraHelper,
    CameraHelper.prototype.update = function() {
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (void 0 !== points) for (var position = geometry.getAttribute("position"), i = 0, l = points.length; i < l; i++) position.setXYZ(points[i], vector.x, vector.y, vector.z);
        }
        var geometry, pointMap, vector = new Vector3(), camera = new Camera();
        return function() {
            geometry = this.geometry, pointMap = this.pointMap;
            camera.projectionMatrix.copy(this.camera.projectionMatrix), setPoint("c", 0, 0, -1),
            setPoint("t", 0, 0, 1), setPoint("n1", -1, -1, -1), setPoint("n2", 1, -1, -1), setPoint("n3", -1, 1, -1),
            setPoint("n4", 1, 1, -1), setPoint("f1", -1, -1, 1), setPoint("f2", 1, -1, 1), setPoint("f3", -1, 1, 1),
            setPoint("f4", 1, 1, 1), setPoint("u1", .7, 1.1, -1), setPoint("u2", -.7, 1.1, -1),
            setPoint("u3", 0, 2, -1), setPoint("cf1", -1, 0, 1), setPoint("cf2", 1, 0, 1), setPoint("cf3", 0, -1, 1),
            setPoint("cf4", 0, 1, 1), setPoint("cn1", -1, 0, -1), setPoint("cn2", 1, 0, -1),
            setPoint("cn3", 0, -1, -1), setPoint("cn4", 0, 1, -1), geometry.getAttribute("position").needsUpdate = !0;
        };
    }(), BoxHelper.prototype = Object.create(LineSegments.prototype), BoxHelper.prototype.constructor = BoxHelper,
    BoxHelper.prototype.update = function() {
        var box = new Box3();
        return function(object) {
            if (void 0 !== object && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
            void 0 !== this.object && box.setFromObject(this.object), !box.isEmpty()) {
                var min = box.min, max = box.max, position = this.geometry.attributes.position, array = position.array;
                array[0] = max.x, array[1] = max.y, array[2] = max.z, array[3] = min.x, array[4] = max.y,
                array[5] = max.z, array[6] = min.x, array[7] = min.y, array[8] = max.z, array[9] = max.x,
                array[10] = min.y, array[11] = max.z, array[12] = max.x, array[13] = max.y, array[14] = min.z,
                array[15] = min.x, array[16] = max.y, array[17] = min.z, array[18] = min.x, array[19] = min.y,
                array[20] = min.z, array[21] = max.x, array[22] = min.y, array[23] = min.z, position.needsUpdate = !0,
                this.geometry.computeBoundingSphere();
            }
        };
    }(), BoxHelper.prototype.setFromObject = function(object) {
        return this.object = object, this.update(), this;
    }, Box3Helper.prototype = Object.create(LineSegments.prototype), Box3Helper.prototype.constructor = Box3Helper,
    Box3Helper.prototype.updateMatrixWorld = function(force) {
        var box = this.box;
        box.isEmpty() || (box.getCenter(this.position), box.getSize(this.scale), this.scale.multiplyScalar(.5),
        Object3D.prototype.updateMatrixWorld.call(this, force));
    }, PlaneHelper.prototype = Object.create(Line.prototype), PlaneHelper.prototype.constructor = PlaneHelper,
    PlaneHelper.prototype.updateMatrixWorld = function(force) {
        var scale = -this.plane.constant;
        Math.abs(scale) < 1e-8 && (scale = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, scale),
        this.lookAt(this.plane.normal), Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    var lineGeometry, coneGeometry;
    ArrowHelper.prototype = Object.create(Object3D.prototype), ArrowHelper.prototype.constructor = ArrowHelper,
    ArrowHelper.prototype.setDirection = function() {
        var radians, axis = new Vector3();
        return function(dir) {
            dir.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : dir.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (axis.set(dir.z, 0, -dir.x).normalize(),
            radians = Math.acos(dir.y), this.quaternion.setFromAxisAngle(axis, radians));
        };
    }(), ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength),
        this.line.scale.set(1, Math.max(0, length - headLength), 1), this.line.updateMatrix(),
        this.cone.scale.set(headWidth, headLength, headWidth), this.cone.position.y = length,
        this.cone.updateMatrix();
    }, ArrowHelper.prototype.setColor = function(color) {
        this.line.material.color.copy(color), this.cone.material.color.copy(color);
    }, AxesHelper.prototype = Object.create(LineSegments.prototype), AxesHelper.prototype.constructor = AxesHelper;
    var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    CatmullRomCurve3.prototype = Object.create(Curve.prototype), CatmullRomCurve3.prototype.constructor = CatmullRomCurve3,
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0, CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3(), points = this.points, l = points.length, p = (l - (this.closed ? 0 : 1)) * t, intPoint = Math.floor(p), weight = p - intPoint;
        this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length : 0 === weight && intPoint === l - 1 && (intPoint = l - 2,
        weight = 1);
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]),
        p0 = tmp), p1 = points[intPoint % l], p2 = points[(intPoint + 1) % l], this.closed || intPoint + 2 < l ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]),
        p3 = tmp), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var pow = "chordal" === this.curveType ? .5 : .25, dt0 = Math.pow(p0.distanceToSquared(p1), pow), dt1 = Math.pow(p1.distanceToSquared(p2), pow), dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            dt1 < 1e-4 && (dt1 = 1), dt0 < 1e-4 && (dt0 = dt1), dt2 < 1e-4 && (dt2 = dt1), px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2),
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2), pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else "catmullrom" === this.curveType && (px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension),
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension), pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension));
        return point.set(px.calc(weight), py.calc(weight), pz.calc(weight)), point;
    }, CatmullRomCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source), this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        return this.closed = source.closed, this.curveType = source.curveType, this.tension = source.tension,
        this;
    }, CubicBezierCurve3.prototype = Object.create(Curve.prototype), CubicBezierCurve3.prototype.constructor = CubicBezierCurve3,
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0, CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3(), v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z)),
        point;
    }, CubicBezierCurve3.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v0.copy(source.v0), this.v1.copy(source.v1),
        this.v2.copy(source.v2), this.v3.copy(source.v3), this;
    }, QuadraticBezierCurve3.prototype = Object.create(Curve.prototype), QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3,
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0, QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3(), v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z)),
        point;
    }, QuadraticBezierCurve3.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v0.copy(source.v0), this.v1.copy(source.v1),
        this.v2.copy(source.v2), this;
    }, LineCurve3.prototype = Object.create(Curve.prototype), LineCurve3.prototype.constructor = LineCurve3,
    LineCurve3.prototype.isLineCurve3 = !0, LineCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        return 1 === t ? point.copy(this.v2) : (point.copy(this.v2).sub(this.v1), point.multiplyScalar(t).add(this.v1)),
        point;
    }, LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }, LineCurve3.prototype.copy = function(source) {
        return Curve.prototype.copy.call(this, source), this.v1.copy(source.v1), this.v2.copy(source.v2),
        this;
    }, ArcCurve.prototype = Object.create(EllipseCurve.prototype), ArcCurve.prototype.constructor = ArcCurve,
    ArcCurve.prototype.isArcCurve = !0;
    var SceneUtils = {
        createMultiMaterialObject: function(geometry, materials) {
            for (var group = new Group(), i = 0, l = materials.length; i < l; i++) group.add(new Mesh(geometry, materials[i]));
            return group;
        },
        detach: function(child, parent, scene) {
            child.applyMatrix(parent.matrixWorld), parent.remove(child), scene.add(child);
        },
        attach: function(child, scene, parent) {
            child.applyMatrix(new Matrix4().getInverse(parent.matrixWorld)), scene.remove(child),
            parent.add(child);
        }
    }, LineStrip = 0, LinePieces = 1;
    Curve.create = function(construct, getPoint) {
        return console.log("THREE.Curve.create() has been deprecated"), construct.prototype = Object.create(Curve.prototype),
        construct.prototype.constructor = construct, construct.prototype.getPoint = getPoint,
        construct;
    }, Object.assign(CurvePath.prototype, {
        createPointsGeometry: function(divisions) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function(divisions) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function(points) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var geometry = new Geometry(), i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    }), Object.assign(Path.prototype, {
        fromPoints: function(points) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(points);
        }
    }), ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype), SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype),
    Spline.prototype = Object.create(CatmullRomCurve3.prototype), Object.assign(Spline.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.");
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
        }
    }), GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    }, Object.assign(Box2.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(box);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Object.assign(Box3.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(box);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(sphere);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Line3.prototype.center = function(optionalTarget) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(optionalTarget);
    }, Object.assign(_Math, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random();
        },
        nearestPowerOfTwo: function(value) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            _Math.floorPowerOfTwo(value);
        },
        nextPowerOfTwo: function(value) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            _Math.ceilPowerOfTwo(value);
        }
    }), Object.assign(Matrix3.prototype, {
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(array, offset);
        },
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            vector.applyMatrix3(this);
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
        },
        applyToBuffer: function(buffer) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
        }
    }), Object.assign(Matrix4.prototype, {
        extractPosition: function(m) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(m);
        },
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(array, offset);
        },
        getPosition: function() {
            var v1;
            return function() {
                return void 0 === v1 && (v1 = new Vector3()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                v1.setFromMatrixColumn(this, 3);
            };
        }(),
        setRotationFromQuaternion: function(q) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            vector.applyMatrix4(this);
        },
        multiplyVector4: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            vector.applyMatrix4(this);
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
        },
        rotateAxis: function(v) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            v.transformDirection(this);
        },
        crossVector: function(vector) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            vector.applyMatrix4(this);
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function(buffer) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
        },
        makeFrustum: function(left, right, bottom, top, near, far) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(left, right, top, bottom, near, far);
        }
    }), Plane.prototype.isIntersectionLine = function(line) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(line);
    }, Quaternion.prototype.multiplyVector3 = function(vector) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        vector.applyQuaternion(this);
    }, Object.assign(Ray.prototype, {
        isIntersectionBox: function(box) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(box);
        },
        isIntersectionPlane: function(plane) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(plane);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(sphere);
        }
    }), Object.assign(Shape.prototype, {
        extractAllPoints: function(divisions) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(divisions);
        },
        extrude: function(options) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new ExtrudeGeometry(this, options);
        },
        makeGeometry: function(options) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new ShapeGeometry(this, options);
        }
    }), Object.assign(Vector2.prototype, {
        fromAttribute: function(attribute, index, offset) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function(v) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(v);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength();
        }
    }), Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
        },
        getPositionFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function(index, matrix) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function(m) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(m);
        },
        fromAttribute: function(attribute, index, offset) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function(v) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(v);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength();
        }
    }), Object.assign(Vector4.prototype, {
        fromAttribute: function(attribute, index, offset) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(attribute, index, offset);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength();
        }
    }), Geometry.prototype.computeTangents = function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.");
    }, Object.assign(Object3D.prototype, {
        getChildByName: function(name) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(name);
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
        },
        translate: function(distance, axis) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(axis, distance);
        }
    }), Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
            },
            set: function(value) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            }
        }
    }), Object.defineProperties(LOD.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
            }
        }
    }), Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        }
    }), Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions;
        },
        set: function(value) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = value;
        }
    }), PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== filmGauge && (this.filmGauge = filmGauge), this.setFocalLength(focalLength);
    }, Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.");
            }
        },
        shadowCameraFov: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
            }
        },
        shadowBias: {
            set: function(value) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
            }
        },
        shadowMapWidth: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = value;
            }
        }
    }), Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length;
            }
        }
    }), Object.assign(BufferGeometry.prototype, {
        addIndex: function(index) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(index);
        },
        addDrawCall: function(start, count, indexOffset) {
            void 0 !== indexOffset && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(start, count);
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups();
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
        }
    }), Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups;
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups;
            }
        }
    }), Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this;
            }
        }
    }), Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            },
            set: function(value) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = value === FlatShading;
            }
        }
    }), Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1;
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
            }
        }
    }), Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives;
            },
            set: function(value) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = value;
            }
        }
    }), Object.assign(WebGLRenderer.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget();
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision;
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset();
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float");
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float");
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives");
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc");
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc");
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax");
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays");
        },
        enableScissorTest: function(boolean) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(boolean);
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
        }
    }), Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
                this.shadowMap.cullFace = value;
            }
        }
    }), Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
            },
            set: function(cullFace) {
                var value = cullFace !== CullFaceBack;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "."),
                this.renderReverseSided = value;
            }
        }
    }), Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = value;
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = value;
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = value;
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = value;
            }
        }
    }), Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var scope = this;
        return new AudioLoader().load(file, function(buffer) {
            scope.setBuffer(buffer);
        }), this;
    }, AudioAnalyser.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData();
    }, CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(renderer, scene);
    };
    var GeometryUtils = {
        merge: function(geometry1, geometry2, materialIndexOffset) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var matrix;
            geometry2.isMesh && (geometry2.matrixAutoUpdate && geometry2.updateMatrix(), matrix = geometry2.matrix,
            geometry2 = geometry2.geometry), geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function(geometry) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            geometry.center();
        }
    }, ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(url, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadTextureCube: function(urls, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
        }
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_1_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__),
    __webpack_require__(1)), ActionServer = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_roslib__),
    function(_EventEmitter) {
        function ActionServer(robot) {
            var _this;
            _classCallCheck(this, ActionServer), _this = _super.call(this);
            var ros = robot.ros;
            return _this.actionClient = new __WEBPACK_IMPORTED_MODULE_1_roslib__.ActionClient({
                ros: ros,
                serverName: "action_server/task",
                actionName: "action_server_msgs/TaskAction"
            }), _this;
        }
        _inherits(ActionServer, _EventEmitter);
        var _super = _createSuper(ActionServer);
        return _createClass(ActionServer, [ {
            key: "doAction",
            value: function(recipe) {
                var that = this, goal = new __WEBPACK_IMPORTED_MODULE_1_roslib__.Goal({
                    actionClient: this.actionClient,
                    goalMessage: {
                        recipe: JSON.stringify(recipe)
                    }
                });
                goal.on("feedback", function(feedback) {
                    that.emit("feedback", feedback);
                }), goal.on("status", function(status) {
                    that.emit("status", status);
                }), goal.send();
            }
        }, {
            key: "cancelAllActions",
            value: function() {
                this.actionClient.cancel();
            }
        } ]), ActionServer;
    }(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__.EventEmitter2));
    __webpack_exports__.a = ActionServer;
}, function(module, exports) {
    module.exports = "undefined" != typeof window ? window.WebSocket : WebSocket;
}, function(module, exports, __webpack_require__) {
    function ServiceResponse(values) {
        assign(this, values);
    }
    var assign = __webpack_require__(2);
    module.exports = ServiceResponse;
}, function(module, exports, __webpack_require__) {
    function ActionClient(options) {
        var that = this;
        options = options || {}, this.ros = options.ros, this.serverName = options.serverName,
        this.actionName = options.actionName, this.timeout = options.timeout, this.omitFeedback = options.omitFeedback,
        this.omitStatus = options.omitStatus, this.omitResult = options.omitResult, this.goals = {};
        var receivedStatus = !1;
        this.feedbackListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/feedback",
            messageType: this.actionName + "Feedback"
        }), this.statusListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/status",
            messageType: "actionlib_msgs/GoalStatusArray"
        }), this.resultListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/result",
            messageType: this.actionName + "Result"
        }), this.goalTopic = new Topic({
            ros: this.ros,
            name: this.serverName + "/goal",
            messageType: this.actionName + "Goal"
        }), this.cancelTopic = new Topic({
            ros: this.ros,
            name: this.serverName + "/cancel",
            messageType: "actionlib_msgs/GoalID"
        }), this.goalTopic.advertise(), this.cancelTopic.advertise(), this.omitStatus || this.statusListener.subscribe(function(statusMessage) {
            receivedStatus = !0, statusMessage.status_list.forEach(function(status) {
                var goal = that.goals[status.goal_id.id];
                goal && goal.emit("status", status);
            });
        }), this.omitFeedback || this.feedbackListener.subscribe(function(feedbackMessage) {
            var goal = that.goals[feedbackMessage.status.goal_id.id];
            goal && (goal.emit("status", feedbackMessage.status), goal.emit("feedback", feedbackMessage.feedback));
        }), this.omitResult || this.resultListener.subscribe(function(resultMessage) {
            var goal = that.goals[resultMessage.status.goal_id.id];
            goal && (goal.emit("status", resultMessage.status), goal.emit("result", resultMessage.result));
        }), this.timeout && setTimeout(function() {
            receivedStatus || that.emit("timeout");
        }, this.timeout);
    }
    var Topic = __webpack_require__(8), Message = __webpack_require__(6), EventEmitter2 = __webpack_require__(3).EventEmitter2;
    ActionClient.prototype.__proto__ = EventEmitter2.prototype, ActionClient.prototype.cancel = function() {
        var cancelMessage = new Message();
        this.cancelTopic.publish(cancelMessage);
    }, ActionClient.prototype.dispose = function() {
        this.goalTopic.unadvertise(), this.cancelTopic.unadvertise(), this.omitStatus || this.statusListener.unsubscribe(),
        this.omitFeedback || this.feedbackListener.unsubscribe(), this.omitResult || this.resultListener.unsubscribe();
    }, module.exports = ActionClient;
}, function(module, exports, __webpack_require__) {
    function Goal(options) {
        var that = this;
        this.actionClient = options.actionClient, this.goalMessage = options.goalMessage,
        this.isFinished = !1;
        var date = new Date();
        this.goalID = "goal_" + Math.random() + "_" + date.getTime(), this.goalMessage = new Message({
            goal_id: {
                stamp: {
                    secs: 0,
                    nsecs: 0
                },
                id: this.goalID
            },
            goal: this.goalMessage
        }), this.on("status", function(status) {
            that.status = status;
        }), this.on("result", function(result) {
            that.isFinished = !0, that.result = result;
        }), this.on("feedback", function(feedback) {
            that.feedback = feedback;
        }), this.actionClient.goals[this.goalID] = this;
    }
    var Message = __webpack_require__(6), EventEmitter2 = __webpack_require__(3).EventEmitter2;
    Goal.prototype.__proto__ = EventEmitter2.prototype, Goal.prototype.send = function(timeout) {
        var that = this;
        that.actionClient.goalTopic.publish(that.goalMessage), timeout && setTimeout(function() {
            that.isFinished || that.emit("timeout");
        }, timeout);
    }, Goal.prototype.cancel = function() {
        var cancelMessage = new Message({
            id: this.goalID
        });
        this.actionClient.cancelTopic.publish(cancelMessage);
    }, module.exports = Goal;
}, function(module, exports, __webpack_require__) {
    function Transform(options) {
        options = options || {}, this.translation = new Vector3(options.translation), this.rotation = new Quaternion(options.rotation);
    }
    var Vector3 = __webpack_require__(4), Quaternion = __webpack_require__(9);
    Transform.prototype.clone = function() {
        return new Transform(this);
    }, module.exports = Transform;
}, function(module, exports, __webpack_require__) {
    function UrdfBox(options) {
        this.dimension = null, this.type = UrdfTypes.URDF_BOX;
        var xyz = options.xml.getAttribute("size").split(" ");
        this.dimension = new Vector3({
            x: parseFloat(xyz[0]),
            y: parseFloat(xyz[1]),
            z: parseFloat(xyz[2])
        });
    }
    var Vector3 = __webpack_require__(4), UrdfTypes = __webpack_require__(10);
    module.exports = UrdfBox;
}, function(module, exports) {
    function UrdfColor(options) {
        var rgba = options.xml.getAttribute("rgba").split(" ");
        this.r = parseFloat(rgba[0]), this.g = parseFloat(rgba[1]), this.b = parseFloat(rgba[2]),
        this.a = parseFloat(rgba[3]);
    }
    module.exports = UrdfColor;
}, function(module, exports, __webpack_require__) {
    function UrdfCylinder(options) {
        this.type = UrdfTypes.URDF_CYLINDER, this.length = parseFloat(options.xml.getAttribute("length")),
        this.radius = parseFloat(options.xml.getAttribute("radius"));
    }
    var UrdfTypes = __webpack_require__(10);
    module.exports = UrdfCylinder;
}, function(module, exports, __webpack_require__) {
    function UrdfLink(options) {
        this.name = options.xml.getAttribute("name"), this.visuals = [];
        for (var visuals = options.xml.getElementsByTagName("visual"), i = 0; i < visuals.length; i++) this.visuals.push(new UrdfVisual({
            xml: visuals[i]
        }));
    }
    var UrdfVisual = __webpack_require__(30);
    module.exports = UrdfLink;
}, function(module, exports, __webpack_require__) {
    function UrdfVisual(options) {
        var xml = options.xml;
        this.origin = null, this.geometry = null, this.material = null, this.name = options.xml.getAttribute("name");
        var origins = xml.getElementsByTagName("origin");
        if (0 === origins.length) this.origin = new Pose(); else {
            var xyz = origins[0].getAttribute("xyz"), position = new Vector3();
            xyz && (xyz = xyz.split(" "), position = new Vector3({
                x: parseFloat(xyz[0]),
                y: parseFloat(xyz[1]),
                z: parseFloat(xyz[2])
            }));
            var rpy = origins[0].getAttribute("rpy"), orientation = new Quaternion();
            if (rpy) {
                rpy = rpy.split(" ");
                var roll = parseFloat(rpy[0]), pitch = parseFloat(rpy[1]), yaw = parseFloat(rpy[2]), phi = roll / 2, the = pitch / 2, psi = yaw / 2, x = Math.sin(phi) * Math.cos(the) * Math.cos(psi) - Math.cos(phi) * Math.sin(the) * Math.sin(psi), y = Math.cos(phi) * Math.sin(the) * Math.cos(psi) + Math.sin(phi) * Math.cos(the) * Math.sin(psi), z = Math.cos(phi) * Math.cos(the) * Math.sin(psi) - Math.sin(phi) * Math.sin(the) * Math.cos(psi), w = Math.cos(phi) * Math.cos(the) * Math.cos(psi) + Math.sin(phi) * Math.sin(the) * Math.sin(psi);
                orientation = new Quaternion({
                    x: x,
                    y: y,
                    z: z,
                    w: w
                }), orientation.normalize();
            }
            this.origin = new Pose({
                position: position,
                orientation: orientation
            });
        }
        var geoms = xml.getElementsByTagName("geometry");
        if (geoms.length > 0) {
            for (var geom = geoms[0], shape = null, i = 0; i < geom.childNodes.length; i++) {
                var node = geom.childNodes[i];
                if (1 === node.nodeType) {
                    shape = node;
                    break;
                }
            }
            var type = shape.nodeName;
            "sphere" === type ? this.geometry = new UrdfSphere({
                xml: shape
            }) : "box" === type ? this.geometry = new UrdfBox({
                xml: shape
            }) : "cylinder" === type ? this.geometry = new UrdfCylinder({
                xml: shape
            }) : "mesh" === type ? this.geometry = new UrdfMesh({
                xml: shape
            }) : console.warn("Unknown geometry type " + type);
        }
        var materials = xml.getElementsByTagName("material");
        materials.length > 0 && (this.material = new UrdfMaterial({
            xml: materials[0]
        }));
    }
    var Pose = __webpack_require__(16), Vector3 = __webpack_require__(4), Quaternion = __webpack_require__(9), UrdfCylinder = __webpack_require__(28), UrdfBox = __webpack_require__(26), UrdfMaterial = __webpack_require__(17), UrdfMesh = __webpack_require__(31), UrdfSphere = __webpack_require__(32);
    module.exports = UrdfVisual;
}, function(module, exports, __webpack_require__) {
    function UrdfMesh(options) {
        this.scale = null, this.type = UrdfTypes.URDF_MESH, this.filename = options.xml.getAttribute("filename");
        var scale = options.xml.getAttribute("scale");
        if (scale) {
            var xyz = scale.split(" ");
            this.scale = new Vector3({
                x: parseFloat(xyz[0]),
                y: parseFloat(xyz[1]),
                z: parseFloat(xyz[2])
            });
        }
    }
    var Vector3 = __webpack_require__(4), UrdfTypes = __webpack_require__(10);
    module.exports = UrdfMesh;
}, function(module, exports, __webpack_require__) {
    function UrdfSphere(options) {
        this.type = UrdfTypes.URDF_SPHERE, this.radius = parseFloat(options.xml.getAttribute("radius"));
    }
    var UrdfTypes = __webpack_require__(10);
    module.exports = UrdfSphere;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_1_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__),
    __webpack_require__(1)), Base = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_roslib__),
    function(_EventEmitter) {
        function Base(robot) {
            var _this;
            _classCallCheck(this, Base), _this = _super.call(this);
            var ros = robot.ros;
            return _this.cmdVelTopic = ros.Topic({
                name: "base/references",
                messageType: "geometry_msgs/Twist"
            }), _this.localPlannerTopic = ros.Topic({
                name: "local_planner/action_server/goal",
                messageType: "cb_base_navigation_msgs/LocalPlannerActionGoal"
            }), _this;
        }
        _inherits(Base, _EventEmitter);
        var _super = _createSuper(Base);
        return _createClass(Base, [ {
            key: "sendTwist",
            value: function(vx, vy, vth) {
                var twist = new __WEBPACK_IMPORTED_MODULE_1_roslib__.Message({
                    angular: {
                        x: 0,
                        y: 0,
                        z: vth
                    },
                    linear: {
                        x: vx,
                        y: vy,
                        z: 0
                    }
                });
                this.cmdVelTopic.publish(twist), console.log("sendTwist: ".concat(vx, ", ").concat(vy, ", ").concat(vth));
            }
        }, {
            key: "sendLocalPlannerGoal",
            value: function(plan, look_at_x, look_at_y) {
                var goal = new __WEBPACK_IMPORTED_MODULE_1_roslib__.Message({
                    goal: {
                        plan: plan,
                        orientation_constraint: {
                            frame: "/map",
                            look_at: {
                                x: look_at_x,
                                y: look_at_y
                            }
                        }
                    }
                });
                this.localPlannerTopic.publish(goal), console.log("sendGoal to local planner: ".concat(goal));
            }
        } ]), Base;
    }(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__.EventEmitter2));
    __webpack_exports__.a = Base;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" == typeof o.length) {
                it && (o = it);
                var i = 0, F = function() {};
                return {
                    s: F,
                    n: function() {
                        return i >= o.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: o[i++]
                        };
                    },
                    e: function(_e) {
                        throw _e;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var err, normalCompletion = !0, didErr = !1;
        return {
            s: function() {
                it = o[Symbol.iterator]();
            },
            n: function() {
                var step = it.next();
                return normalCompletion = step.done, step;
            },
            e: function(_e2) {
                didErr = !0, err = _e2;
            },
            f: function() {
                try {
                    normalCompletion || null == it.return || it.return();
                } finally {
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (o) {
            if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
        }
    }
    function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function parseEdPosition(pose) {
        return {
            position: [ pose.x, pose.y, pose.z ],
            quaternion: [ pose.qx, pose.qy, pose.qz, pose.qw ]
        };
    }
    function parseEdConvexHull(chull) {
        var _step2, vertices = [], _iterator2 = _createForOfIteratorHelper(chull.points);
        try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var point = _step2.value;
                vertices.push([ point.x, point.y, chull.z_min ]), vertices.push([ point.x, point.y, chull.z_max ]);
            }
        } catch (err) {
            _iterator2.e(err);
        } finally {
            _iterator2.f();
        }
        for (var faces = [], i = 1; i < chull.points.length - 1; i++) {
            var i2 = 2 * i;
            faces.push([ i2 + 2, i2, 0 ]), faces.push([ i2 + 1, i2 + 3, 1 ]);
        }
        for (var _i4 = 0; _i4 < chull.points.length; _i4++) {
            var j = (_i4 + 1) % chull.points.length;
            faces.push([ 2 * j, 2 * _i4 + 1, 2 * _i4 ]), faces.push([ 2 * j, 2 * j + 1, 2 * _i4 + 1 ]);
        }
        return {
            vertices: vertices,
            faces: faces
        };
    }
    function parseEdMesh(mesh) {
        var _step3, vertices = [], _iterator3 = _createForOfIteratorHelper(mesh.vertices);
        try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var vertex = _step3.value;
                vertices.push([ vertex.x, vertex.y, vertex.z ]);
            }
        } catch (err) {
            _iterator3.e(err);
        } finally {
            _iterator3.f();
        }
        var _step4, faces = [], _iterator4 = _createForOfIteratorHelper(mesh.triangles);
        try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                var triangle = _step4.value;
                faces.push([ triangle.i1, triangle.i2, triangle.i3 ]);
            }
        } catch (err) {
            _iterator4.e(err);
        } finally {
            _iterator4.f();
        }
        return {
            vertices: vertices,
            faces: faces
        };
    }
    var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_1_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__),
    __webpack_require__(1)), Ed = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_roslib__),
    function(_EventEmitter) {
        function Ed(robot) {
            var _this;
            _classCallCheck(this, Ed), _this = _super.call(this);
            var ros = robot.ros;
            return _this.queryService = ros.Service({
                name: "ed/query",
                serviceType: "ed_msgs/Query"
            }), _this.resetService = ros.Service({
                name: "ed/reset",
                serviceType: "ed_msgs/Reset"
            }), _this.entities = new Map(), _this.revision = 0, _this;
        }
        _inherits(Ed, _EventEmitter);
        var _super = _createSuper(Ed);
        return _createClass(Ed, [ {
            key: "query",
            value: function(callback) {
                var _this2 = this, request = new __WEBPACK_IMPORTED_MODULE_1_roslib__.ServiceRequest({
                    since_revision: this.revision
                });
                this.queryService.callService(request, function(response) {
                    var new_revision = response.new_revision;
                    if (new_revision <= _this2.revision) return void console.error("ed:query incorrect revision");
                    _this2.revision = new_revision;
                    var data = JSON.parse(response.human_readable);
                    _this2._updateEntities(data.entities), callback && callback();
                }, function(error) {
                    console.error("ed:query callService ".concat(_this2.queryService.name, " failed:"), error);
                });
            }
        }, {
            key: "reset",
            value: function(keepShapes) {
                var request = new __WEBPACK_IMPORTED_MODULE_1_roslib__.ServiceRequest({
                    keep_all_shapes: keepShapes
                });
                this.resetService.callService(request);
            }
        }, {
            key: "watch",
            value: function(callbacks) {
                callbacks.add && this.on("entities.add", callbacks.add), callbacks.update && this.on("entities.update", callbacks.update),
                callbacks.remove && this.on("entities.remove", callbacks.remove);
            }
        }, {
            key: "_updateEntities",
            value: function(entities) {
                var _step, _this3 = this, add = [], update = [], remove = [], _iterator = _createForOfIteratorHelper(entities);
                try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) !function() {
                        var entity = _step.value, id = entity.id, newObject = {
                            id: id
                        };
                        if (_this3.entities.has(id)) {
                            var oldObject = _this3.entities.get(id);
                            if (Object.prototype.hasOwnProperty.call(entity, "pose")) {
                                var _parseEdPosition = parseEdPosition(entity.pose), position = _parseEdPosition.position, quaternion = _parseEdPosition.quaternion;
                                newObject.position = position, newObject.quaternion = quaternion;
                            } else oldObject.position && (newObject.position = oldObject.position), oldObject.quaternion && (newObject.quaternion = oldObject.quaternion);
                            if (Object.prototype.hasOwnProperty.call(entity, "mesh")) {
                                var _parseEdMesh = parseEdMesh(entity.mesh), vertices = _parseEdMesh.vertices, faces = _parseEdMesh.faces;
                                newObject.vertices = vertices, newObject.faces = faces;
                            } else if (Object.prototype.hasOwnProperty.call(entity, "convex_hull")) {
                                var _parseEdConvexHull = parseEdConvexHull(entity.convex_hull), _vertices = _parseEdConvexHull.vertices, _faces = _parseEdConvexHull.faces;
                                newObject.vertices = _vertices, newObject.faces = _faces;
                            } else oldObject.vertices && (newObject.vertices = oldObject.vertices), oldObject.faces && (newObject.faces = oldObject.faces);
                            _this3.entities.set(id, newObject);
                            [ "position", "quaternion", "vertices", "faces" ].every(function(key) {
                                return key in newObject;
                            }) && update.push([ newObject, oldObject ]);
                        } else {
                            if (Object.prototype.hasOwnProperty.call(entity, "pose")) {
                                var _parseEdPosition2 = parseEdPosition(entity.pose), _position = _parseEdPosition2.position, _quaternion = _parseEdPosition2.quaternion;
                                newObject.position = _position, newObject.quaternion = _quaternion;
                            }
                            if (Object.prototype.hasOwnProperty.call(entity, "mesh")) {
                                var _parseEdMesh2 = parseEdMesh(entity.mesh), _vertices2 = _parseEdMesh2.vertices, _faces2 = _parseEdMesh2.faces;
                                newObject.vertices = _vertices2, newObject.faces = _faces2;
                            } else if (Object.prototype.hasOwnProperty.call(entity, "convex_hull")) {
                                var _parseEdConvexHull2 = parseEdConvexHull(entity.convex_hull), _vertices3 = _parseEdConvexHull2.vertices, _faces3 = _parseEdConvexHull2.faces;
                                newObject.vertices = _vertices3, newObject.faces = _faces3;
                            }
                            _this3.entities.set(id, newObject);
                            [ "position", "quaternion", "vertices", "faces" ].every(function(key) {
                                return key in newObject;
                            }) && add.push(newObject);
                        }
                    }();
                } catch (err) {
                    _iterator.e(err);
                } finally {
                    _iterator.f();
                }
                for (var _i = 0, _add = add; _i < _add.length; _i++) {
                    var data = _add[_i];
                    this.emit("entities.add", data);
                }
                for (var _i2 = 0, _update = update; _i2 < _update.length; _i2++) {
                    var _data = _update[_i2];
                    this.emit.apply(this, [ "entities.update" ].concat(_toConsumableArray(_data)));
                }
                for (var _i3 = 0, _remove = remove; _i3 < _remove.length; _i3++) {
                    var _data2 = _remove[_i3];
                    this.emit("entities.remove", _data2);
                }
            }
        } ]), Ed;
    }(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__.EventEmitter2));
    __webpack_exports__.a = Ed;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" == typeof o.length) {
                it && (o = it);
                var i = 0, F = function() {};
                return {
                    s: F,
                    n: function() {
                        return i >= o.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: o[i++]
                        };
                    },
                    e: function(_e) {
                        throw _e;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var err, normalCompletion = !0, didErr = !1;
        return {
            s: function() {
                it = o[Symbol.iterator]();
            },
            n: function() {
                var step = it.next();
                return normalCompletion = step.done, step;
            },
            e: function(_e2) {
                didErr = !0, err = _e2;
            },
            f: function() {
                try {
                    normalCompletion || null == it.return || it.return();
                } finally {
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (o) {
            if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
        }
    }
    function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
    }
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    function diagnosticMessageToStatus(message) {
        var _step, hardware_status = {}, _iterator = _createForOfIteratorHelper(message.status);
        try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _step$value = _step.value, _name2 = _step$value.name, level = _step$value.level, message_info = _step$value.message_info, homed = "homed" === message_info;
                hardware_status[_name2] = {
                    level: level,
                    homed: homed
                };
            }
        } catch (err) {
            _iterator.e(err);
        } finally {
            _iterator.f();
        }
        hardware_status = Object.assign({}, defaultStatus, hardware_status);
        for (var _i2 = 0, _Object$keys2 = Object.keys(hardware_status); _i2 < _Object$keys2.length; _i2++) {
            var _name = _Object$keys2[_i2], part = hardware_status[_name];
            part.actions = getActions(_name, part);
        }
        return hardware_status;
    }
    function getActions(name, part) {
        var props = __WEBPACK_IMPORTED_MODULE_3__hardware_properties__.a[name];
        if (!props) return null;
        var level = part ? part.level : -1, homed = !!part && part.homed, actions = {};
        return props.homeable && (actions.home = {
            enabled: level === levels.IDLE,
            warning: !!homed && "This part was already homed, Are you sure you want to redo homing?"
        }), actions.start = {
            enabled: level === levels.IDLE && (homed || !props.homeable_mandatory),
            warning: !(!props.homeable || homed) && "This part is not yet homed, Are you sure you want to proceed?"
        }, actions.stop = {
            enabled: level === levels.HOMING || level === levels.OPERATIONAL
        }, actions.restart = {
            enabled: !0,
            warning: "This will restart the robot hardware interface, Are you sure you want to proceed?"
        }, props.resetable && (actions.reset = {
            enabled: level === levels.ERROR
        }), actions;
    }
    for (var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_1_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__),
    __webpack_require__(1)), __WEBPACK_IMPORTED_MODULE_2_lodash_debounce__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_roslib__),
    __webpack_require__(94)), __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_debounce__), __WEBPACK_IMPORTED_MODULE_3__hardware_properties__ = __webpack_require__(103), levels = {
        STALE: 0,
        IDLE: 1,
        OPERATIONAL: 2,
        HOMING: 3,
        ERROR: 4
    }, commands = {
        restart: 0,
        home: 21,
        start: 22,
        stop: 23,
        reset: 24
    }, hardwareIds = {
        all: 0,
        base: 1,
        spindle: 2,
        left_arm: 3,
        right_arm: 4,
        head: 5
    }, defaultStatus = {}, _i = 0, _Object$keys = Object.keys(hardwareIds); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        defaultStatus[name] = {
            level: levels.STALE,
            homed: !1
        };
    }
    var HARDWARE_TIMEOUT = 2e3, BATTERY_TIMEOUT = 2e3, EBUTTONS_TIMEOUT = 2e3, Hardware = function(_EventEmitter) {
        function Hardware(robot) {
            var _this;
            _classCallCheck(this, Hardware), _this = _super.call(this), _defineProperty(_assertThisInitialized(_this), "_status", defaultStatus),
            _defineProperty(_assertThisInitialized(_this), "_resetHardwareLater", __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default()(_this._resetHardware, HARDWARE_TIMEOUT)),
            _defineProperty(_assertThisInitialized(_this), "_battery", null), _defineProperty(_assertThisInitialized(_this), "_resetBatteryLater", __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default()(_this._resetBattery, BATTERY_TIMEOUT)),
            _defineProperty(_assertThisInitialized(_this), "_ebuttons", null), _defineProperty(_assertThisInitialized(_this), "_resetEbuttonsLater", __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default()(_this._resetEbuttons, EBUTTONS_TIMEOUT));
            var ros = robot.ros;
            return ros.Topic({
                name: "hardware_status",
                messageType: "diagnostic_msgs/DiagnosticArray",
                throttle_rate: 500
            }).subscribe(_this._onStatus.bind(_assertThisInitialized(_this))), _this._commandTopic = ros.Topic({
                name: "dashboard_ctrlcmds",
                messageType: "std_msgs/UInt8MultiArray"
            }), ros.Topic({
                name: "battery_percentage",
                messageType: "std_msgs/Float32",
                throttle_rate: 200
            }).subscribe(_this._onBattery.bind(_assertThisInitialized(_this))), ros.Topic({
                name: "ebutton_status",
                messageType: "diagnostic_msgs/DiagnosticArray",
                throttle_rate: 200
            }).subscribe(_this._onEbuttons.bind(_assertThisInitialized(_this))), _this;
        }
        _inherits(Hardware, _EventEmitter);
        var _super = _createSuper(Hardware);
        return _createClass(Hardware, [ {
            key: "_onStatus",
            value: function(message) {
                this.status = diagnosticMessageToStatus(message), this._resetHardwareLater();
            }
        }, {
            key: "_resetHardware",
            value: function() {
                console.log("hardware message timeout"), this.status = defaultStatus;
            }
        }, {
            key: "send_command",
            value: function(part, command) {
                if (!Object.prototype.hasOwnProperty.call(hardwareIds, part)) throw new RangeError("Invalid part");
                if (!Object.prototype.hasOwnProperty.call(commands, command)) throw new RangeError("Invalid command");
                var i1 = hardwareIds[part], i2 = commands[command];
                console.log("hardware command: %s %s (%i, %i)", command, part, i1, i2);
                var cmd = new __WEBPACK_IMPORTED_MODULE_1_roslib__.Message({
                    data: [ i1, i2 ]
                });
                this._commandTopic.publish(cmd);
            }
        }, {
            key: "_onBattery",
            value: function(message) {
                var percent = message.data;
                this.battery = percent, this._resetBatteryLater();
            }
        }, {
            key: "_resetBattery",
            value: function() {
                console.log("battery message timeout"), this.battery = null;
            }
        }, {
            key: "_onEbuttons",
            value: function(message) {
                var status = message.status.map(function(_ref) {
                    return {
                        name: _ref.name,
                        level: _ref.level
                    };
                });
                this.ebuttons = status, this._resetEbuttonsLater();
            }
        }, {
            key: "_resetEbuttons",
            value: function() {
                console.log("ebuttons message timeout"), this.ebuttons = null;
            }
        }, {
            key: "status",
            get: function() {
                return this._status;
            },
            set: function(value) {
                this._status = value, this.emit("status", value);
            }
        }, {
            key: "battery",
            get: function() {
                return this._battery;
            },
            set: function(value) {
                this._battery = value, this.emit("battery", value);
            }
        }, {
            key: "ebuttons",
            get: function() {
                return this._ebuttons;
            },
            set: function(value) {
                this._ebuttons = value, this.emit("ebuttons", value);
            }
        } ]), Hardware;
    }(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__.EventEmitter2);
    _defineProperty(Hardware, "levels", levels), __webpack_exports__.a = Hardware;
}, function(module, exports) {
    function isObject(value) {
        var type = typeof value;
        return null != value && ("object" == type || "function" == type);
    }
    module.exports = isObject;
}, function(module, exports, __webpack_require__) {
    var freeGlobal = __webpack_require__(96), freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
}, function(module, exports, __webpack_require__) {
    var root = __webpack_require__(37), Symbol = root.Symbol;
    module.exports = Symbol;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_1_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__),
    __webpack_require__(1)), Head = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_roslib__),
    function(_EventEmitter) {
        function Head(robot) {
            var _this;
            _classCallCheck(this, Head), _this = _super.call(this);
            var ros = robot.ros;
            return _this.getImageService = ros.Service({
                name: "ed/get_image",
                serviceType: "rgbd_msgs/GetRGBD"
            }), _this.goal = null, _this.head_ac = ros.ActionClient({
                serverName: "head_ref/action_server",
                actionName: "head_ref_msgs/HeadReferenceAction"
            }), _this;
        }
        _inherits(Head, _EventEmitter);
        var _super = _createSuper(Head);
        return _createClass(Head, [ {
            key: "getImage",
            value: function() {
                var _this2 = this, width = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128, callback = arguments.length > 1 ? arguments[1] : void 0, request = new __WEBPACK_IMPORTED_MODULE_1_roslib__.ServiceRequest({
                    width: width,
                    compression: 0
                }), start_time = new Date();
                this.getImageService.callService(request, function(response) {
                    var time_diff = new Date() - start_time, rgb_data = response.rgb_data, depth_data = response.depth_data;
                    if (rgb_data) {
                        var rgb_image_url = "data:image/jpeg;base64,".concat(rgb_data), depth_image_url = "data:image/jpeg;base64,".concat(depth_data);
                        callback(rgb_image_url, depth_image_url, time_diff);
                    } else callback(null, null, time_diff);
                    _this2.emit("update_time", time_diff);
                }, function(error) {
                    console.error("Head:getImage callService ".concat(_this2.getImageService.name, " failed:"), error);
                });
            }
        }, {
            key: "sendPanTiltGoal",
            value: function(pan, tilt) {
                this.goal = new __WEBPACK_IMPORTED_MODULE_1_roslib__.Goal({
                    actionClient: this.head_ac,
                    goalMessage: {
                        goal_type: 1,
                        priority: 0,
                        pan_vel: 1,
                        tilt_vel: 1,
                        target_point: {},
                        pan: pan,
                        tilt: tilt,
                        end_time: 0
                    }
                }), this.goal.send();
            }
        }, {
            key: "cancelGoal",
            value: function() {
                this.goal && this.goal.cancel();
            }
        }, {
            key: "cancelAllGoals",
            value: function() {
                this.head_ac.cancel();
            }
        } ]), Head;
    }(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__.EventEmitter2));
    __webpack_exports__.a = Head;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: !0
    }), function(angular) {
        var __WEBPACK_IMPORTED_MODULE_0_bootstrap_dist_css_bootstrap_min_css__ = __webpack_require__(42), __WEBPACK_IMPORTED_MODULE_1_bootstrap_dist_css_bootstrap_css__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bootstrap_dist_css_bootstrap_min_css__),
        __webpack_require__(43)), __WEBPACK_IMPORTED_MODULE_2_angular_circular_navigation_angular_circular_navigation_css__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_bootstrap_dist_css_bootstrap_css__),
        __webpack_require__(44)), __WEBPACK_IMPORTED_MODULE_3_font_awesome_css_font_awesome_min_css__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular_circular_navigation_angular_circular_navigation_css__),
        __webpack_require__(45)), __WEBPACK_IMPORTED_MODULE_4__styles_main_css__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_font_awesome_css_font_awesome_min_css__),
        __webpack_require__(46)), __WEBPACK_IMPORTED_MODULE_5_angular_circular_navigation_angular_circular_navigation__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__styles_main_css__),
        __webpack_require__(47)), __WEBPACK_IMPORTED_MODULE_6_ngdraggable__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_angular_circular_navigation_angular_circular_navigation__),
        __webpack_require__(48)), __WEBPACK_IMPORTED_MODULE_7_bootstrap_js_tab__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_ngdraggable__),
        __webpack_require__(49)), __WEBPACK_IMPORTED_MODULE_8__scripts_app__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_bootstrap_js_tab__),
        __webpack_require__(50)), __WEBPACK_IMPORTED_MODULE_9__scripts_controllers_actions__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__scripts_app__),
        __webpack_require__(51)), __WEBPACK_IMPORTED_MODULE_10__scripts_controllers_circularmenu__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__scripts_controllers_actions__),
        __webpack_require__(52)), __WEBPACK_IMPORTED_MODULE_11__scripts_controllers_connection__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__scripts_controllers_circularmenu__),
        __webpack_require__(53)), __WEBPACK_IMPORTED_MODULE_12__scripts_controllers_ed__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__scripts_controllers_connection__),
        __webpack_require__(54)), __WEBPACK_IMPORTED_MODULE_13__scripts_controllers_jointcontroller__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__scripts_controllers_ed__),
        __webpack_require__(55)), __WEBPACK_IMPORTED_MODULE_14__scripts_controllers_main__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__scripts_controllers_jointcontroller__),
        __webpack_require__(56)), __WEBPACK_IMPORTED_MODULE_15__scripts_controllers_modellist__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__scripts_controllers_main__),
        __webpack_require__(57)), __WEBPACK_IMPORTED_MODULE_16__scripts_controllers_sidebar__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__scripts_controllers_modellist__),
        __webpack_require__(58)), __WEBPACK_IMPORTED_MODULE_17__scripts_controllers_snapshotlist__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16__scripts_controllers_sidebar__),
        __webpack_require__(59)), __WEBPACK_IMPORTED_MODULE_18__scripts_controllers_speech__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__scripts_controllers_snapshotlist__),
        __webpack_require__(60)), __WEBPACK_IMPORTED_MODULE_19__scripts_controllers_teleop__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__scripts_controllers_speech__),
        __webpack_require__(61)), __WEBPACK_IMPORTED_MODULE_20__scripts_controllers_hardware_battery_js__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19__scripts_controllers_teleop__),
        __webpack_require__(62)), __WEBPACK_IMPORTED_MODULE_21__scripts_controllers_hardware_ebuttons_js__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__scripts_controllers_hardware_battery_js__),
        __webpack_require__(63)), __WEBPACK_IMPORTED_MODULE_22__scripts_directives_ngteleopcanvas__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21__scripts_controllers_hardware_ebuttons_js__),
        __webpack_require__(64)), __WEBPACK_IMPORTED_MODULE_24__scripts_orbitControls__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22__scripts_directives_ngteleopcanvas__),
        __webpack_require__(65), __webpack_require__(67)), __WEBPACK_IMPORTED_MODULE_25__scripts_run__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24__scripts_orbitControls__),
        __webpack_require__(68)), __WEBPACK_IMPORTED_MODULE_26__scripts_services_robot__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25__scripts_run__),
        __webpack_require__(70));
        __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26__scripts_services_robot__);
        angular.module("EdGuiApp").run([ "$templateCache", function($templateCache) {
            $templateCache.put("views/scene.html", __webpack_require__(111)), $templateCache.put("views/hardware.html", __webpack_require__(112)),
            $templateCache.put("views/tabs/teleop_tabs/base.html", __webpack_require__(113)),
            $templateCache.put("views/tabs/teleop_tabs/head.html", __webpack_require__(114)),
            $templateCache.put("views/tabs/teleop_tabs/speech.html", __webpack_require__(115)),
            $templateCache.put("views/tabs/teleop_tabs/body.html", __webpack_require__(116)),
            $templateCache.put("views/tabs/teleop_tabs/ed.html", __webpack_require__(117)),
            $templateCache.put("views/tabs/teleop.html", __webpack_require__(118)), $templateCache.put("views/tabs/editor.html", __webpack_require__(119)),
            $templateCache.put("views/tabs/actions.html", __webpack_require__(120));
        } ]);
    }.call(__webpack_exports__, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    (function(__webpack_provided_window_dot_jQuery) {
        /**
 * @license AngularJS v1.8.2
 * (c) 2010-2020 Google LLC. http://angularjs.org
 * License: MIT
 */
        !function(window) {
            "use strict";
            function errorHandlingConfig(config) {
                if (!isObject(config)) return minErrConfig;
                isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN),
                isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled);
            }
            function isValidObjectMaxDepth(maxDepth) {
                return isNumber(maxDepth) && maxDepth > 0;
            }
            function minErr(module, ErrorConstructor) {
                ErrorConstructor = ErrorConstructor || Error;
                var url = "https://errors.angularjs.org/1.8.2/", regex = url.replace(".", "\\.") + "[\\s\\S]*", errRegExp = new RegExp(regex, "g");
                return function() {
                    var paramPrefix, i, code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth);
                    });
                    if (message += template.replace(/\{\d+\}/g, function(match) {
                        var index = +match.slice(1, -1);
                        return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match;
                    }), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled) for (i = 0,
                    paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                    return new ErrorConstructor(message);
                };
            }
            function isArrayLike(obj) {
                if (null == obj || isWindow(obj)) return !1;
                if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
                var length = "length" in Object(obj) && obj.length;
                return isNumber(length) && (length >= 0 && length - 1 in obj || "function" == typeof obj.item);
            }
            function forEach(obj, iterator, context) {
                var key, length;
                if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
                    var isPrimitive = "object" != typeof obj;
                    for (key = 0, length = obj.length; key < length; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
                } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
                return obj;
            }
            function forEachSorted(obj, iterator, context) {
                for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
                return keys;
            }
            function reverseParams(iteratorFn) {
                return function(value, key) {
                    iteratorFn(key, value);
                };
            }
            function nextUid() {
                return ++uid;
            }
            function setHashKey(obj, h) {
                h ? obj.$$hashKey = h : delete obj.$$hashKey;
            }
            function baseExtend(dst, objs, deep) {
                for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
                    var obj = objs[i];
                    if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j], src = obj[key];
                        deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : "__proto__" !== key && (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}),
                        baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
                    }
                }
                return setHashKey(dst, h), dst;
            }
            function extend(dst) {
                return baseExtend(dst, slice.call(arguments, 1), !1);
            }
            function merge(dst) {
                return baseExtend(dst, slice.call(arguments, 1), !0);
            }
            function toInt(str) {
                return parseInt(str, 10);
            }
            function inherit(parent, extra) {
                return extend(Object.create(parent), extra);
            }
            function noop() {}
            function identity($) {
                return $;
            }
            function valueFn(value) {
                return function() {
                    return value;
                };
            }
            function hasCustomToString(obj) {
                return isFunction(obj.toString) && obj.toString !== toString;
            }
            function isUndefined(value) {
                return void 0 === value;
            }
            function isDefined(value) {
                return void 0 !== value;
            }
            function isObject(value) {
                return null !== value && "object" == typeof value;
            }
            function isBlankObject(value) {
                return null !== value && "object" == typeof value && !getPrototypeOf(value);
            }
            function isString(value) {
                return "string" == typeof value;
            }
            function isNumber(value) {
                return "number" == typeof value;
            }
            function isDate(value) {
                return "[object Date]" === toString.call(value);
            }
            function isArray(arr) {
                return Array.isArray(arr) || arr instanceof Array;
            }
            function isError(value) {
                switch (toString.call(value)) {
                  case "[object Error]":
                  case "[object Exception]":
                  case "[object DOMException]":
                    return !0;

                  default:
                    return value instanceof Error;
                }
            }
            function isFunction(value) {
                return "function" == typeof value;
            }
            function isRegExp(value) {
                return "[object RegExp]" === toString.call(value);
            }
            function isWindow(obj) {
                return obj && obj.window === obj;
            }
            function isScope(obj) {
                return obj && obj.$evalAsync && obj.$watch;
            }
            function isFile(obj) {
                return "[object File]" === toString.call(obj);
            }
            function isFormData(obj) {
                return "[object FormData]" === toString.call(obj);
            }
            function isBlob(obj) {
                return "[object Blob]" === toString.call(obj);
            }
            function isBoolean(value) {
                return "boolean" == typeof value;
            }
            function isPromiseLike(obj) {
                return obj && isFunction(obj.then);
            }
            function isTypedArray(value) {
                return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
            }
            function isArrayBuffer(obj) {
                return "[object ArrayBuffer]" === toString.call(obj);
            }
            function isElement(node) {
                return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
            }
            function makeMap(str) {
                var i, obj = {}, items = str.split(",");
                for (i = 0; i < items.length; i++) obj[items[i]] = !0;
                return obj;
            }
            function nodeName_(element) {
                return lowercase(element.nodeName || element[0] && element[0].nodeName);
            }
            function includes(array, obj) {
                return -1 !== Array.prototype.indexOf.call(array, obj);
            }
            function arrayRemove(array, value) {
                var index = array.indexOf(value);
                return index >= 0 && array.splice(index, 1), index;
            }
            function copy(source, destination, maxDepth) {
                function copyRecurse(source, destination, maxDepth) {
                    if (--maxDepth < 0) return "...";
                    var key, h = destination.$$hashKey;
                    if (isArray(source)) for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth)); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key], maxDepth); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
                    return setHashKey(destination, h), destination;
                }
                function copyElement(source, maxDepth) {
                    if (!isObject(source)) return source;
                    var index = stackSource.indexOf(source);
                    if (-1 !== index) return stackDest[index];
                    if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                    var needsRecurse = !1, destination = copyType(source);
                    return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)),
                    needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
                }
                function copyType(source) {
                    switch (toString.call(source)) {
                      case "[object Int8Array]":
                      case "[object Int16Array]":
                      case "[object Int32Array]":
                      case "[object Float32Array]":
                      case "[object Float64Array]":
                      case "[object Uint8Array]":
                      case "[object Uint8ClampedArray]":
                      case "[object Uint16Array]":
                      case "[object Uint32Array]":
                        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

                      case "[object ArrayBuffer]":
                        if (!source.slice) {
                            var copied = new ArrayBuffer(source.byteLength);
                            return new Uint8Array(copied).set(new Uint8Array(source)), copied;
                        }
                        return source.slice(0);

                      case "[object Boolean]":
                      case "[object Number]":
                      case "[object String]":
                      case "[object Date]":
                        return new source.constructor(source.valueOf());

                      case "[object RegExp]":
                        var re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]);
                        return re.lastIndex = source.lastIndex, re;

                      case "[object Blob]":
                        return new source.constructor([ source ], {
                            type: source.type
                        });
                    }
                    if (isFunction(source.cloneNode)) return source.cloneNode(!0);
                }
                var stackSource = [], stackDest = [];
                if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
                    if (isTypedArray(destination) || isArrayBuffer(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                    if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                    return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                        "$$hashKey" !== key && delete destination[key];
                    }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth);
                }
                return copyElement(source, maxDepth);
            }
            function simpleCompare(a, b) {
                return a === b || a !== a && b !== b;
            }
            function equals(o1, o2) {
                if (o1 === o2) return !0;
                if (null === o1 || null === o2) return !1;
                if (o1 !== o1 && o2 !== o2) return !0;
                var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
                if (t1 === t2 && "object" === t1) {
                    if (!isArray(o1)) {
                        if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                        if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                        keySet = createMap();
                        for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                            if (!equals(o1[key], o2[key])) return !1;
                            keySet[key] = !0;
                        }
                        for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                        return !0;
                    }
                    if (!isArray(o2)) return !1;
                    if ((length = o1.length) === o2.length) {
                        for (key = 0; key < length; key++) if (!equals(o1[key], o2[key])) return !1;
                        return !0;
                    }
                }
                return !1;
            }
            function concat(array1, array2, index) {
                return array1.concat(slice.call(array2, index));
            }
            function sliceArgs(args, startIndex) {
                return slice.call(args, startIndex || 0);
            }
            function bind(self, fn) {
                var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
                return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
                    return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                } : function() {
                    return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                };
            }
            function toJsonReplacer(key, value) {
                var val = value;
                return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"),
                val;
            }
            function toJson(obj, pretty) {
                if (!isUndefined(obj)) return isNumber(pretty) || (pretty = pretty ? 2 : null),
                JSON.stringify(obj, toJsonReplacer, pretty);
            }
            function fromJson(json) {
                return isString(json) ? JSON.parse(json) : json;
            }
            function timezoneToOffset(timezone, fallback) {
                timezone = timezone.replace(ALL_COLONS, "");
                var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
                return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
            }
            function addDateMinutes(date, minutes) {
                return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes),
                date;
            }
            function convertTimezoneToLocal(date, timezone, reverse) {
                reverse = reverse ? -1 : 1;
                var dateTimezoneOffset = date.getTimezoneOffset();
                return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset));
            }
            function startingTag(element) {
                element = jqLite(element).clone().empty();
                var elemHtml = jqLite("<div></div>").append(element).html();
                try {
                    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                        return "<" + lowercase(nodeName);
                    });
                } catch (e) {
                    return lowercase(elemHtml);
                }
            }
            function tryDecodeURIComponent(value) {
                try {
                    return decodeURIComponent(value);
                } catch (e) {}
            }
            function parseKeyValue(keyValue) {
                var obj = {};
                return forEach((keyValue || "").split("&"), function(keyValue) {
                    var splitPoint, key, val;
                    keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="),
                    -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)),
                    key = tryDecodeURIComponent(key), isDefined(key) && (val = !isDefined(val) || tryDecodeURIComponent(val),
                    hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
                }), obj;
            }
            function toKeyValue(obj) {
                var parts = [];
                return forEach(obj, function(value, key) {
                    isArray(value) ? forEach(value, function(arrayValue) {
                        parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)));
                    }) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)));
                }), parts.length ? parts.join("&") : "";
            }
            function encodeUriSegment(val) {
                return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
            }
            function getNgAttribute(element, ngAttr) {
                var attr, i, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
                return null;
            }
            function angularInit(element, bootstrap) {
                var appElement, module, config = {};
                if (forEach(ngAttrPrefixes, function(prefix) {
                    var name = prefix + "app";
                    !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element,
                    module = element.getAttribute(name));
                }), forEach(ngAttrPrefixes, function(prefix) {
                    var candidate, name = prefix + "app";
                    !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate,
                    module = candidate.getAttribute(name));
                }), appElement) {
                    if (!isAutoBootstrapAllowed) return void window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
                    config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config);
                }
            }
            function bootstrap(element, modules, config) {
                isObject(config) || (config = {}), config = extend({
                    strictDi: !1
                }, config);
                var doBootstrap = function() {
                    if (element = jqLite(element), element.injector()) {
                        var tag = element[0] === window.document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
                    }
                    modules = modules || [], modules.unshift([ "$provide", function($provide) {
                        $provide.value("$rootElement", element);
                    } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                        $compileProvider.debugInfoEnabled(!0);
                    } ]), modules.unshift("ng");
                    var injector = createInjector(modules, config.strictDi);
                    return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                        scope.$apply(function() {
                            element.data("$injector", injector), compile(element)(scope);
                        });
                    } ]), injector;
                }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
                if (window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0,
                window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name)) return doBootstrap();
                window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function(extraModules) {
                    return forEach(extraModules, function(module) {
                        modules.push(module);
                    }), doBootstrap();
                }, isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap();
            }
            function reloadWithDebugInfo() {
                window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
            }
            function getTestability(rootElement) {
                var injector = angular.element(rootElement).injector();
                if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
                return injector.get("$$testability");
            }
            function snake_case(name, separator) {
                return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                    return (pos ? separator : "") + letter.toLowerCase();
                });
            }
            function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
                JQLite.legacyXHTMLReplacement = !0;
            }
            function assertArg(arg, name, reason) {
                if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
                return arg;
            }
            function assertArgFn(arg, name, acceptArrayAnnotation) {
                return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)),
                arg;
            }
            function assertNotHasOwnProperty(name, context) {
                if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
            }
            function getter(obj, path, bindFnToScope) {
                if (!path) return obj;
                for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i],
                obj && (obj = (lastInstance = obj)[key]);
                return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
            }
            function getBlockNodes(nodes) {
                for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))),
                blockNodes.push(node));
                return blockNodes || nodes;
            }
            function createMap() {
                return Object.create(null);
            }
            function stringify(value) {
                if (null == value) return "";
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
                }
                return value;
            }
            function setupModuleLoader(window) {
                function ensure(obj, name, factory) {
                    return obj[name] || (obj[name] = factory());
                }
                var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
                return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
                    var modules = {};
                    return function(name, requires, configFn) {
                        var info = {};
                        return function(name, context) {
                            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                        }(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null),
                        ensure(modules, name, function() {
                            function invokeLater(provider, method, insertMethod, queue) {
                                return queue || (queue = invokeQueue), function() {
                                    return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                                };
                            }
                            function invokeLaterAndSetModuleName(provider, method, queue) {
                                return queue || (queue = invokeQueue), function(recipeName, factoryFunction) {
                                    return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name),
                                    queue.push([ provider, method, arguments ]), moduleInstance;
                                };
                            }
                            if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                            var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                                _invokeQueue: invokeQueue,
                                _configBlocks: configBlocks,
                                _runBlocks: runBlocks,
                                info: function(value) {
                                    if (isDefined(value)) {
                                        if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                        return info = value, this;
                                    }
                                    return info;
                                },
                                requires: requires,
                                name: name,
                                provider: invokeLaterAndSetModuleName("$provide", "provider"),
                                factory: invokeLaterAndSetModuleName("$provide", "factory"),
                                service: invokeLaterAndSetModuleName("$provide", "service"),
                                value: invokeLater("$provide", "value"),
                                constant: invokeLater("$provide", "constant", "unshift"),
                                decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                                animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                                filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                                controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                                directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                                component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                                config: config,
                                run: function(block) {
                                    return runBlocks.push(block), this;
                                }
                            };
                            return configFn && config(configFn), moduleInstance;
                        });
                    };
                });
            }
            function shallowCopy(src, dst) {
                if (isArray(src)) {
                    dst = dst || [];
                    for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i];
                } else if (isObject(src)) {
                    dst = dst || {};
                    for (var key in src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
                }
                return dst || src;
            }
            function serializeObject(obj, maxDepth) {
                var seen = [];
                return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)),
                JSON.stringify(obj, function(key, val) {
                    if (val = toJsonReplacer(key, val), isObject(val)) {
                        if (seen.indexOf(val) >= 0) return "...";
                        seen.push(val);
                    }
                    return val;
                });
            }
            function toDebugString(obj, maxDepth) {
                return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj, maxDepth) : obj;
            }
            function jqNextId() {
                return ++jqId;
            }
            function cssKebabToCamel(name) {
                return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
            }
            function fnCamelCaseReplace(all, letter) {
                return letter.toUpperCase();
            }
            function kebabToCamel(name) {
                return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            function jqLiteIsTextNode(html) {
                return !HTML_REGEXP.test(html);
            }
            function jqLiteAcceptsData(node) {
                var nodeType = node.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
            }
            function jqLiteHasData(node) {
                for (var key in jqCache[node.ng339]) return !0;
                return !1;
            }
            function jqLiteBuildFragment(html, context) {
                var tmp, tag, wrap, finalHtml, i, fragment = context.createDocumentFragment(), nodes = [];
                if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
                    if (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(),
                    finalHtml = JQLite.legacyXHTMLReplacement ? html.replace(XHTML_TAG_REGEXP, "<$1></$2>") : html,
                    msie < 10) for (wrap = wrapMapIE9[tag] || wrapMapIE9._default, tmp.innerHTML = wrap[1] + finalHtml + wrap[2],
                    i = wrap[0]; i--; ) tmp = tmp.firstChild; else {
                        for (wrap = wrapMap[tag] || [], i = wrap.length; --i > -1; ) tmp.appendChild(window.document.createElement(wrap[i])),
                        tmp = tmp.firstChild;
                        tmp.innerHTML = finalHtml;
                    }
                    nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
                }
                return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
                    fragment.appendChild(node);
                }), fragment;
            }
            function jqLiteParseHTML(html, context) {
                context = context || window.document;
                var parsed;
                return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
            }
            function jqLiteWrapNode(node, wrapper) {
                var parent = node.parentNode;
                parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node);
            }
            function JQLite(element) {
                if (element instanceof JQLite) return element;
                var argIsString;
                if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
                    if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                    return new JQLite(element);
                }
                argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
            }
            function jqLiteClone(element) {
                return element.cloneNode(!0);
            }
            function jqLiteDealoc(element, onlyDescendants) {
                !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([ element ]),
                element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"));
            }
            function isEmptyObject(obj) {
                var name;
                for (name in obj) return !1;
                return !0;
            }
            function removeIfEmptyData(element) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId], events = expandoStore && expandoStore.events, data = expandoStore && expandoStore.data;
                data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId],
                element.ng339 = void 0);
            }
            function jqLiteOff(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
                var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
                if (handle) {
                    if (type) {
                        var removeHandler = function(type) {
                            var listenerFns = events[type];
                            isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle),
                            delete events[type]);
                        };
                        forEach(type.split(" "), function(type) {
                            removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
                        });
                    } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle),
                    delete events[type];
                    removeIfEmptyData(element);
                }
            }
            function jqLiteRemoveData(element, name) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {},
                removeIfEmptyData(element));
            }
            function jqLiteExpandoStore(element, createIfNecessary) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(),
                expandoStore = jqCache[expandoId] = {
                    events: {},
                    data: {},
                    handle: void 0
                }), expandoStore;
            }
            function jqLiteData(element, key, value) {
                if (jqLiteAcceptsData(element)) {
                    var prop, isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
                    if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                        if (massGetter) return data;
                        if (isSimpleGetter) return data && data[kebabToCamel(key)];
                        for (prop in key) data[kebabToCamel(prop)] = key[prop];
                    }
                }
            }
            function jqLiteHasClass(element, selector) {
                return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
            }
            function jqLiteRemoveClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
                    forEach(cssClasses.split(" "), function(cssClass) {
                        cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ");
                    }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
                }
            }
            function jqLiteAddClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
                    forEach(cssClasses.split(" "), function(cssClass) {
                        cssClass = trim(cssClass), -1 === newClasses.indexOf(" " + cssClass + " ") && (newClasses += cssClass + " ");
                    }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
                }
            }
            function jqLiteAddNodes(root, elements) {
                if (elements) if (elements.nodeType) root[root.length++] = elements; else {
                    var length = elements.length;
                    if ("number" == typeof length && elements.window !== elements) {
                        if (length) for (var i = 0; i < length; i++) root[root.length++] = elements[i];
                    } else root[root.length++] = elements;
                }
            }
            function jqLiteController(element, name) {
                return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
            }
            function jqLiteInheritedData(element, name, value) {
                element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
                for (var names = isArray(name) ? name : [ name ]; element; ) {
                    for (var i = 0, ii = names.length; i < ii; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
                    element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
                }
            }
            function jqLiteEmpty(element) {
                for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
            }
            function jqLiteRemove(element, keepData) {
                keepData || jqLiteDealoc(element);
                var parent = element.parentNode;
                parent && parent.removeChild(element);
            }
            function jqLiteDocumentLoaded(action, win) {
                win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
            }
            function jqLiteReady(fn) {
                function trigger() {
                    window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger),
                    fn();
                }
                "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger),
                window.addEventListener("load", trigger));
            }
            function getBooleanAttrName(element, name) {
                var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
                return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
            }
            function getAliasedAttrName(name) {
                return ALIASED_ATTR[name];
            }
            function createEventHandler(element, events) {
                var eventHandler = function(event, type) {
                    event.isDefaultPrevented = function() {
                        return event.defaultPrevented;
                    };
                    var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
                    if (eventFnsLength) {
                        if (isUndefined(event.immediatePropagationStopped)) {
                            var originalStopImmediatePropagation = event.stopImmediatePropagation;
                            event.stopImmediatePropagation = function() {
                                event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(),
                                originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                            };
                        }
                        event.isImmediatePropagationStopped = function() {
                            return !0 === event.immediatePropagationStopped;
                        };
                        var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                        eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                        for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
                    }
                };
                return eventHandler.elem = element, eventHandler;
            }
            function defaultHandlerWrapper(element, event, handler) {
                handler.call(element, event);
            }
            function specialMouseHandlerWrapper(target, event, handler) {
                var related = event.relatedTarget;
                related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event);
            }
            function $$jqLiteProvider() {
                this.$get = function() {
                    return extend(JQLite, {
                        hasClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                        },
                        addClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                        },
                        removeClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                        }
                    });
                };
            }
            function hashKey(obj, nextUidFn) {
                var key = obj && obj.$$hashKey;
                if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
                var objType = typeof obj;
                return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
            }
            function NgMapShim() {
                this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1;
            }
            function stringifyFn(fn) {
                return Function.prototype.toString.call(fn);
            }
            function extractArgs(fn) {
                var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
                return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            }
            function anonFn(fn) {
                var args = extractArgs(fn);
                return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
            }
            function annotate(fn, strictDi, name) {
                var $inject, argDecl, last;
                if ("function" == typeof fn) {
                    if (!($inject = fn.$inject)) {
                        if ($inject = [], fn.length) {
                            if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                            argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                                arg.replace(FN_ARG, function(all, underscore, name) {
                                    $inject.push(name);
                                });
                            });
                        }
                        fn.$inject = $inject;
                    }
                } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
                return $inject;
            }
            function createInjector(modulesToLoad, strictDi) {
                function supportObject(delegate) {
                    return function(key, value) {
                        if (!isObject(key)) return delegate(key, value);
                        forEach(key, reverseParams(delegate));
                    };
                }
                function provider(name, provider_) {
                    if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)),
                    !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                    return providerCache[name + providerSuffix] = provider_;
                }
                function enforceReturnValue(name, factory) {
                    return function() {
                        var result = instanceInjector.invoke(factory, this);
                        if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                        return result;
                    };
                }
                function factory(name, factoryFn, enforce) {
                    return provider(name, {
                        $get: !1 !== enforce ? enforceReturnValue(name, factoryFn) : factoryFn
                    });
                }
                function service(name, constructor) {
                    return factory(name, [ "$injector", function($injector) {
                        return $injector.instantiate(constructor);
                    } ]);
                }
                function value(name, val) {
                    return factory(name, valueFn(val), !1);
                }
                function constant(name, value) {
                    assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
                }
                function decorator(serviceName, decorFn) {
                    var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                    origProvider.$get = function() {
                        var origInstance = instanceInjector.invoke(orig$get, origProvider);
                        return instanceInjector.invoke(decorFn, null, {
                            $delegate: origInstance
                        });
                    };
                }
                function loadModules(modulesToLoad) {
                    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                    var moduleFn, runBlocks = [];
                    return forEach(modulesToLoad, function(module) {
                        function runInvokeQueue(queue) {
                            var i, ii;
                            for (i = 0, ii = queue.length; i < ii; i++) {
                                var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                            }
                        }
                        if (!loadedModules.get(module)) {
                            loadedModules.set(module, !0);
                            try {
                                isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn,
                                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks),
                                runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                            } catch (e) {
                                throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack),
                                $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                            }
                        }
                    }), runBlocks;
                }
                function createInternalInjector(cache, factory) {
                    function getService(serviceName, caller) {
                        if (cache.hasOwnProperty(serviceName)) {
                            if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                            return cache[serviceName];
                        }
                        try {
                            return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller),
                            cache[serviceName];
                        } catch (err) {
                            throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                        } finally {
                            path.shift();
                        }
                    }
                    function injectionArgs(fn, locals, serviceName) {
                        for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                            var key = $inject[i];
                            if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                        }
                        return args;
                    }
                    function isClass(func) {
                        if (msie || "function" != typeof func) return !1;
                        var result = func.$$ngIsClass;
                        return isBoolean(result) || (result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func))),
                        result;
                    }
                    function invoke(fn, self, locals, serviceName) {
                        "string" == typeof locals && (serviceName = locals, locals = null);
                        var args = injectionArgs(fn, locals, serviceName);
                        return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null),
                        new (Function.prototype.bind.apply(fn, args))()) : fn.apply(self, args);
                    }
                    function instantiate(Type, locals, serviceName) {
                        var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                        return args.unshift(null), new (Function.prototype.bind.apply(ctor, args))();
                    }
                    return {
                        invoke: invoke,
                        instantiate: instantiate,
                        get: getService,
                        annotate: createInjector.$$annotate,
                        has: function(name) {
                            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                        }
                    };
                }
                strictDi = !0 === strictDi;
                var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
                    throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
                }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
                }), instanceInjector = protoInstanceInjector;
                providerCache["$injector" + providerSuffix] = {
                    $get: valueFn(protoInstanceInjector)
                }, instanceInjector.modules = providerInjector.modules = createMap();
                var runBlocks = loadModules(modulesToLoad);
                return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi,
                forEach(runBlocks, function(fn) {
                    fn && instanceInjector.invoke(fn);
                }), instanceInjector.loadNewModules = function(mods) {
                    forEach(loadModules(mods), function(fn) {
                        fn && instanceInjector.invoke(fn);
                    });
                }, instanceInjector;
            }
            function $AnchorScrollProvider() {
                var autoScrollingEnabled = !0;
                this.disableAutoScrolling = function() {
                    autoScrollingEnabled = !1;
                }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
                    function getFirstAnchor(list) {
                        var result = null;
                        return Array.prototype.some.call(list, function(element) {
                            if ("a" === nodeName_(element)) return result = element, !0;
                        }), result;
                    }
                    function getYOffset() {
                        var offset = scroll.yOffset;
                        if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                            var elem = offset[0], style = $window.getComputedStyle(elem);
                            offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                        } else isNumber(offset) || (offset = 0);
                        return offset;
                    }
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = getYOffset();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else $window.scrollTo(0, 0);
                    }
                    function scroll(hash) {
                        hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                        var elm;
                        hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
                    }
                    var document = $window.document;
                    return autoScrollingEnabled && $rootScope.$watch(function() {
                        return $location.hash();
                    }, function(newVal, oldVal) {
                        newVal === oldVal && "" === newVal || jqLiteDocumentLoaded(function() {
                            $rootScope.$evalAsync(scroll);
                        });
                    }), scroll;
                } ];
            }
            function mergeClasses(a, b) {
                return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")),
                a + " " + b) : a : b : "";
            }
            function extractElementNode(element) {
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType === ELEMENT_NODE) return elm;
                }
            }
            function splitClasses(classes) {
                isString(classes) && (classes = classes.split(" "));
                var obj = createMap();
                return forEach(classes, function(klass) {
                    klass.length && (obj[klass] = !0);
                }), obj;
            }
            function prepareAnimateOptions(options) {
                return isObject(options) ? options : {};
            }
            function getHash(url) {
                var index = url.indexOf("#");
                return -1 === index ? "" : url.substr(index);
            }
            function trimEmptyHash(url) {
                return url.replace(/#$/, "");
            }
            function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
                function cacheStateAndFireUrlChange() {
                    pendingLocation = null, fireStateOrUrlChange();
                }
                function cacheState() {
                    cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState,
                    equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState,
                    lastHistoryState = cachedState;
                }
                function fireStateOrUrlChange() {
                    var prevLastHistoryState = lastHistoryState;
                    cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(),
                    lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                        listener(self.url(), cachedState);
                    }));
                }
                var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}, taskTracker = $$taskTrackerFactory($log);
                self.isMock = !1, self.$$completeOutstandingRequest = taskTracker.completeTask,
                self.$$incOutstandingRequestCount = taskTracker.incTaskCount, self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
                var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
                    try {
                        return history.state;
                    } catch (e) {}
                } : noop;
                cacheState(), self.url = function(url, replace, state) {
                    if (isUndefined(state) && (state = null), location !== window.location && (location = window.location),
                    history !== window.history && (history = window.history), url) {
                        var sameState = lastHistoryState === state;
                        if (url = urlResolve(url).href, lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                        return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url),
                        replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url,
                        location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url),
                        cacheState()), pendingLocation && (pendingLocation = url), self;
                    }
                    return trimEmptyHash(pendingLocation || location.href);
                }, self.state = function() {
                    return cachedState;
                };
                var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
                self.onUrlChange = function(callback) {
                    return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange),
                    jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0),
                    urlChangeListeners.push(callback), callback;
                }, self.$$applicationDestroyed = function() {
                    jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
                }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
                    var href = baseElement.attr("href");
                    return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
                }, self.defer = function(fn, delay, taskType) {
                    var timeoutId;
                    return delay = delay || 0, taskType = taskType || taskTracker.DEFAULT_TASK_TYPE,
                    taskTracker.incTaskCount(taskType), timeoutId = setTimeout(function() {
                        delete pendingDeferIds[timeoutId], taskTracker.completeTask(fn, taskType);
                    }, delay), pendingDeferIds[timeoutId] = taskType, timeoutId;
                }, self.defer.cancel = function(deferId) {
                    if (pendingDeferIds.hasOwnProperty(deferId)) {
                        var taskType = pendingDeferIds[deferId];
                        return delete pendingDeferIds[deferId], clearTimeout(deferId), taskTracker.completeTask(noop, taskType),
                        !0;
                    }
                    return !1;
                };
            }
            function $BrowserProvider() {
                this.$get = [ "$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
                    return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
                } ];
            }
            function $CacheFactoryProvider() {
                this.$get = function() {
                    function cacheFactory(cacheId, options) {
                        function refresh(entry) {
                            entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry,
                            link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                        }
                        function link(nextEntry, prevEntry) {
                            nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                        }
                        if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                        var size = 0, stats = extend({}, options, {
                            id: cacheId
                        }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                        return caches[cacheId] = {
                            put: function(key, value) {
                                if (!isUndefined(value)) {
                                    if (capacity < Number.MAX_VALUE) {
                                        refresh(lruHash[key] || (lruHash[key] = {
                                            key: key
                                        }));
                                    }
                                    return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key),
                                    value;
                                }
                            },
                            get: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    refresh(lruEntry);
                                }
                                return data[key];
                            },
                            remove: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n),
                                    link(lruEntry.n, lruEntry.p), delete lruHash[key];
                                }
                                key in data && (delete data[key], size--);
                            },
                            removeAll: function() {
                                data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                            },
                            destroy: function() {
                                data = null, stats = null, lruHash = null, delete caches[cacheId];
                            },
                            info: function() {
                                return extend({}, stats, {
                                    size: size
                                });
                            }
                        };
                    }
                    var caches = {};
                    return cacheFactory.info = function() {
                        var info = {};
                        return forEach(caches, function(cache, cacheId) {
                            info[cacheId] = cache.info();
                        }), info;
                    }, cacheFactory.get = function(cacheId) {
                        return caches[cacheId];
                    }, cacheFactory;
                };
            }
            function $TemplateCacheProvider() {
                this.$get = [ "$cacheFactory", function($cacheFactory) {
                    return $cacheFactory("templates");
                } ];
            }
            function UNINITIALIZED_VALUE() {}
            function $CompileProvider($provide, $$sanitizeUriProvider) {
                function parseIsolateBindings(scope, directiveName, isController) {
                    var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/, bindings = createMap();
                    return forEach(scope, function(definition, scopeName) {
                        if ((definition = definition.trim()) in bindingCache) return void (bindings[scopeName] = bindingCache[definition]);
                        var match = definition.match(LOCAL_REGEXP);
                        if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                        bindings[scopeName] = {
                            mode: match[1][0],
                            collection: "*" === match[2],
                            optional: "?" === match[3],
                            attrName: match[4] || scopeName
                        }, match[4] && (bindingCache[definition] = bindings[scopeName]);
                    }), bindings;
                }
                function parseDirectiveBindings(directive, directiveName) {
                    var bindings = {
                        isolateScope: null,
                        bindToController: null
                    };
                    if (isObject(directive.scope) && (!0 === directive.bindToController ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0),
                    bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)),
                    isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)),
                    bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                    return bindings;
                }
                function assertValidDirectiveName(name) {
                    var letter = name.charAt(0);
                    if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                    if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
                }
                function getDirectiveRequire(directive) {
                    var require = directive.require || directive.controller && directive.name;
                    return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                        var match = value.match(REQUIRE_PREFIX_REGEXP);
                        value.substring(match[0].length) || (require[key] = match[0] + key);
                    }), require;
                }
                function getDirectiveRestrict(restrict, name) {
                    if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                    return restrict || "EA";
                }
                var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
                this.directive = function registerDirective(name, directiveFactory) {
                    return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name),
                    assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [],
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        return forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                isFunction(directive) ? directive = {
                                    compile: valueFn(directive)
                                } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)),
                                directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name,
                                directive.require = getDirectiveRequire(directive), directive.restrict = getDirectiveRestrict(directive.restrict, name),
                                directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }), directives;
                    } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)),
                    this;
                }, this.component = function registerComponent(name, options) {
                    function factory($injector) {
                        function makeInjectable(fn) {
                            return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                                return $injector.invoke(fn, this, {
                                    $element: tElement,
                                    $attrs: tAttrs
                                });
                            } : fn;
                        }
                        var template = options.template || options.templateUrl ? options.template : "", ddo = {
                            controller: controller,
                            controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                            template: makeInjectable(template),
                            templateUrl: makeInjectable(options.templateUrl),
                            transclude: options.transclude,
                            scope: {},
                            bindToController: options.bindings || {},
                            restrict: "E",
                            require: options.require
                        };
                        return forEach(options, function(val, key) {
                            "$" === key.charAt(0) && (ddo[key] = val);
                        }), ddo;
                    }
                    if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))),
                    this;
                    var controller = options.controller || function() {};
                    return forEach(options, function(val, key) {
                        "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
                    }), factory.$inject = [ "$injector" ], this.directive(name, factory);
                }, this.aHrefSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp),
                    this) : $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
                }, Object.defineProperty(this, "aHrefSanitizationWhitelist", {
                    get: function() {
                        return this.aHrefSanitizationTrustedUrlList;
                    },
                    set: function(value) {
                        this.aHrefSanitizationTrustedUrlList = value;
                    }
                }), this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp),
                    this) : $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
                }, Object.defineProperty(this, "imgSrcSanitizationWhitelist", {
                    get: function() {
                        return this.imgSrcSanitizationTrustedUrlList;
                    },
                    set: function(value) {
                        this.imgSrcSanitizationTrustedUrlList = value;
                    }
                });
                var debugInfoEnabled = !0;
                this.debugInfoEnabled = function(enabled) {
                    return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
                };
                var strictComponentBindingsEnabled = !1;
                this.strictComponentBindingsEnabled = function(enabled) {
                    return isDefined(enabled) ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled;
                };
                var TTL = 10;
                this.onChangesTtl = function(value) {
                    return arguments.length ? (TTL = value, this) : TTL;
                };
                var commentDirectivesEnabledConfig = !0;
                this.commentDirectivesEnabled = function(value) {
                    return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
                };
                var cssClassDirectivesEnabledConfig = !0;
                this.cssClassDirectivesEnabled = function(value) {
                    return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
                };
                var PROP_CONTEXTS = createMap();
                this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
                    var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
                    if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
                    return PROP_CONTEXTS[key] = ctx, this;
                }, function() {
                    function registerContext(ctx, values) {
                        forEach(values, function(v) {
                            PROP_CONTEXTS[v.toLowerCase()] = ctx;
                        });
                    }
                    registerContext(SCE_CONTEXTS.HTML, [ "iframe|srcdoc", "*|innerHTML", "*|outerHTML" ]),
                    registerContext(SCE_CONTEXTS.CSS, [ "*|style" ]), registerContext(SCE_CONTEXTS.URL, [ "area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite" ]),
                    registerContext(SCE_CONTEXTS.MEDIA_URL, [ "audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster" ]),
                    registerContext(SCE_CONTEXTS.RESOURCE_URL, [ "*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src" ]);
                }(), this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            $rootScope.$apply(function() {
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                                    onChangesQueue[i]();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                onChangesQueue = void 0;
                            });
                        } finally {
                            onChangesTtl++;
                        }
                    }
                    function sanitizeSrcset(value, invokeType) {
                        if (!value) return value;
                        if (!isString(value)) throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        return result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])),
                        result;
                    }
                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var i, l, key, keys = Object.keys(attributesToCopy);
                            for (i = 0, l = keys.length; i < l; i++) key = keys[i], this[key] = attributesToCopy[key];
                        } else this.$attr = {};
                        this.$$element = element;
                    }
                    function setSpecialAttr(element, attrName, value) {
                        specialAttrHolder.innerHTML = "<span " + attrName + ">";
                        var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
                    }
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) {}
                    }
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function(scope, cloneConnectFn, options) {
                            if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                            assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()),
                            options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                            parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude),
                            namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                            var $linkNode;
                            if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes,
                            transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                            return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope),
                            compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn),
                            cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                        };
                    }
                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html";
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i],
                                stableNodeList[idx] = nodeList[idx];
                            } else stableNodeList = nodeList;
                            for (i = 0, ii = linkFns.length; i < ii; ) node = stableNodeList[linkFns[i++]],
                            nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(),
                            compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null,
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                        }
                        for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes(),
                        11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective),
                        nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null,
                        nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn),
                        (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0,
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                        return linkFnFound ? compositeLinkFn : null;
                    }
                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var sibling, node = nodeList[idx], parent = node.parentNode;
                        if (node.nodeType === NODE_TYPE_TEXT) for (;;) {
                            if (!(sibling = parent ? node.nextSibling : nodeList[idx + 1]) || sibling.nodeType !== NODE_TYPE_TEXT) break;
                            node.nodeValue = node.nodeValue + sibling.nodeValue, sibling.parentNode && sibling.parentNode.removeChild(sibling),
                            notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
                        }
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            return transcludedScope || (transcludedScope = scope.$new(!1, containingScope),
                            transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            });
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                        switch (nodeType) {
                          case NODE_TYPE_ELEMENT:
                            nodeName = nodeName_(node), addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                var multiElementMatch, attrStartName = !1, attrEndName = !1, isNgAttr = !1, isNgProp = !1, isNgEvent = !1;
                                attr = nAttrs[j], name = attr.name, value = attr.value, nName = directiveNormalize(name.toLowerCase()),
                                (ngPrefixMatch = nName.match(NG_PREFIX_BINDING)) ? (isNgAttr = "Attr" === ngPrefixMatch[1],
                                isNgProp = "Prop" === ngPrefixMatch[1], isNgEvent = "On" === ngPrefixMatch[1], name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, function(match, letter) {
                                    return letter.toUpperCase();
                                })) : (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name,
                                attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)),
                                isNgProp || isNgEvent ? (attrs[nName] = value, attrsMap[nName] = attr.name, isNgProp ? addPropertyDirective(node, directives, nName, name) : addEventDirective(directives, nName, name)) : (nName = directiveNormalize(name.toLowerCase()),
                                attrsMap[nName] = name, !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value,
                                getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr),
                                addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName));
                            }
                            if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"),
                            !cssClassDirectivesEnabled) break;
                            if (className = node.className, isObject(className) && (className = className.animVal),
                            isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]),
                            addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])),
                            className = className.substr(match.index + match[0].length);
                            break;

                          case NODE_TYPE_TEXT:
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;

                          case NODE_TYPE_COMMENT:
                            if (!commentDirectivesEnabled) break;
                            collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                        }
                        return directives.sort(byPriority), directives;
                    }
                    function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        try {
                            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            if (match) {
                                var nName = directiveNormalize(match[1]);
                                addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]));
                            }
                        } catch (e) {}
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [], depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) do {
                            if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                            node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++,
                            node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                        } while (depth > 0); else nodes.push(node);
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function(scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                            return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext),
                            $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)),
                            pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                isolateScope: !0
                            })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)),
                            post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                isolateScope: !0
                            })), postLinkFns.push(post));
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn,
                                cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers),
                                futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element),
                                !slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                            }
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode),
                            attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent),
                            boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn,
                            transcludeFn.isSlotFilled = function(slotName) {
                                return !!boundTranscludeFn.$$slots[slotName];
                            }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)),
                            newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))),
                            compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings,
                            scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective),
                            scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                                controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance),
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            }
                            for (forEach(controllerDirectives, function(controllerDirective, name) {
                                var require = controllerDirective.require;
                                controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                            }), forEach(elementControllers, function(controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$onChanges)) try {
                                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                if (isFunction(controllerInstance.$onInit)) try {
                                    controllerInstance.$onInit();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                                    controllerInstance.$doCheck();
                                }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                                    controllerInstance.$onDestroy();
                                });
                            }), i = 0, ii = preLinkFns.length; i < ii; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope),
                            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn),
                            i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            forEach(elementControllers, function(controller) {
                                var controllerInstance = controller.instance;
                                isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                            });
                        }
                        previousCompileContext = previousCompileContext || {};
                        for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start, attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0,
                            terminalPriority > directive.priority) break;
                            if (directiveValue = directive.scope, directiveValue && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode),
                            newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)),
                            newScopeDirective = newScopeDirective || directive), directiveName = directive.name,
                            !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                    mightHaveMultipleTransclusionError = !0;
                                    break;
                                }
                                didScanForMultipleTransclusion = !0;
                            }
                            if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(),
                            assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode),
                            controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0,
                            directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode),
                            nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0,
                            terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])),
                            compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode),
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            }); else {
                                var slots = createMap();
                                if (isObject(directiveValue)) {
                                    $template = window.document.createDocumentFragment();
                                    var slotMap = createMap(), filledSlots = createMap();
                                    forEach(directiveValue, function(elementSelector, slotName) {
                                        var optional = "?" === elementSelector.charAt(0);
                                        elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName,
                                        slots[slotName] = null, filledSlots[slotName] = optional;
                                    }), forEach($compileNode.contents(), function(node) {
                                        var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                        slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(),
                                        slots[slotName].appendChild(node)) : $template.appendChild(node);
                                    }), forEach(filledSlots, function(filled, slotName) {
                                        if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                    });
                                    for (var slotName in slots) if (slots[slotName]) {
                                        var slotCompileNodes = jqLite(slots[slotName].childNodes);
                                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn);
                                    }
                                    $template = jqLite($template.childNodes);
                                } else $template = jqLite(jqLiteClone(compileNode)).contents();
                                $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                                    needsNewScope: directive.$$isolateScope || directive.$$newScope
                                }), childTranscludeFn.$$slots = slots;
                            }
                            if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode),
                            templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template,
                            directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))),
                                compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                replaceWith(jqCollection, $compileNode, compileNode);
                                var newTemplateAttrs = {
                                    $attr: {}
                                }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective),
                                directives = directives.concat(templateDirectives).concat(unprocessedDirectives),
                                mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                            } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode),
                            templateDirective = directive, directive.replace && (replaceDirective = directive),
                            nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                controllerDirectives: controllerDirectives,
                                newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                newIsolateScopeDirective: newIsolateScopeDirective,
                                templateDirective: templateDirective,
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            }), ii = directives.length; else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                var context = directive.$$originalDirective || directive;
                                isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode));
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                        }
                        return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective,
                        nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn,
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective,
                        nodeLinkFn;
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                            if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name],
                            value = value && value.instance), !value) {
                                var dataName = "$" + name + "Controller";
                                value = "^^" === inheritType && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT ? null : inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                        } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                            value[property] = getControllers(directiveName, controller, $element, elementControllers);
                        }));
                        return value || null;
                    }
                    function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var elementControllers = createMap();
                        for (var controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey], locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controller = directive.controller;
                            "@" === controller && (controller = attrs[directive.name]);
                            var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                        }
                        return elementControllers;
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: isolateScope,
                            $$newScope: newScope
                        });
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) if (directive = directives[i],
                        (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                            if (startAttrName && (directive = inherit(directive, {
                                $$start: startAttrName,
                                $$end: endAttrName
                            })), !directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope);
                            }
                            tDirectives.push(directive), match = directive;
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) if (directive = directives[i],
                        directive.multiElement) return !0;
                        return !1;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr, dstAttr = dst.$attr;
                        forEach(dst, function(value, key) {
                            "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]),
                            dst.$set(key, value, !0, srcAttr[key]));
                        }), forEach(src, function(value, key) {
                            dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                        });
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                            templateUrl: null,
                            transclude: null,
                            replace: null,
                            $$originalDirective: origAsyncDirective
                        }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                            var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                            if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))),
                                compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                tempTemplateAttrs = {
                                    $attr: {}
                                }, replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0),
                                directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                            for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext),
                            forEach($rootElement, function(node, i) {
                                node === compileNode && ($rootElement[i] = $compileNode[0]);
                            }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                                var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                if (!scope.$$destroyed) {
                                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                        var oldClasses = beforeTemplateLinkNode.className;
                                        previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)),
                                        replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                                    }
                                    childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn,
                                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                                }
                            }
                            linkQueue = null;
                        }).catch(function(error) {
                            isError(error) && $exceptionHandler(error);
                        }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)),
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : "";
                        }
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                    }
                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, !0);
                        interpolateFn && directives.push({
                            priority: 0,
                            compile: function(templateNode) {
                                var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                                    var parent = node.parent();
                                    hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions),
                                    scope.$watch(interpolateFn, function(value) {
                                        node[0].nodeValue = value;
                                    });
                                };
                            }
                        });
                    }
                    function wrapTemplate(type, template) {
                        switch (type = lowercase(type || "html")) {
                          case "svg":
                          case "math":
                            var wrapper = window.document.createElement("div");
                            return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                          default:
                            return template;
                        }
                    }
                    function getTrustedAttrContext(nodeName, attrNormalizedName) {
                        return "srcdoc" === attrNormalizedName ? $sce.HTML : "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? -1 === [ "img", "video", "audio", "source", "track" ].indexOf(nodeName) ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === nodeName ? $sce.MEDIA_URL : "a" === nodeName ? $sce.URL : $sce.RESOURCE_URL : "form" === nodeName && "action" === attrNormalizedName || "base" === nodeName && "href" === attrNormalizedName || "link" === nodeName && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== nodeName || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL;
                    }
                    function getTrustedPropContext(nodeName, propNormalizedName) {
                        var prop = propNormalizedName.toLowerCase();
                        return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop];
                    }
                    function sanitizeSrcsetPropertyValue(value) {
                        return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
                    }
                    function addPropertyDirective(node, directives, attrName, propName) {
                        if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                        var nodeName = nodeName_(node), trustedContext = getTrustedPropContext(nodeName, propName), sanitizer = identity;
                        "srcset" !== propName || "img" !== nodeName && "source" !== nodeName ? trustedContext && (sanitizer = $sce.getTrusted.bind($sce, trustedContext)) : sanitizer = sanitizeSrcsetPropertyValue,
                        directives.push({
                            priority: 100,
                            compile: function(_, attr) {
                                var ngPropGetter = $parse(attr[attrName]), ngPropWatch = $parse(attr[attrName], function(val) {
                                    return $sce.valueOf(val);
                                });
                                return {
                                    pre: function(scope, $element) {
                                        function applyPropValue() {
                                            var propValue = ngPropGetter(scope);
                                            $element[0][propName] = sanitizer(propValue);
                                        }
                                        applyPropValue(), scope.$watch(ngPropWatch, applyPropValue);
                                    }
                                };
                            }
                        });
                    }
                    function addEventDirective(directives, attrName, eventName) {
                        directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, !1));
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var nodeName = nodeName_(node), trustedContext = getTrustedAttrContext(nodeName, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (interpolateFn) {
                            if ("multiple" === name && "select" === nodeName) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                            directives.push({
                                priority: 100,
                                compile: function() {
                                    return {
                                        pre: function(scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                            newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing),
                                            value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0,
                                            (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                                "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                            }));
                                        }
                                    };
                                }
                            });
                        }
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                        if ($rootElement) for (i = 0, ii = $rootElement.length; i < ii; i++) if ($rootElement[i] === firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++,
                            j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                            $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                            break;
                        }
                        parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                        for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)),
                        jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")),
                        i = 1; i < removeCount; i++) delete elementsToRemove[i];
                        elementsToRemove[0] = newNode, elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function() {
                            return fn.apply(null, arguments);
                        }, fn, annotation);
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function strictBindingsCheck(attrName, directiveName) {
                        if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        function recordChanges(key, currentValue, previousValue) {
                            isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue),
                            onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)),
                            changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                        }
                        function triggerOnChangesHook() {
                            destination.$onChanges(changes), changes = void 0;
                        }
                        var changes, removeWatchCollection = [], initialChanges = {};
                        return forEach(bindings, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                            switch (mode) {
                              case "@":
                                optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name),
                                destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, function(value) {
                                    if (isString(value) || isBoolean(value)) {
                                        var oldValue = destination[scopeName];
                                        recordChanges(scopeName, value, oldValue), destination[scopeName] = value;
                                    }
                                }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue),
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]),
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "=":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName]) break;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare,
                                parentSet = parentGet.assign || function() {
                                    throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                                }, lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function(parentValue) {
                                    return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue),
                                    lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal),
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "<":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName]) break;
                                parentGet = $parse(attrs[attrName]);
                                var isLiteral = parentGet.literal, initialValue = destination[scopeName] = parentGet(scope);
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]),
                                removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function(newValue, oldValue) {
                                    if (oldValue === newValue) {
                                        if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                        oldValue = initialValue;
                                    }
                                    recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                                }), removeWatchCollection.push(removeWatch);
                                break;

                              case "&":
                                if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name),
                                (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop) === noop && optional) break;
                                destination[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                            }
                        }), {
                            initialChanges: initialChanges,
                            removeWatches: removeWatchCollection.length && function() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]();
                            }
                        };
                    }
                    var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                        },
                        $removeClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                        },
                        $updateClass: function(newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                        },
                        $set: function(key, value, writeAttr, attrName) {
                            var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                            booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value,
                            observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key]) || (this.$attr[key] = attrName = snake_case(key, "-")),
                            nodeName = nodeName_(this.$$element), "img" === nodeName && "srcset" === key && (this[key] = value = sanitizeSrcset(value, "$set('srcset', value)")),
                            !1 !== writeAttr && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? booleanKey && !1 === value ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], function(fn) {
                                try {
                                    fn(value);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            });
                        },
                        $observe: function(key, fn) {
                            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn), $rootScope.$evalAsync(function() {
                                listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                            }), function() {
                                arrayRemove(listeners, fn);
                            };
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                    }, NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding),
                        $element.data("$binding", bindings);
                    } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                        safeAddClass($element, "ng-binding");
                    } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope);
                    } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
                    } : noop, compile.$$createComment = function(directiveName, comment) {
                        var content = "";
                        return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")),
                        window.document.createComment(content);
                    }, compile;
                } ];
            }
            function SimpleChange(previous, current) {
                this.previousValue = previous, this.currentValue = current;
            }
            function directiveNormalize(name) {
                return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                });
            }
            function tokenDifference(str1, str2) {
                var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                    values += (values.length > 0 ? " " : "") + token;
                }
                return values;
            }
            function removeComments(jqNodes) {
                jqNodes = jqLite(jqNodes);
                var i = jqNodes.length;
                if (i <= 1) return jqNodes;
                for (;i--; ) {
                    var node = jqNodes[i];
                    (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
                }
                return jqNodes;
            }
            function identifierForController(controller, ident) {
                if (ident && isString(ident)) return ident;
                if (isString(controller)) {
                    var match = CNTRL_REG.exec(controller);
                    if (match) return match[3];
                }
            }
            function $ControllerProvider() {
                var controllers = {};
                this.has = function(name) {
                    return controllers.hasOwnProperty(name);
                }, this.register = function(name, constructor) {
                    assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
                }, this.$get = [ "$injector", function($injector) {
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                        locals.$scope[identifier] = instance;
                    }
                    return function(expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        if (later = !0 === later, ident && isString(ident) && (identifier = ident), isString(expression)) {
                            if (!(match = expression.match(CNTRL_REG))) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                            if (constructor = match[1], identifier = identifier || match[3], !(expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0))) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                            assertArgFn(expression, constructor, !0);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name),
                            extend(function() {
                                var result = $injector.invoke(expression, instance, locals, constructor);
                                return result !== instance && (isObject(result) || isFunction(result)) && (instance = result,
                                identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)),
                                instance;
                            }, {
                                instance: instance,
                                identifier: identifier
                            });
                        }
                        return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name),
                        instance;
                    };
                } ];
            }
            function $DocumentProvider() {
                this.$get = [ "$window", function(window) {
                    return jqLite(window.document);
                } ];
            }
            function $$IsDocumentHiddenProvider() {
                this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
                    function changeListener() {
                        hidden = doc.hidden;
                    }
                    var doc = $document[0], hidden = doc && doc.hidden;
                    return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                        $document.off("visibilitychange", changeListener);
                    }), function() {
                        return hidden;
                    };
                } ];
            }
            function $ExceptionHandlerProvider() {
                this.$get = [ "$log", function($log) {
                    return function(exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                } ];
            }
            function serializeValue(v) {
                return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
            }
            function $HttpParamSerializerProvider() {
                this.$get = function() {
                    return function(params) {
                        if (!params) return "";
                        var parts = [];
                        return forEachSorted(params, function(value, key) {
                            null === value || isUndefined(value) || isFunction(value) || (isArray(value) ? forEach(value, function(v) {
                                parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                            }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                        }), parts.join("&");
                    };
                };
            }
            function $HttpParamSerializerJQLikeProvider() {
                this.$get = function() {
                    return function(params) {
                        function serialize(toSerialize, prefix, topLevel) {
                            isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                                serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                            }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                                serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                            }) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))));
                        }
                        if (!params) return "";
                        var parts = [];
                        return serialize(params, "", !0), parts.join("&");
                    };
                };
            }
            function defaultHttpResponseTransform(data, headers) {
                if (isString(data)) {
                    var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                    if (tempData) {
                        var contentType = headers("Content-Type"), hasJsonContentType = contentType && 0 === contentType.indexOf(APPLICATION_JSON);
                        if (hasJsonContentType || isJsonLike(tempData)) try {
                            data = fromJson(tempData);
                        } catch (e) {
                            if (!hasJsonContentType) return data;
                            throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                        }
                    }
                }
                return data;
            }
            function isJsonLike(str) {
                var jsonStart = str.match(JSON_START);
                return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
            }
            function parseHeaders(headers) {
                function fillInParsed(key, val) {
                    key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
                }
                var i, parsed = createMap();
                return isString(headers) ? forEach(headers.split("\n"), function(line) {
                    i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal));
                }), parsed;
            }
            function headersGetter(headers) {
                var headersObj;
                return function(name) {
                    if (headersObj || (headersObj = parseHeaders(headers)), name) {
                        var value = headersObj[lowercase(name)];
                        return void 0 === value && (value = null), value;
                    }
                    return headersObj;
                };
            }
            function transformData(data, headers, status, fns) {
                return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
                    data = fn(data, headers, status);
                }), data);
            }
            function isSuccess(status) {
                return 200 <= status && status < 300;
            }
            function $HttpProvider() {
                var defaults = this.defaults = {
                    transformResponse: [ defaultHttpResponseTransform ],
                    transformRequest: [ function(d) {
                        return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
                    } ],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    paramSerializer: "$httpParamSerializer",
                    jsonpCallbackParam: "callback"
                }, useApplyAsync = !1;
                this.useApplyAsync = function(value) {
                    return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
                };
                var interceptorFactories = this.interceptors = [], xsrfTrustedOrigins = this.xsrfTrustedOrigins = [];
                Object.defineProperty(this, "xsrfWhitelistedOrigins", {
                    get: function() {
                        return this.xsrfTrustedOrigins;
                    },
                    set: function(origins) {
                        this.xsrfTrustedOrigins = origins;
                    }
                }), this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                    function $http(requestConfig) {
                        function chainInterceptors(promise, interceptors) {
                            for (var i = 0, ii = interceptors.length; i < ii; ) {
                                var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                                promise = promise.then(thenFn, rejectFn);
                            }
                            return interceptors.length = 0, promise;
                        }
                        function completeOutstandingRequest() {
                            $browser.$$completeOutstandingRequest(noop, "$http");
                        }
                        function executeHeaderFns(headers, config) {
                            var headerContent, processedHeaders = {};
                            return forEach(headers, function(headerFn, header) {
                                isFunction(headerFn) ? null != (headerContent = headerFn(config)) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn;
                            }), processedHeaders;
                        }
                        function serverRequest(config) {
                            var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                            return isUndefined(reqData) && forEach(headers, function(value, header) {
                                "content-type" === lowercase(header) && delete headers[header];
                            }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials),
                            sendReq(config, reqData).then(transformResponse, transformResponse);
                        }
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse),
                            isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                        if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                        if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                        var config = extend({
                            method: "get",
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse,
                            paramSerializer: defaults.paramSerializer,
                            jsonpCallbackParam: defaults.jsonpCallbackParam
                        }, requestConfig);
                        config.headers = function(config) {
                            var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration: for (defHeaderName in defHeaders) {
                                lowercaseDefHeaderName = lowercase(defHeaderName);
                                for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                            }
                            return executeHeaderFns(reqHeaders, shallowCopy(config));
                        }(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer,
                        $browser.$$incOutstandingRequestCount("$http");
                        var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                        return forEach(reversedInterceptors, function(interceptor) {
                            (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError),
                            (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                        }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest),
                        promise = chainInterceptors(promise, responseInterceptors), promise = promise.finally(completeOutstandingRequest);
                    }
                    function sendReq(config, reqData) {
                        function createApplyHandlers(eventHandlers) {
                            if (eventHandlers) {
                                var applyHandlers = {};
                                return forEach(eventHandlers, function(eventHandler, key) {
                                    applyHandlers[key] = function(event) {
                                        function callEventHandler() {
                                            eventHandler(event);
                                        }
                                        useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                                    };
                                }), applyHandlers;
                            }
                        }
                        function done(status, response, headersString, statusText, xhrStatus) {
                            function resolveHttpPromise() {
                                resolvePromise(response, status, headersString, statusText, xhrStatus);
                            }
                            cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]) : cache.remove(url)),
                            useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(),
                            $rootScope.$$phase || $rootScope.$apply());
                        }
                        function resolvePromise(response, status, headers, statusText, xhrStatus) {
                            status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText,
                                xhrStatus: xhrStatus
                            });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            -1 !== idx && $http.pendingRequests.splice(idx, 1);
                        }
                        var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                        if (isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url)),
                        url = buildUrl(url, config.paramSerializer(config.params)), isJsonp && (url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam)),
                        $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq),
                        !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache),
                        cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]) : resolvePromise(cachedResp, 200, {}, "OK", "complete") : cache.put(url, promise)),
                        isUndefined(cachedResp)) {
                            var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                            xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue),
                            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                        }
                        return promise;
                    }
                    function buildUrl(url, serializedParams) {
                        return serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams),
                        url;
                    }
                    function sanitizeJsonpCallbackParam(url, cbKey) {
                        var parts = url.split("?");
                        if (parts.length > 2) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                        return forEach(parseKeyValue(parts[1]), function(value, key) {
                            if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                            if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                        }), url += (-1 === url.indexOf("?") ? "?" : "&") + cbKey + "=JSON_CALLBACK";
                    }
                    var defaultCache = $cacheFactory("$http");
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, function(interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    });
                    var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfTrustedOrigins);
                    return $http.pendingRequests = [], function(names) {
                        forEach(arguments, function(name) {
                            $http[name] = function(url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url
                                }));
                            };
                        });
                    }("get", "delete", "head", "jsonp"), function(name) {
                        forEach(arguments, function(name) {
                            $http[name] = function(url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }));
                            };
                        });
                    }("post", "put", "patch"), $http.defaults = defaults, $http;
                } ];
            }
            function $xhrFactoryProvider() {
                this.$get = function() {
                    return function() {
                        return new window.XMLHttpRequest();
                    };
                };
            }
            function $HttpBackendProvider() {
                this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
                    return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
                } ];
            }
            function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                function jsonpReq(url, callbackPath, done) {
                    url = url.replace("JSON_CALLBACK", callbackPath);
                    var script = rawDocument.createElement("script"), callback = null;
                    return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                        script.removeEventListener("load", callback), script.removeEventListener("error", callback),
                        rawDocument.body.removeChild(script), script = null;
                        var status = -1, text = "unknown";
                        event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                            type: "error"
                        }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
                    }, script.addEventListener("load", callback), script.addEventListener("error", callback),
                    rawDocument.body.appendChild(script), callback;
                }
                return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                    function timeoutRequest(reason) {
                        abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort();
                    }
                    function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                        isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null,
                        callback(status, response, headersString, statusText, xhrStatus);
                    }
                    if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                        var response = 200 === status && callbacks.getResponse(callbackPath);
                        completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath);
                    }); else {
                        var xhr = createXhr(method, url), abortedByTimeout = !1;
                        xhr.open(method, url, !0), forEach(headers, function(value, key) {
                            isDefined(value) && xhr.setRequestHeader(key, value);
                        }), xhr.onload = function() {
                            var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                            0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0),
                            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                        };
                        var requestError = function() {
                            completeRequest(callback, -1, null, null, "", "error");
                        }, requestAborted = function() {
                            completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
                        }, requestTimeout = function() {
                            completeRequest(callback, -1, null, null, "", "timeout");
                        };
                        if (xhr.onerror = requestError, xhr.ontimeout = requestTimeout, xhr.onabort = requestAborted,
                        forEach(eventHandlers, function(value, key) {
                            xhr.addEventListener(key, value);
                        }), forEach(uploadEventHandlers, function(value, key) {
                            xhr.upload.addEventListener(key, value);
                        }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                            xhr.responseType = responseType;
                        } catch (e) {
                            if ("json" !== responseType) throw e;
                        }
                        xhr.send(isUndefined(post) ? null : post);
                    }
                    if (timeout > 0) var timeoutId = $browserDefer(function() {
                        timeoutRequest("timeout");
                    }, timeout); else isPromiseLike(timeout) && timeout.then(function() {
                        timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
                    });
                };
            }
            function $InterpolateProvider() {
                var startSymbol = "{{", endSymbol = "}}";
                this.startSymbol = function(value) {
                    return value ? (startSymbol = value, this) : startSymbol;
                }, this.endSymbol = function(value) {
                    return value ? (endSymbol = value, this) : endSymbol;
                }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
                    function escape(ch) {
                        return "\\\\\\" + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                        var unwatch = scope.$watch(function(scope) {
                            return unwatch(), constantInterp(scope);
                        }, listener, objectEquality);
                        return unwatch;
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        function parseStringifyInterceptor(value) {
                            try {
                                return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value),
                                allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        }
                        var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                        if (!text.length || -1 === text.indexOf(startSymbol)) {
                            if (mustHaveExpression) return;
                            var unescapedText = unescapeText(text);
                            contextAllowsConcatenation && (unescapedText = $sce.getTrusted(trustedContext, unescapedText));
                            var constantInterp = valueFn(unescapedText);
                            return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate,
                            constantInterp;
                        }
                        allOrNothing = !!allOrNothing;
                        for (var startIndex, endIndex, parseFns, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength; ) {
                            if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                                index !== textLength && concat.push(unescapeText(text.substring(index)));
                                break;
                            }
                            index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))),
                            exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp),
                            index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("");
                        }
                        singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                        var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : parseStringifyInterceptor;
                        if (parseFns = expressions.map(function(exp) {
                            return $parse(exp, interceptor);
                        }), !mustHaveExpression || expressions.length) {
                            var compute = function(values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i])) return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text),
                                concat.join(""));
                            };
                            return extend(function(context) {
                                var i = 0, ii = expressions.length, values = new Array(ii);
                                try {
                                    for (;i < ii; i++) values[i] = parseFns[i](context);
                                    return compute(values);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }, {
                                exp: text,
                                expressions: expressions,
                                $$watchDelegate: function(scope, listener) {
                                    var lastValue;
                                    return scope.$watchGroup(parseFns, function(values, oldValues) {
                                        var currValue = compute(values);
                                        listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope),
                                        lastValue = currValue;
                                    });
                                }
                            });
                        }
                    }
                    var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                    return $interpolate.startSymbol = function() {
                        return startSymbol;
                    }, $interpolate.endSymbol = function() {
                        return endSymbol;
                    }, $interpolate;
                } ];
            }
            function $IntervalProvider() {
                this.$get = [ "$$intervalFactory", "$window", function($$intervalFactory, $window) {
                    var intervals = {}, setIntervalFn = function(tick, delay, deferred) {
                        var id = $window.setInterval(tick, delay);
                        return intervals[id] = deferred, id;
                    }, clearIntervalFn = function(id) {
                        $window.clearInterval(id), delete intervals[id];
                    }, interval = $$intervalFactory(setIntervalFn, clearIntervalFn);
                    return interval.cancel = function(promise) {
                        if (!promise) return !1;
                        if (!promise.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                        if (!intervals.hasOwnProperty(promise.$$intervalId)) return !1;
                        var id = promise.$$intervalId, deferred = intervals[id];
                        return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), clearIntervalFn(id),
                        !0;
                    }, interval;
                } ];
            }
            function $$IntervalFactoryProvider() {
                this.$get = [ "$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
                    return function(setIntervalFn, clearIntervalFn) {
                        return function(fn, delay, count, invokeApply) {
                            function callback() {
                                hasParams ? fn.apply(null, args) : fn(iteration);
                            }
                            function tick() {
                                skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++),
                                count > 0 && iteration >= count && (deferred.resolve(iteration), clearIntervalFn(promise.$$intervalId)),
                                skipApply || $rootScope.$apply();
                            }
                            var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                            return count = isDefined(count) ? count : 0, promise.$$intervalId = setIntervalFn(tick, delay, deferred, skipApply),
                            promise;
                        };
                    };
                } ];
            }
            function encodePath(path) {
                for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
                return segments.join("/");
            }
            function decodePath(path, html5Mode) {
                for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = decodeURIComponent(segments[i]),
                html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
                return segments.join("/");
            }
            function normalizePath(pathValue, searchValue, hashValue) {
                var search = toKeyValue(searchValue), hash = hashValue ? "#" + encodeUriSegment(hashValue) : "";
                return encodePath(pathValue) + (search ? "?" + search : "") + hash;
            }
            function parseAbsoluteUrl(absoluteUrl, locationObj) {
                var parsedUrl = urlResolve(absoluteUrl);
                locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname,
                locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
            }
            function parseAppUrl(url, locationObj, html5Mode) {
                if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
                var prefixed = "/" !== url.charAt(0);
                prefixed && (url = "/" + url);
                var match = urlResolve(url), path = prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
                locationObj.$$path = decodePath(path, html5Mode), locationObj.$$search = parseKeyValue(match.search),
                locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
            }
            function startsWith(str, search) {
                return str.slice(0, search.length) === search;
            }
            function stripBaseUrl(base, url) {
                if (startsWith(url, base)) return url.substr(base.length);
            }
            function stripHash(url) {
                var index = url.indexOf("#");
                return -1 === index ? url : url.substr(0, index);
            }
            function stripFile(url) {
                return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
            }
            function serverBase(url) {
                return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
            }
            function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
                this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this),
                this.$$parse = function(url) {
                    var pathUrl = stripBaseUrl(appBaseNoFile, url);
                    if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                    parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose();
                }, this.$$normalizeUrl = function(url) {
                    return appBaseNoFile + url.substr(1);
                }, this.$$parseLinkUrl = function(url, relHref) {
                    if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
                    var appUrl, prevAppUrl, rewrittenUrl;
                    return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile),
                    rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
                };
            }
            function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
                parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                    var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                    isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "",
                    isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl),
                    isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this, !1),
                    this.$$path = function(path, url, base) {
                        var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                        return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path),
                        firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
                    }(this.$$path, withoutHashUrl, appBase), this.$$compose();
                }, this.$$normalizeUrl = function(url) {
                    return appBase + (url ? hashPrefix + url : "");
                }, this.$$parseLinkUrl = function(url, relHref) {
                    return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0);
                };
            }
            function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
                this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
                    if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
                    var rewrittenUrl, appUrl;
                    return appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile),
                    rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
                }, this.$$normalizeUrl = function(url) {
                    return appBase + hashPrefix + url;
                };
            }
            function locationGetter(property) {
                return function() {
                    return this[property];
                };
            }
            function locationGetterSetter(property, preprocess) {
                return function(value) {
                    return isUndefined(value) ? this[property] : (this[property] = preprocess(value),
                    this.$$compose(), this);
                };
            }
            function $LocationProvider() {
                var hashPrefix = "!", html5Mode = {
                    enabled: !1,
                    requireBase: !0,
                    rewriteLinks: !0
                };
                this.hashPrefix = function(prefix) {
                    return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
                }, this.html5Mode = function(mode) {
                    return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled),
                    isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks),
                    this) : html5Mode;
                }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
                    function urlsEqual(a, b) {
                        return a === b || urlResolve(a).href === urlResolve(b).href;
                    }
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url(), oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state), $location.$$state = $browser.state();
                        } catch (e) {
                            throw $location.url(oldUrl), $location.$$state = oldState, e;
                        }
                    }
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                    var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                        appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                    var appBaseNoFile = stripFile(appBase);
                    $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl),
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    $rootElement.on("click", function(event) {
                        var rewriteLinks = html5Mode.rewriteLinks;
                        if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                            for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                            if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                                var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                                isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href),
                                IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(),
                                $location.absUrl() !== $browser.url() && $rootScope.$apply());
                            }
                        }
                    }), $location.absUrl() !== initialUrl && $browser.url($location.absUrl(), !0);
                    var initializing = !0;
                    return $browser.onUrlChange(function(newUrl, newState) {
                        if (!startsWith(newUrl, appBaseNoFile)) return void ($window.location.href = newUrl);
                        $rootScope.$evalAsync(function() {
                            var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                            $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented,
                            $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl),
                            $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1,
                            afterLocationChange(oldUrl, oldState)));
                        }), $rootScope.$$phase || $rootScope.$digest();
                    }), $rootScope.$watch(function() {
                        if (initializing || $location.$$urlUpdatedByLocation) {
                            $location.$$urlUpdatedByLocation = !1;
                            var oldUrl = $browser.url(), newUrl = $location.absUrl(), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = !urlsEqual(oldUrl, newUrl) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                            (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                                var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl),
                                $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state),
                                afterLocationChange(oldUrl, oldState)));
                            }));
                        }
                        $location.$$replace = !1;
                    }), $location;
                } ];
            }
            function $LogProvider() {
                var debug = !0, self = this;
                this.debugEnabled = function(flag) {
                    return isDefined(flag) ? (debug = flag, this) : debug;
                }, this.$get = [ "$window", function($window) {
                    function formatError(arg) {
                        return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)),
                        arg;
                    }
                    function consoleLog(type) {
                        var console = $window.console || {}, logFn = console[type] || console.log || noop;
                        return function() {
                            var args = [];
                            return forEach(arguments, function(arg) {
                                args.push(formatError(arg));
                            }), Function.prototype.apply.call(logFn, console, args);
                        };
                    }
                    var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: function() {
                            var fn = consoleLog("debug");
                            return function() {
                                debug && fn.apply(self, arguments);
                            };
                        }()
                    };
                } ];
            }
            function getStringValue(name) {
                return name + "";
            }
            function ifDefined(v, d) {
                return void 0 !== v ? v : d;
            }
            function plusFn(l, r) {
                return void 0 === l ? r : void 0 === r ? l : l + r;
            }
            function isStateless($filter, filterName) {
                return !$filter(filterName).$stateful;
            }
            function isPure(node, parentIsPure) {
                switch (node.type) {
                  case AST.MemberExpression:
                    if (node.computed) return !1;
                    break;

                  case AST.UnaryExpression:
                    return PURITY_ABSOLUTE;

                  case AST.BinaryExpression:
                    return "+" !== node.operator && PURITY_ABSOLUTE;

                  case AST.CallExpression:
                    return !1;
                }
                return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure;
            }
            function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
                var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = isPure(ast, parentIsPure);
                switch (ast.type) {
                  case AST.Program:
                    allConstants = !0, forEach(ast.body, function(expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant;
                    }), ast.constant = allConstants;
                    break;

                  case AST.Literal:
                    ast.constant = !0, ast.toWatch = [];
                    break;

                  case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant,
                    ast.toWatch = ast.argument.toWatch;
                    break;

                  case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure),
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;

                  case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure),
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure),
                    findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant,
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.Identifier:
                    ast.constant = !1, ast.toWatch = [ ast ];
                    break;

                  case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure),
                    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant),
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.CallExpression:
                    isStatelessFilter = !!ast.filter && isStateless($filter, ast.callee.name), allConstants = isStatelessFilter,
                    argsToWatch = [], forEach(ast.arguments, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant,
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
                    break;

                  case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure),
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
                    break;

                  case AST.ArrayExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant,
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;

                  case AST.ObjectExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                        findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant,
                        argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1),
                        allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch));
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;

                  case AST.ThisExpression:
                  case AST.LocalsExpression:
                    ast.constant = !1, ast.toWatch = [];
                }
            }
            function getInputs(body) {
                if (1 === body.length) {
                    var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
                    return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0;
                }
            }
            function isAssignable(ast) {
                return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
            }
            function assignableAST(ast) {
                if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
                    type: AST.AssignmentExpression,
                    left: ast.body[0].expression,
                    right: {
                        type: AST.NGValueParameter
                    },
                    operator: "="
                };
            }
            function isLiteral(ast) {
                return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
            }
            function isConstant(ast) {
                return ast.constant;
            }
            function ASTCompiler($filter) {
                this.$filter = $filter;
            }
            function ASTInterpreter($filter) {
                this.$filter = $filter;
            }
            function Parser(lexer, $filter, options) {
                this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
            }
            function getValueOf(value) {
                return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
            }
            function $ParseProvider() {
                var identStart, identContinue, cache = createMap(), literals = {
                    true: !0,
                    false: !1,
                    null: null,
                    undefined: void 0
                };
                this.addLiteral = function(literalName, literalValue) {
                    literals[literalName] = literalValue;
                }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
                    return identStart = identifierStart, identContinue = identifierContinue, this;
                }, this.$get = [ "$filter", function($filter) {
                    function $parse(exp, interceptorFn) {
                        var parsedExpression, cacheKey;
                        switch (typeof exp) {
                          case "string":
                            if (exp = exp.trim(), cacheKey = exp, !(parsedExpression = cache[cacheKey])) {
                                parsedExpression = new Parser(new Lexer($parseOptions), $filter, $parseOptions).parse(exp),
                                cache[cacheKey] = addWatchDelegate(parsedExpression);
                            }
                            return addInterceptor(parsedExpression, interceptorFn);

                          case "function":
                            return addInterceptor(exp, interceptorFn);

                          default:
                            return addInterceptor(noop, interceptorFn);
                        }
                    }
                    function $$getAst(exp) {
                        return new Parser(new Lexer($parseOptions), $filter, $parseOptions).getAst(exp).ast;
                    }
                    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                        return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" == typeof newValue && "object" == typeof (newValue = getValueOf(newValue)) && !compareObjectIdentity) && (newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue);
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var lastResult, inputExpressions = parsedExpression.inputs;
                        if (1 === inputExpressions.length) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                                var newInputValue = inputExpressions(scope);
                                return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]),
                                oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                            }, listener, objectEquality, prettyPrintExpression);
                        }
                        for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck,
                        oldInputValues[i] = null;
                        return scope.$watch(function(scope) {
                            for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                                var newInputValue = inputExpressions[i](scope);
                                (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) && (oldInputValues[i] = newInputValue,
                                oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                            }
                            return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)),
                            lastResult;
                        }, listener, objectEquality, prettyPrintExpression);
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        function unwatchIfDone() {
                            isDone(lastValue) && unwatch();
                        }
                        function oneTimeWatch(scope, locals, assign, inputs) {
                            return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs),
                            isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue);
                        }
                        var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined, exp = parsedExpression.$$intercepted || parsedExpression, post = parsedExpression.$$interceptor || identity, useInputs = parsedExpression.inputs && !exp.inputs;
                        return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant,
                        oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
                    }
                    function isAllDefined(value) {
                        var allDefined = !0;
                        return forEach(value, function(val) {
                            isDefined(val) || (allDefined = !1);
                        }), allDefined;
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch = scope.$watch(function(scope) {
                            return unwatch(), parsedExpression(scope);
                        }, listener, objectEquality);
                        return unwatch;
                    }
                    function addWatchDelegate(parsedExpression) {
                        return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate),
                        parsedExpression;
                    }
                    function chainInterceptors(first, second) {
                        function chainedInterceptor(value) {
                            return second(first(value));
                        }
                        return chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure,
                        chainedInterceptor;
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn) return parsedExpression;
                        parsedExpression.$$interceptor && (interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn),
                        parsedExpression = parsedExpression.$$intercepted);
                        var useInputs = !1, fn = function(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value);
                        };
                        return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal,
                        fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant,
                        interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ],
                        interceptorFn.$$pure || (fn.inputs = fn.inputs.map(function(e) {
                            return e.isPure === PURITY_RELATIVE ? function(s) {
                                return e(s);
                            } : e;
                        }))), addWatchDelegate(fn);
                    }
                    var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                        csp: noUnsafeEval,
                        literals: copy(literals),
                        isIdentifierStart: isFunction(identStart) && identStart,
                        isIdentifierContinue: isFunction(identContinue) && identContinue
                    };
                    return $parse.$$getAst = $$getAst, $parse;
                } ];
            }
            function $QProvider() {
                var errorOnUnhandledRejections = !0;
                this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
                    return qFactory(function(callback) {
                        $rootScope.$evalAsync(callback);
                    }, $exceptionHandler, errorOnUnhandledRejections);
                } ], this.errorOnUnhandledRejections = function(value) {
                    return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
                };
            }
            function $$QProvider() {
                var errorOnUnhandledRejections = !0;
                this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
                    return qFactory(function(callback) {
                        $browser.defer(callback);
                    }, $exceptionHandler, errorOnUnhandledRejections);
                } ], this.errorOnUnhandledRejections = function(value) {
                    return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
                };
            }
            function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
                function defer() {
                    return new Deferred();
                }
                function Deferred() {
                    var promise = this.promise = new Promise();
                    this.resolve = function(val) {
                        resolvePromise(promise, val);
                    }, this.reject = function(reason) {
                        rejectPromise(promise, reason);
                    }, this.notify = function(progress) {
                        notifyPromise(promise, progress);
                    };
                }
                function Promise() {
                    this.$$state = {
                        status: 0
                    };
                }
                function processQueue(state) {
                    var fn, promise, pending;
                    pending = state.pending, state.processScheduled = !1, state.pending = void 0;
                    try {
                        for (var i = 0, ii = pending.length; i < ii; ++i) {
                            markQStateExceptionHandled(state), promise = pending[i][0], fn = pending[i][state.status];
                            try {
                                isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value);
                            } catch (e) {
                                rejectPromise(promise, e), e && !0 === e.$$passToExceptionHandler && exceptionHandler(e);
                            }
                        }
                    } finally {
                        --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
                    }
                }
                function processChecks() {
                    for (;!queueSize && checkQueue.length; ) {
                        var toCheck = checkQueue.shift();
                        if (!isStateExceptionHandled(toCheck)) {
                            markQStateExceptionHandled(toCheck);
                            var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                            isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage);
                        }
                    }
                }
                function scheduleProcessQueue(state) {
                    !errorOnUnhandledRejections || state.pending || 2 !== state.status || isStateExceptionHandled(state) || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks),
                    checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0,
                    ++queueSize, nextTick(function() {
                        processQueue(state);
                    }));
                }
                function resolvePromise(promise, val) {
                    promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val));
                }
                function $$resolve(promise, val) {
                    function doResolve(val) {
                        done || (done = !0, $$resolve(promise, val));
                    }
                    function doReject(val) {
                        done || (done = !0, $$reject(promise, val));
                    }
                    function doNotify(progress) {
                        notifyPromise(promise, progress);
                    }
                    var then, done = !1;
                    try {
                        (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1,
                        then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1,
                        scheduleProcessQueue(promise.$$state));
                    } catch (e) {
                        doReject(e);
                    }
                }
                function rejectPromise(promise, reason) {
                    promise.$$state.status || $$reject(promise, reason);
                }
                function $$reject(promise, reason) {
                    promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
                }
                function notifyPromise(promise, progress) {
                    var callbacks = promise.$$state.pending;
                    promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                        for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0], callback = callbacks[i][3];
                            try {
                                notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
                function reject(reason) {
                    var result = new Promise();
                    return rejectPromise(result, reason), result;
                }
                function handleCallback(value, resolver, callback) {
                    var callbackOutput = null;
                    try {
                        isFunction(callback) && (callbackOutput = callback());
                    } catch (e) {
                        return reject(e);
                    }
                    return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                        return resolver(value);
                    }, reject) : resolver(value);
                }
                function when(value, callback, errback, progressBack) {
                    var result = new Promise();
                    return resolvePromise(result, value), result.then(callback, errback, progressBack);
                }
                function all(promises) {
                    var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
                    return forEach(promises, function(promise, key) {
                        counter++, when(promise).then(function(value) {
                            results[key] = value, --counter || resolvePromise(result, results);
                        }, function(reason) {
                            rejectPromise(result, reason);
                        });
                    }), 0 === counter && resolvePromise(result, results), result;
                }
                function race(promises) {
                    var deferred = defer();
                    return forEach(promises, function(promise) {
                        when(promise).then(deferred.resolve, deferred.reject);
                    }), deferred.promise;
                }
                function $Q(resolver) {
                    function resolveFn(value) {
                        resolvePromise(promise, value);
                    }
                    function rejectFn(reason) {
                        rejectPromise(promise, reason);
                    }
                    if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                    var promise = new Promise();
                    return resolver(resolveFn, rejectFn), promise;
                }
                var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
                extend(Promise.prototype, {
                    then: function(onFulfilled, onRejected, progressBack) {
                        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                        var result = new Promise();
                        return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]),
                        this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result;
                    },
                    catch: function(callback) {
                        return this.then(null, callback);
                    },
                    finally: function(callback, progressBack) {
                        return this.then(function(value) {
                            return handleCallback(value, resolve, callback);
                        }, function(error) {
                            return handleCallback(error, reject, callback);
                        }, progressBack);
                    }
                });
                var resolve = when;
                return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when,
                $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q;
            }
            function isStateExceptionHandled(state) {
                return !!state.pur;
            }
            function markQStateExceptionHandled(state) {
                state.pur = !0;
            }
            function markQExceptionHandled(q) {
                q.$$state && markQStateExceptionHandled(q.$$state);
            }
            function $$RAFProvider() {
                this.$get = [ "$window", "$timeout", function($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                        var id = requestAnimationFrame(fn);
                        return function() {
                            cancelAnimationFrame(id);
                        };
                    } : function(fn) {
                        var timer = $timeout(fn, 16.66, !1);
                        return function() {
                            $timeout.cancel(timer);
                        };
                    };
                    return raf.supported = rafSupported, raf;
                } ];
            }
            function $RootScopeProvider() {
                function createChildScopeClass(parent) {
                    function ChildScope() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null,
                        this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(),
                        this.$$ChildScope = null, this.$$suspended = !1;
                    }
                    return ChildScope.prototype = parent, ChildScope;
                }
                var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
                this.digestTtl = function(value) {
                    return arguments.length && (TTL = value), TTL;
                }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = !0;
                    }
                    function cleanUpScope($scope) {
                        9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)),
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null,
                        this.$root = this, this.$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {},
                        this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null;
                    }
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while (current = current.$parent);
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name];
                        } while (current = current.$parent);
                    }
                    function initWatchVal() {}
                    function flushApplyAsync() {
                        for (;applyAsyncQueue.length; ) try {
                            applyAsyncQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        applyAsyncId = null;
                    }
                    function scheduleApplyAsync() {
                        null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                            $rootScope.$apply(flushApplyAsync);
                        }, null, "$applyAsync"));
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function(isolate, parent) {
                            var child;
                            return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)),
                            child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail,
                            parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child,
                            (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child;
                        },
                        $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp), fn = isFunction(listener) ? listener : noop;
                            if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                            var scope = this, array = scope.$$watchers, watcher = {
                                fn: fn,
                                last: initWatchVal,
                                get: get,
                                exp: prettyPrintExpression || watchExp,
                                eq: !!objectEquality
                            };
                            return lastDirtyWatch = null, array || (array = scope.$$watchers = [], array.$$digestWatchIndex = -1),
                            array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1),
                            function() {
                                var index = arrayRemove(array, watcher);
                                index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--),
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function(watchExpressions, listener) {
                            function watchGroupAction() {
                                changeReactionScheduled = !1;
                                try {
                                    firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                                } finally {
                                    for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i];
                                }
                            }
                            var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                            if (!watchExpressions.length) {
                                var shouldCall = !0;
                                return self.$evalAsync(function() {
                                    shouldCall && listener(newValues, newValues, self);
                                }), function() {
                                    shouldCall = !1;
                                };
                            }
                            return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                                newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                            }) : (forEach(watchExpressions, function(expr, i) {
                                var unwatchFn = self.$watch(expr, function(value) {
                                    newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0,
                                    self.$evalAsync(watchGroupAction));
                                });
                                deregisterFns.push(unwatchFn);
                            }), function() {
                                for (;deregisterFns.length; ) deregisterFns.shift()();
                            });
                        },
                        $watchCollection: function(obj, listener) {
                            function $watchCollectionInterceptor(_value) {
                                newValue = _value;
                                var newLength, key, newItem, oldItem;
                                if (!isUndefined(newValue)) {
                                    if (isObject(newValue)) if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0,
                                        changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++,
                                        oldValue.length = oldLength = newLength);
                                        for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i],
                                        oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++,
                                        oldValue[i] = newItem);
                                    } else {
                                        oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++),
                                        newLength = 0;
                                        for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key],
                                        oldItem = oldValue[key], key in oldValue ? oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++,
                                        oldValue[key] = newItem) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key]);
                                        }
                                    } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                    return changeDetected;
                                }
                            }
                            function $watchCollectionAction() {
                                if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self),
                                trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                                    veryOldValue = new Array(newValue.length);
                                    for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                                } else {
                                    veryOldValue = {};
                                    for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                                } else veryOldValue = newValue;
                            }
                            $watchCollectionInterceptor.$$pure = $parse(obj).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                            var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                            return this.$watch(changeDetector, $watchCollectionAction);
                        },
                        $digest: function() {
                            var watch, value, last, fn, get, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = asyncQueue.length ? $rootScope : this, watchLog = [];
                            beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId),
                            flushApplyAsync()), lastDirtyWatch = null;
                            do {
                                dirty = !1, current = target;
                                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                    try {
                                        asyncTask = asyncQueue[asyncQueuePosition], fn = asyncTask.fn, fn(asyncTask.scope, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                asyncQueue.length = 0;
                                traverseScopesLoop: do {
                                    if (watchers = !current.$$suspended && current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                        if (watch = watchers[watchers.$$digestWatchIndex]) if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                            if (watch === lastDirtyWatch) {
                                                dirty = !1;
                                                break traverseScopesLoop;
                                            }
                                        } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value,
                                        fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), ttl < 5 && (logIdx = 4 - ttl,
                                        watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                            msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                            newVal: value,
                                            oldVal: last
                                        }));
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                                } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                            } while (dirty || asyncQueue.length);
                            for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                                postDigestQueue[postDigestQueuePosition++]();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange();
                        },
                        $suspend: function() {
                            this.$$suspended = !0;
                        },
                        $isSuspended: function() {
                            return this.$$suspended;
                        },
                        $resume: function() {
                            this.$$suspended = !1;
                        },
                        $destroy: function() {
                            if (!this.$$destroyed) {
                                var parent = this.$parent;
                                this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(),
                                incrementWatchersCount(this, -this.$$watchersCount);
                                for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                                parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling),
                                parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling),
                                this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling),
                                this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop,
                                this.$on = this.$watch = this.$watchGroup = function() {
                                    return noop;
                                }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this);
                            }
                        },
                        $eval: function(expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function(expr, locals) {
                            $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                                asyncQueue.length && $rootScope.$digest();
                            }, null, "$evalAsync"), asyncQueue.push({
                                scope: this,
                                fn: $parse(expr),
                                locals: locals
                            });
                        },
                        $$postDigest: function(fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function(expr) {
                            try {
                                beginPhase("$apply");
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    throw $exceptionHandler(e), e;
                                }
                            }
                        },
                        $applyAsync: function(expr) {
                            function $applyAsyncExpression() {
                                scope.$eval(expr);
                            }
                            var scope = this;
                            expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync();
                        },
                        $on: function(name, listener) {
                            var namedListeners = this.$$listeners[name];
                            namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                            var current = this;
                            do {
                                current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++;
                            } while (current = current.$parent);
                            var self = this;
                            return function() {
                                var indexOfListener = namedListeners.indexOf(listener);
                                -1 !== indexOfListener && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name));
                            };
                        },
                        $emit: function(name, args) {
                            var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                                name: name,
                                targetScope: scope,
                                stopPropagation: function() {
                                    stopPropagation = !0;
                                },
                                preventDefault: function() {
                                    event.defaultPrevented = !0;
                                },
                                defaultPrevented: !1
                            }, listenerArgs = concat([ event ], arguments, 1);
                            do {
                                for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope,
                                i = 0, length = namedListeners.length; i < length; i++) if (namedListeners[i]) try {
                                    namedListeners[i].apply(null, listenerArgs);
                                } catch (e) {
                                    $exceptionHandler(e);
                                } else namedListeners.splice(i, 1), i--, length--;
                                if (stopPropagation) break;
                                scope = scope.$parent;
                            } while (scope);
                            return event.currentScope = null, event;
                        },
                        $broadcast: function(name, args) {
                            var target = this, current = target, next = target, event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function() {
                                    event.defaultPrevented = !0;
                                },
                                defaultPrevented: !1
                            };
                            if (!target.$$listenerCount[name]) return event;
                            for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                                for (event.currentScope = current, listeners = current.$$listeners[name] || [],
                                i = 0, length = listeners.length; i < length; i++) if (listeners[i]) try {
                                    listeners[i].apply(null, listenerArgs);
                                } catch (e) {
                                    $exceptionHandler(e);
                                } else listeners.splice(i, 1), i--, length--;
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                            }
                            return event.currentScope = null, event;
                        }
                    };
                    var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
                    return $rootScope;
                } ];
            }
            function $$SanitizeUriProvider() {
                var aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
                this.aHrefSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? (aHrefSanitizationTrustedUrlList = regexp, this) : aHrefSanitizationTrustedUrlList;
                }, this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? (imgSrcSanitizationTrustedUrlList = regexp, this) : imgSrcSanitizationTrustedUrlList;
                }, this.$get = function() {
                    return function(uri, isMediaUrl) {
                        var regex = isMediaUrl ? imgSrcSanitizationTrustedUrlList : aHrefSanitizationTrustedUrlList, normalizedVal = urlResolve(uri && uri.trim()).href;
                        return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
                    };
                };
            }
            function snakeToCamel(name) {
                return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            function adjustMatcher(matcher) {
                if ("self" === matcher) return matcher;
                if (isString(matcher)) {
                    if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                    return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"),
                    new RegExp("^" + matcher + "$");
                }
                if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
                throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
            }
            function adjustMatchers(matchers) {
                var adjustedMatchers = [];
                return isDefined(matchers) && forEach(matchers, function(matcher) {
                    adjustedMatchers.push(adjustMatcher(matcher));
                }), adjustedMatchers;
            }
            function $SceDelegateProvider() {
                this.SCE_CONTEXTS = SCE_CONTEXTS;
                var trustedResourceUrlList = [ "self" ], bannedResourceUrlList = [];
                this.trustedResourceUrlList = function(value) {
                    return arguments.length && (trustedResourceUrlList = adjustMatchers(value)), trustedResourceUrlList;
                }, Object.defineProperty(this, "resourceUrlWhitelist", {
                    get: function() {
                        return this.trustedResourceUrlList;
                    },
                    set: function(value) {
                        this.trustedResourceUrlList = value;
                    }
                }), this.bannedResourceUrlList = function(value) {
                    return arguments.length && (bannedResourceUrlList = adjustMatchers(value)), bannedResourceUrlList;
                }, Object.defineProperty(this, "resourceUrlBlacklist", {
                    get: function() {
                        return this.bannedResourceUrlList;
                    },
                    set: function(value) {
                        this.bannedResourceUrlList = value;
                    }
                }), this.$get = [ "$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
                    function matchUrl(matcher, parsedUrl) {
                        return "self" === matcher ? urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl) : !!matcher.exec(parsedUrl.href);
                    }
                    function isResourceUrlAllowedByPolicy(url) {
                        var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                        for (i = 0, n = trustedResourceUrlList.length; i < n; i++) if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                            allowed = !0;
                            break;
                        }
                        if (allowed) for (i = 0, n = bannedResourceUrlList.length; i < n; i++) if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                            allowed = !1;
                            break;
                        }
                        return allowed;
                    }
                    function generateHolderType(Base) {
                        var holderType = function(trustedValue) {
                            this.$$unwrapTrustedValue = function() {
                                return trustedValue;
                            };
                        };
                        return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                            return this.$$unwrapTrustedValue();
                        }, holderType.prototype.toString = function() {
                            return this.$$unwrapTrustedValue().toString();
                        }, holderType;
                    }
                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                        if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        return new Constructor(trustedValue);
                    }
                    function valueOf(maybeTrusted) {
                        return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
                    }
                    function getTrusted(type, maybeTrusted) {
                        if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                        if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()),
                        type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                            throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                        }
                        if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    }
                    var htmlSanitizer = function(html) {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    };
                    $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                    var trustedValueHolderBase = generateHolderType(), byType = {};
                    return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase),
                    byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]),
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]),
                    {
                        trustAs: trustAs,
                        getTrusted: getTrusted,
                        valueOf: valueOf
                    };
                } ];
            }
            function $SceProvider() {
                var enabled = !0;
                this.enabled = function(value) {
                    return arguments.length && (enabled = !!value), enabled;
                }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
                    if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function() {
                        return enabled;
                    }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted,
                    sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                        return value;
                    }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                        var parsed = $parse(expr);
                        return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                            return sce.getTrusted(type, value);
                        });
                    };
                    var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                    return forEach(SCE_CONTEXTS, function(enumValue, name) {
                        var lName = lowercase(name);
                        sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                            return parse(enumValue, expr);
                        }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                            return getTrusted(enumValue, value);
                        }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                            return trustAs(enumValue, value);
                        };
                    }), sce;
                } ];
            }
            function $SnifferProvider() {
                this.$get = [ "$window", "$document", function($window, $document) {
                    var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
                    return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle),
                    animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                        history: !(!hasHistoryPushState || android < 4 || boxee),
                        hasEvent: function(event) {
                            if ("input" === event && msie) return !1;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement("div");
                                eventSupport[event] = "on" + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        transitions: transitions,
                        animations: animations,
                        android: android
                    };
                } ];
            }
            function $$TaskTrackerFactoryProvider() {
                this.$get = valueFn(function(log) {
                    return new TaskTracker(log);
                });
            }
            function TaskTracker(log) {
                function completeTask(fn, taskType) {
                    taskType = taskType || DEFAULT_TASK_TYPE;
                    try {
                        fn();
                    } finally {
                        decTaskCount(taskType);
                        var countForType = taskCounts[taskType], countForAll = taskCounts[ALL_TASKS_TYPE];
                        if (!countForAll || !countForType) for (var nextCb, getNextCallback = countForAll ? getLastCallbackForType : getLastCallback; nextCb = getNextCallback(taskType); ) try {
                            nextCb();
                        } catch (e) {
                            log.error(e);
                        }
                    }
                }
                function decTaskCount(taskType) {
                    taskType = taskType || DEFAULT_TASK_TYPE, taskCounts[taskType] && (taskCounts[taskType]--,
                    taskCounts[ALL_TASKS_TYPE]--);
                }
                function getLastCallback() {
                    var cbInfo = taskCallbacks.pop();
                    return cbInfo && cbInfo.cb;
                }
                function getLastCallbackForType(taskType) {
                    for (var i = taskCallbacks.length - 1; i >= 0; --i) {
                        var cbInfo = taskCallbacks[i];
                        if (cbInfo.type === taskType) return taskCallbacks.splice(i, 1), cbInfo.cb;
                    }
                }
                function incTaskCount(taskType) {
                    taskType = taskType || DEFAULT_TASK_TYPE, taskCounts[taskType] = (taskCounts[taskType] || 0) + 1,
                    taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1;
                }
                function notifyWhenNoPendingTasks(callback, taskType) {
                    taskType = taskType || ALL_TASKS_TYPE, taskCounts[taskType] ? taskCallbacks.push({
                        type: taskType,
                        cb: callback
                    }) : callback();
                }
                var self = this, taskCounts = {}, taskCallbacks = [], ALL_TASKS_TYPE = self.ALL_TASKS_TYPE = "$$all$$", DEFAULT_TASK_TYPE = self.DEFAULT_TASK_TYPE = "$$default$$";
                self.completeTask = completeTask, self.incTaskCount = incTaskCount, self.notifyWhenNoPendingTasks = notifyWhenNoPendingTasks;
            }
            function $TemplateRequestProvider() {
                var httpOptions;
                this.httpOptions = function(val) {
                    return val ? (httpOptions = val, this) : httpOptions;
                }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        function handleError(resp) {
                            return ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText),
                            $exceptionHandler(resp)), $q.reject(resp);
                        }
                        handleRequestFn.totalPendingRequests++, isString(tpl) && !isUndefined($templateCache.get(tpl)) || (tpl = $sce.getTrustedResourceUrl(tpl));
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                            return transformer !== defaultHttpResponseTransform;
                        }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null),
                        $http.get(tpl, extend({
                            cache: $templateCache,
                            transformResponse: transformResponse
                        }, httpOptions)).finally(function() {
                            handleRequestFn.totalPendingRequests--;
                        }).then(function(response) {
                            return $templateCache.put(tpl, response.data);
                        }, handleError);
                    }
                    return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
                } ];
            }
            function $$TestabilityProvider() {
                this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
                    var testability = {};
                    return testability.findBindings = function(element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                        return forEach(bindings, function(binding) {
                            var dataBinding = angular.element(binding).data("$binding");
                            dataBinding && forEach(dataBinding, function(bindingName) {
                                if (opt_exactMatch) {
                                    new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding);
                                } else -1 !== bindingName.indexOf(expression) && matches.push(binding);
                            });
                        }), matches;
                    }, testability.findModels = function(element, expression, opt_exactMatch) {
                        for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                            var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                            if (elements.length) return elements;
                        }
                    }, testability.getLocation = function() {
                        return $location.url();
                    }, testability.setLocation = function(url) {
                        url !== $location.url() && ($location.url(url), $rootScope.$digest());
                    }, testability.whenStable = function(callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback);
                    }, testability;
                } ];
            }
            function $TimeoutProvider() {
                this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    function timeout(fn, delay, invokeApply) {
                        isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                        var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                        return timeoutId = $browser.defer(function() {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e), $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            skipApply || $rootScope.$apply();
                        }, delay, "$timeout"), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred,
                        promise;
                    }
                    var deferreds = {};
                    return timeout.cancel = function(promise) {
                        if (!promise) return !1;
                        if (!promise.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                        if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return !1;
                        var id = promise.$$timeoutId, deferred = deferreds[id];
                        return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id],
                        $browser.defer.cancel(id);
                    }, timeout;
                } ];
            }
            function urlResolve(url) {
                if (!isString(url)) return url;
                var href = url;
                msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href),
                urlParsingNode.setAttribute("href", href);
                var hostname = urlParsingNode.hostname;
                return !ipv6InBrackets && hostname.indexOf(":") > -1 && (hostname = "[" + hostname + "]"),
                {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                    hostname: hostname,
                    port: urlParsingNode.port,
                    pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                };
            }
            function urlIsSameOrigin(requestUrl) {
                return urlsAreSameOrigin(requestUrl, originUrl);
            }
            function urlIsSameOriginAsBaseUrl(requestUrl) {
                return urlsAreSameOrigin(requestUrl, getBaseUrl());
            }
            function urlIsAllowedOriginFactory(trustedOriginUrls) {
                var parsedAllowedOriginUrls = [ originUrl ].concat(trustedOriginUrls.map(urlResolve));
                return function(requestUrl) {
                    var parsedUrl = urlResolve(requestUrl);
                    return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
                };
            }
            function urlsAreSameOrigin(url1, url2) {
                return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host;
            }
            function getBaseUrl() {
                return window.document.baseURI ? window.document.baseURI : (baseUrlParsingNode || (baseUrlParsingNode = window.document.createElement("a"),
                baseUrlParsingNode.href = ".", baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1)),
                baseUrlParsingNode.href);
            }
            function $WindowProvider() {
                this.$get = valueFn(window);
            }
            function $$CookieReader($document) {
                function safeGetCookie(rawDocument) {
                    try {
                        return rawDocument.cookie || "";
                    } catch (e) {
                        return "";
                    }
                }
                function safeDecodeURIComponent(str) {
                    try {
                        return decodeURIComponent(str);
                    } catch (e) {
                        return str;
                    }
                }
                var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
                return function() {
                    var cookieArray, cookie, i, index, name, currentCookieString = safeGetCookie(rawDocument);
                    if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString,
                    cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i],
                    (index = cookie.indexOf("=")) > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)),
                    isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                    return lastCookies;
                };
            }
            function $$CookieReaderProvider() {
                this.$get = $$CookieReader;
            }
            function $FilterProvider($provide) {
                function register(name, factory) {
                    if (isObject(name)) {
                        var filters = {};
                        return forEach(name, function(filter, key) {
                            filters[key] = register(key, filter);
                        }), filters;
                    }
                    return $provide.factory(name + suffix, factory);
                }
                var suffix = "Filter";
                this.register = register, this.$get = [ "$injector", function($injector) {
                    return function(name) {
                        return $injector.get(name + suffix);
                    };
                } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter),
                register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter),
                register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
            }
            function filterFilter() {
                return function(array, expression, comparator, anyPropertyKey) {
                    if (!isArrayLike(array)) {
                        if (null == array) return array;
                        throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                    }
                    anyPropertyKey = anyPropertyKey || "$";
                    var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
                    switch (expressionType) {
                      case "function":
                        predicateFn = expression;
                        break;

                      case "boolean":
                      case "null":
                      case "number":
                      case "string":
                        matchAgainstAnyProp = !0;

                      case "object":
                        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;

                      default:
                        return array;
                    }
                    return Array.prototype.filter.call(array, predicateFn);
                };
            }
            function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
                var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
                return !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
                    return !isUndefined(actual) && (null === actual || null === expected ? actual === expected : !(isObject(expected) || isObject(actual) && !hasCustomToString(actual)) && (actual = lowercase("" + actual),
                    expected = lowercase("" + expected), -1 !== actual.indexOf(expected)));
                }), function(item) {
                    return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                };
            }
            function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
                var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
                if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
                if (isArray(actual)) return actual.some(function(item) {
                    return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
                });
                switch (actualType) {
                  case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual) if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                        return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1);
                    }
                    if ("object" === expectedType) {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                                var matchAnyProperty = key === anyPropertyKey;
                                if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                            }
                        }
                        return !0;
                    }
                    return comparator(actual, expected);

                  case "function":
                    return !1;

                  default:
                    return comparator(actual, expected);
                }
            }
            function getTypeForFilter(val) {
                return null === val ? "null" : typeof val;
            }
            function currencyFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(amount, currencySymbol, fractionSize) {
                    isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac);
                    var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
                    return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
                };
            }
            function numberFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(number, fractionSize) {
                    return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
                };
            }
            function parse(numStr) {
                var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
                for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")),
                (i = numStr.search(/e/i)) > 0 ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i),
                numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length),
                i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
                if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
                    for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
                    for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i);
                }
                return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1),
                exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                    d: digits,
                    e: exponent,
                    i: numberOfIntegerDigits
                };
            }
            function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
                var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i;
                fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
                var roundAt = fractionSize + parsedNumber.i, digit = digits[roundAt];
                if (roundAt > 0) {
                    digits.splice(Math.max(parsedNumber.i, roundAt));
                    for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
                } else {
                    fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1),
                    digits[0] = 0;
                    for (var i = 1; i < roundAt; i++) digits[i] = 0;
                }
                if (digit >= 5) if (roundAt - 1 < 0) {
                    for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
                    digits.unshift(1), parsedNumber.i++;
                } else digits[roundAt - 1]++;
                for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                var carry = digits.reduceRight(function(carry, d, i, digits) {
                    return d += carry, digits[i] = d % 10, Math.floor(d / 10);
                }, 0);
                carry && (digits.unshift(carry), parsedNumber.i++);
            }
            function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
                if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
                var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
                if (isInfinity) formattedText = ""; else {
                    parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                    var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
                    for (isZero = digits.reduce(function(isZero, d) {
                        return isZero && !d;
                    }, !0); integerLen < 0; ) digits.unshift(0), integerLen++;
                    integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits,
                    digits = [ 0 ]);
                    var groups = [];
                    for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                    digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep),
                    decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
                }
                return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
            }
            function padNumber(num, digits, trim, negWrap) {
                var neg = "";
                for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num,
                neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
                return trim && (num = num.substr(num.length - digits)), neg + num;
            }
            function dateGetter(name, size, offset, trim, negWrap) {
                return offset = offset || 0, function(date) {
                    var value = date["get" + name]();
                    return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12),
                    padNumber(value, size, trim, negWrap);
                };
            }
            function dateStrGetter(name, shortForm, standAlone) {
                return function(date, formats) {
                    var value = date["get" + name]();
                    return formats[uppercase((standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "") + name)][value];
                };
            }
            function timeZoneGetter(date, formats, offset) {
                var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
                return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
            }
            function getFirstThursdayOfYear(year) {
                var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
                return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
            }
            function getThursdayThisWeek(datetime) {
                return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
            }
            function weekGetter(size) {
                return function(date) {
                    var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs;
                    return padNumber(1 + Math.round(diff / 6048e5), size);
                };
            }
            function ampmGetter(date, formats) {
                return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
            }
            function eraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
            }
            function longEraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
            }
            function dateFilter($locale) {
                function jsonStringToDate(string) {
                    var match;
                    if (match = string.match(R_ISO8601_STR)) {
                        var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                        match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])),
                        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                        var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                        return timeSetter.call(date, h, m, s, ms), date;
                    }
                    return string;
                }
                var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                return function(date, format, timezone) {
                    var fn, match, text = "", parts = [];
                    if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format,
                    isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)),
                    isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
                    for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1),
                    format = parts.pop()) : (parts.push(format), format = null);
                    var dateTimezoneOffset = date.getTimezoneOffset();
                    return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset),
                    date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                        fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
                    }), text;
                };
            }
            function jsonFilter() {
                return function(object, spacing) {
                    return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
                };
            }
            function limitToFilter() {
                return function(input, limit, begin) {
                    return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit),
                    isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin),
                    begin = begin < 0 ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input);
                };
            }
            function sliceFn(input, begin, end) {
                return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
            }
            function orderByFilter($parse) {
                function processPredicates(sortPredicates) {
                    return sortPredicates.map(function(predicate) {
                        var descending = 1, get = identity;
                        if (isFunction(predicate)) get = predicate; else if (isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1,
                        predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate),
                        get.constant))) {
                            var key = get();
                            get = function(value) {
                                return value[key];
                            };
                        }
                        return {
                            get: get,
                            descending: descending
                        };
                    });
                }
                function isPrimitive(value) {
                    switch (typeof value) {
                      case "number":
                      case "boolean":
                      case "string":
                        return !0;

                      default:
                        return !1;
                    }
                }
                function objectValue(value) {
                    return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : (hasCustomToString(value) && (value = value.toString(),
                    isPrimitive(value)), value);
                }
                function getPredicateValue(value, index) {
                    var type = typeof value;
                    return null === value ? type = "null" : "object" === type && (value = objectValue(value)),
                    {
                        value: value,
                        type: type,
                        index: index
                    };
                }
                function defaultCompare(v1, v2) {
                    var result = 0, type1 = v1.type, type2 = v2.type;
                    if (type1 === type2) {
                        var value1 = v1.value, value2 = v2.value;
                        "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index),
                        isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1);
                    } else result = "undefined" === type1 ? 1 : "undefined" === type2 ? -1 : "null" === type1 ? 1 : "null" === type2 ? -1 : type1 < type2 ? -1 : 1;
                    return result;
                }
                return function(array, sortPredicate, reverseOrder, compareFn) {
                    function getComparisonObject(value, index) {
                        return {
                            value: value,
                            tieBreaker: {
                                value: index,
                                type: "number",
                                index: index
                            },
                            predicateValues: predicates.map(function(predicate) {
                                return getPredicateValue(predicate.get(value), index);
                            })
                        };
                    }
                    function doComparison(v1, v2) {
                        for (var i = 0, ii = predicates.length; i < ii; i++) {
                            var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                            if (result) return result * predicates[i].descending * descending;
                        }
                        return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
                    }
                    if (null == array) return array;
                    if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                    isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
                    var predicates = processPredicates(sortPredicate), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, getComparisonObject);
                    return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                        return item.value;
                    });
                };
            }
            function ngDirective(directive) {
                return isFunction(directive) && (directive = {
                    link: directive
                }), directive.restrict = directive.restrict || "AC", valueFn(directive);
            }
            function nullFormRenameControl(control, name) {
                control.$name = name;
            }
            function FormController($element, $attrs, $scope, $animate, $interpolate) {
                this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0,
                this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1,
                this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1,
                this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate,
                setupValidity(this);
            }
            function setupValidity(instance) {
                instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
            }
            function addSetValidityMethod(context) {
                function createAndSet(ctrl, name, value, controller) {
                    ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
                }
                function unsetAndCleanup(ctrl, name, value, controller) {
                    ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
                }
                function cachedToggleClass(ctrl, className, switchValue) {
                    switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className),
                    ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className),
                    ctrl.$$classCache[className] = !1);
                }
                function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                    validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "",
                    cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, !0 === isValid), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, !1 === isValid);
                }
                var clazz = context.clazz, set = context.set, unset = context.unset;
                clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
                    isUndefined(state) ? createAndSet(this, "$pending", validationErrorKey, controller) : unsetAndCleanup(this, "$pending", validationErrorKey, controller),
                    isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller),
                    set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller),
                    unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller),
                    unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, PENDING_CLASS, !0),
                    this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, PENDING_CLASS, !1),
                    this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid));
                    var combinedState;
                    combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null),
                    toggleValidationCss(this, validationErrorKey, combinedState), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
                };
            }
            function isObjectEmpty(obj) {
                if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
                return !0;
            }
            function stringBasedInputType(ctrl) {
                ctrl.$formatters.push(function(value) {
                    return ctrl.$isEmpty(value) ? value : value.toString();
                });
            }
            function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
            }
            function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                var type = lowercase(element[0].type);
                if (!$sniffer.android) {
                    var composing = !1;
                    element.on("compositionstart", function() {
                        composing = !0;
                    }), element.on("compositionupdate", function(ev) {
                        (isUndefined(ev.data) || "" === ev.data) && (composing = !1);
                    }), element.on("compositionend", function() {
                        composing = !1, listener();
                    });
                }
                var timeout, listener = function(ev) {
                    if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                        var value = element.val(), event = ev && ev.type;
                        "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)),
                        (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
                    }
                };
                if ($sniffer.hasEvent("input")) element.on("input", listener); else {
                    var deferListener = function(ev, input, origValue) {
                        timeout || (timeout = $browser.defer(function() {
                            timeout = null, input && input.value === origValue || listener(ev);
                        }));
                    };
                    element.on("keydown", function(event) {
                        var key = event.keyCode;
                        91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value);
                    }), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener);
                }
                element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
                    if (!timeout) {
                        var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                        timeout = $browser.defer(function() {
                            timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev);
                        });
                    }
                }), ctrl.$render = function() {
                    var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                    element.val() !== value && element.val(value);
                };
            }
            function weekParser(isoWeek, existingDate) {
                if (isDate(isoWeek)) return isoWeek;
                if (isString(isoWeek)) {
                    WEEK_REGEXP.lastIndex = 0;
                    var parts = WEEK_REGEXP.exec(isoWeek);
                    if (parts) {
                        var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                        return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(),
                        seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()),
                        new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                    }
                }
                return NaN;
            }
            function createDateParser(regexp, mapping) {
                return function(iso, previousDate) {
                    var parts, map;
                    if (isDate(iso)) return iso;
                    if (isString(iso)) {
                        if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)),
                        ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                        if (regexp.lastIndex = 0, parts = regexp.exec(iso)) {
                            parts.shift(), map = previousDate ? {
                                yyyy: previousDate.getFullYear(),
                                MM: previousDate.getMonth() + 1,
                                dd: previousDate.getDate(),
                                HH: previousDate.getHours(),
                                mm: previousDate.getMinutes(),
                                ss: previousDate.getSeconds(),
                                sss: previousDate.getMilliseconds() / 1e3
                            } : {
                                yyyy: 1970,
                                MM: 1,
                                dd: 1,
                                HH: 0,
                                mm: 0,
                                ss: 0,
                                sss: 0
                            }, forEach(parts, function(part, index) {
                                index < mapping.length && (map[mapping[index]] = +part);
                            });
                            var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                            return map.yyyy < 100 && date.setFullYear(map.yyyy), date;
                        }
                    }
                    return NaN;
                };
            }
            function createDateInputType(type, regexp, parseDate, format) {
                return function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                    function isValidDate(value) {
                        return value && !(value.getTime && value.getTime() !== value.getTime());
                    }
                    function parseObservedDateValue(val) {
                        return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val;
                    }
                    function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                        var timezone = ctrl.$options.getOption("timezone");
                        previousTimezone && previousTimezone !== timezone && (previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone)));
                        var parsedDate = parseDate(value, previousDate);
                        return !isNaN(parsedDate) && timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)),
                        parsedDate;
                    }
                    function formatter(value, timezone) {
                        var targetFormat = format;
                        isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat")) && (targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, ""));
                        var formatted = $filter("date")(value, targetFormat, timezone);
                        return isTimeType && ctrl.$options.getOption("timeStripZeroSeconds") && (formatted = formatted.replace(/(?::00)?(?:\.000)?$/, "")),
                        formatted;
                    }
                    badInputChecker(scope, element, attr, ctrl, type), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                    var previousDate, previousTimezone, isTimeType = "time" === type || "datetimelocal" === type;
                    if (ctrl.$parsers.push(function(value) {
                        return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void (ctrl.$$parserName = type);
                    }), ctrl.$formatters.push(function(value) {
                        if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        if (isValidDate(value)) {
                            previousDate = value;
                            var timezone = ctrl.$options.getOption("timezone");
                            return timezone && (previousTimezone = timezone, previousDate = convertTimezoneToLocal(previousDate, timezone, !0)),
                            formatter(value, timezone);
                        }
                        return previousDate = null, previousTimezone = null, "";
                    }), isDefined(attr.min) || attr.ngMin) {
                        var minVal = attr.min || $parse(attr.ngMin)(scope), parsedMinVal = parseObservedDateValue(minVal);
                        ctrl.$validators.min = function(value) {
                            return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal;
                        }, attr.$observe("min", function(val) {
                            val !== minVal && (parsedMinVal = parseObservedDateValue(val), minVal = val, ctrl.$validate());
                        });
                    }
                    if (isDefined(attr.max) || attr.ngMax) {
                        var maxVal = attr.max || $parse(attr.ngMax)(scope), parsedMaxVal = parseObservedDateValue(maxVal);
                        ctrl.$validators.max = function(value) {
                            return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal;
                        }, attr.$observe("max", function(val) {
                            val !== maxVal && (parsedMaxVal = parseObservedDateValue(val), maxVal = val, ctrl.$validate());
                        });
                    }
                };
            }
            function badInputChecker(scope, element, attr, ctrl, parserName) {
                var node = element[0];
                (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push(function(value) {
                    var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                    return validity.badInput || validity.typeMismatch ? void (ctrl.$$parserName = parserName) : value;
                });
            }
            function numberFormatterParser(ctrl) {
                ctrl.$parsers.push(function(value) {
                    return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void (ctrl.$$parserName = "number");
                }), ctrl.$formatters.push(function(value) {
                    if (!ctrl.$isEmpty(value)) {
                        if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                        value = value.toString();
                    }
                    return value;
                });
            }
            function parseNumberAttrVal(val) {
                return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
            }
            function isNumberInteger(num) {
                return (0 | num) === num;
            }
            function countDecimals(num) {
                var numString = num.toString(), decimalSymbolIndex = numString.indexOf(".");
                if (-1 === decimalSymbolIndex) {
                    if (-1 < num && num < 1) {
                        var match = /e-(\d+)$/.exec(numString);
                        if (match) return Number(match[1]);
                    }
                    return 0;
                }
                return numString.length - decimalSymbolIndex - 1;
            }
            function isValidForStep(viewValue, stepBase, step) {
                var value = Number(viewValue), isNonIntegerValue = !isNumberInteger(value), isNonIntegerStepBase = !isNumberInteger(stepBase), isNonIntegerStep = !isNumberInteger(step);
                if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                    var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0, stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0, stepDecimals = isNonIntegerStep ? countDecimals(step) : 0, decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals), multiplier = Math.pow(10, decimalCount);
                    value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)),
                    isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step));
                }
                return (value - stepBase) % step == 0;
            }
            function numberInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                badInputChecker(scope, element, attr, ctrl, "number"), numberFormatterParser(ctrl),
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var parsedMinVal;
                if (isDefined(attr.min) || attr.ngMin) {
                    var minVal = attr.min || $parse(attr.ngMin)(scope);
                    parsedMinVal = parseNumberAttrVal(minVal), ctrl.$validators.min = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal;
                    }, attr.$observe("min", function(val) {
                        val !== minVal && (parsedMinVal = parseNumberAttrVal(val), minVal = val, ctrl.$validate());
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal = attr.max || $parse(attr.ngMax)(scope), parsedMaxVal = parseNumberAttrVal(maxVal);
                    ctrl.$validators.max = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal;
                    }, attr.$observe("max", function(val) {
                        val !== maxVal && (parsedMaxVal = parseNumberAttrVal(val), maxVal = val, ctrl.$validate());
                    });
                }
                if (isDefined(attr.step) || attr.ngStep) {
                    var stepVal = attr.step || $parse(attr.ngStep)(scope), parsedStepVal = parseNumberAttrVal(stepVal);
                    ctrl.$validators.step = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
                    }, attr.$observe("step", function(val) {
                        val !== stepVal && (parsedStepVal = parseNumberAttrVal(val), stepVal = val, ctrl.$validate());
                    });
                }
            }
            function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                function setInitialValueAndObserver(htmlAttrName, changeFn) {
                    element.attr(htmlAttrName, attr[htmlAttrName]);
                    var oldVal = attr[htmlAttrName];
                    attr.$observe(htmlAttrName, function(val) {
                        val !== oldVal && (oldVal = val, changeFn(val));
                    });
                }
                function minChange(val) {
                    if (minVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                        var elVal = element.val();
                        minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal);
                    } else ctrl.$validate();
                }
                function maxChange(val) {
                    if (maxVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                        var elVal = element.val();
                        maxVal < elVal && (element.val(maxVal), elVal = maxVal < minVal ? minVal : maxVal),
                        ctrl.$setViewValue(elVal);
                    } else ctrl.$validate();
                }
                function stepChange(val) {
                    stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue) || (supportsRange ? ctrl.$viewValue !== element.val() && ctrl.$setViewValue(element.val()) : ctrl.$validate());
                }
                badInputChecker(scope, element, attr, ctrl, "range"), numberFormatterParser(ctrl),
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step), originalRender = ctrl.$render;
                ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
                    originalRender(), ctrl.$setViewValue(element.val());
                } : originalRender, hasMinAttr && (minVal = parseNumberAttrVal(attr.min), ctrl.$validators.min = supportsRange ? function() {
                    return !0;
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
                }, setInitialValueAndObserver("min", minChange)), hasMaxAttr && (maxVal = parseNumberAttrVal(attr.max),
                ctrl.$validators.max = supportsRange ? function() {
                    return !0;
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
                }, setInitialValueAndObserver("max", maxChange)), hasStepAttr && (stepVal = parseNumberAttrVal(attr.step),
                ctrl.$validators.step = supportsRange ? function() {
                    return !validity.stepMismatch;
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                }, setInitialValueAndObserver("step", stepChange));
            }
            function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl),
                ctrl.$validators.url = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
                };
            }
            function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl),
                ctrl.$validators.email = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
                };
            }
            function radioInputType(scope, element, attr, ctrl) {
                var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
                isUndefined(attr.name) && element.attr("name", nextUid());
                var listener = function(ev) {
                    var value;
                    element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
                };
                element.on("change", listener), ctrl.$render = function() {
                    var value = attr.value;
                    doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
                }, attr.$observe("value", ctrl.$render);
            }
            function parseConstantExpr($parse, context, name, expression, fallback) {
                var parseFn;
                if (isDefined(expression)) {
                    if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
                    return parseFn(context);
                }
                return fallback;
            }
            function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
                    ctrl.$setViewValue(element[0].checked, ev && ev.type);
                };
                element.on("change", listener), ctrl.$render = function() {
                    element[0].checked = ctrl.$viewValue;
                }, ctrl.$isEmpty = function(value) {
                    return !1 === value;
                }, ctrl.$formatters.push(function(value) {
                    return equals(value, trueValue);
                }), ctrl.$parsers.push(function(value) {
                    return value ? trueValue : falseValue;
                });
            }
            function classDirective(name, selector) {
                function arrayDifference(tokens1, tokens2) {
                    if (!tokens1 || !tokens1.length) return [];
                    if (!tokens2 || !tokens2.length) return tokens1;
                    var values = [];
                    outer: for (var i = 0; i < tokens1.length; i++) {
                        for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                        values.push(token);
                    }
                    return values;
                }
                function split(classString) {
                    return classString && classString.split(" ");
                }
                function toClassString(classValue) {
                    if (!classValue) return classValue;
                    var classString = classValue;
                    return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) ? classString = Object.keys(classValue).filter(function(key) {
                        return classValue[key];
                    }).join(" ") : isString(classValue) || (classString = classValue + ""), classString;
                }
                name = "ngClass" + name;
                var indexWatchExpression;
                return [ "$parse", function($parse) {
                    return {
                        restrict: "AC",
                        link: function(scope, element, attr) {
                            function addClasses(classString) {
                                classString = digestClassCounts(split(classString), 1), attr.$addClass(classString);
                            }
                            function removeClasses(classString) {
                                classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                            }
                            function updateClasses(oldClassString, newClassString) {
                                var oldClassArray = split(oldClassString), newClassArray = split(newClassString), toRemoveArray = arrayDifference(oldClassArray, newClassArray), toAddArray = arrayDifference(newClassArray, oldClassArray), toRemoveString = digestClassCounts(toRemoveArray, -1), toAddString = digestClassCounts(toAddArray, 1);
                                attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                            }
                            function digestClassCounts(classArray, count) {
                                var classesToUpdate = [];
                                return forEach(classArray, function(className) {
                                    (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count,
                                    classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                                }), classesToUpdate.join(" ");
                            }
                            function ngClassIndexWatchAction(newModulo) {
                                newModulo === selector ? addClasses(oldClassString) : removeClasses(oldClassString),
                                oldModulo = newModulo;
                            }
                            function ngClassWatchAction(newClassString) {
                                oldModulo === selector && updateClasses(oldClassString, newClassString), oldClassString = newClassString;
                            }
                            var oldClassString, classCounts = element.data("$classCounts"), oldModulo = !0;
                            classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)),
                            "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", function($index) {
                                return 1 & $index;
                            })), scope.$watch(indexWatchExpression, ngClassIndexWatchAction)), scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                        }
                    };
                } ];
            }
            function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
                return {
                    restrict: "A",
                    compile: function($element, attr) {
                        var fn = $parse(attr[directiveName]);
                        return function(scope, element) {
                            element.on(eventName, function(event) {
                                var callback = function() {
                                    fn(scope, {
                                        $event: event
                                    });
                                };
                                if ($rootScope.$$phase) if (forceAsync) scope.$evalAsync(callback); else try {
                                    callback();
                                } catch (error) {
                                    $exceptionHandler(error);
                                } else scope.$apply(callback);
                            });
                        };
                    }
                };
            }
            function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
                this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0,
                this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [],
                this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0,
                this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {},
                this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope),
                this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "",
                this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel),
                this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel,
                this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0,
                this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope,
                this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element,
                this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q,
                this.$$exceptionHandler = $exceptionHandler, setupValidity(this), setupModelWatcher(this);
            }
            function setupModelWatcher(ctrl) {
                ctrl.$$scope.$watch(function(scope) {
                    var modelValue = ctrl.$$ngModelGet(scope);
                    return modelValue === ctrl.$modelValue || ctrl.$modelValue !== ctrl.$modelValue && modelValue !== modelValue || ctrl.$$setModelValue(modelValue),
                    modelValue;
                });
            }
            function ModelOptions(options) {
                this.$$options = options;
            }
            function defaults(dst, src) {
                forEach(src, function(value, key) {
                    isDefined(dst[key]) || (dst[key] = value);
                });
            }
            function setOptionSelectedStatus(optionEl, value) {
                optionEl.prop("selected", value), optionEl.attr("selected", value);
            }
            function parsePatternAttr(regex, patternExp, elm) {
                if (regex) {
                    if (isString(regex) && (regex = new RegExp("^" + regex + "$")), !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    return regex;
                }
            }
            function parseLength(val) {
                var intVal = toInt(val);
                return isNumberNaN(intVal) ? -1 : intVal;
            }
            var msie, jqLite, jQuery, angularModule, minErrConfig = {
                objectMaxDepth: 5,
                urlErrorParamsEnabled: !0
            }, REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function(string) {
                return isString(string) ? string.toLowerCase() : string;
            }, uppercase = function(string) {
                return isString(string) ? string.toUpperCase() : string;
            }, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
            msie = window.document.documentMode;
            var isNumberNaN = Number.isNaN || function(num) {
                return num !== num;
            };
            noop.$inject = [], identity.$inject = [];
            var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, trim = function(value) {
                return isString(value) ? value.trim() : value;
            }, escapeForRegexp = function(s) {
                return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
            }, csp = function() {
                if (!isDefined(csp.rules)) {
                    var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                            noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                        };
                    } else csp.rules = {
                        noUnsafeEval: function() {
                            try {
                                return new Function(""), !1;
                            } catch (e) {
                                return !0;
                            }
                        }(),
                        noInlineStyle: !1
                    };
                }
                return csp.rules;
            }, jq = function() {
                if (isDefined(jq.name_)) return jq.name_;
                var el, i, prefix, name, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i) if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
                    name = el.getAttribute(prefix + "jq");
                    break;
                }
                return jq.name_ = name;
            }, ALL_COLONS = /:/g, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], isAutoBootstrapAllowed = function(document) {
                var script = document.currentScript;
                if (!script) return !0;
                if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
                var attributes = script.attributes;
                return [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ].every(function(src) {
                    if (!src) return !0;
                    if (!src.value) return !1;
                    var link = document.createElement("a");
                    if (link.href = src.value, document.location.origin === link.origin) return !0;
                    switch (link.protocol) {
                      case "http:":
                      case "https:":
                      case "ftp:":
                      case "blob:":
                      case "file:":
                      case "data:":
                        return !0;

                      default:
                        return !1;
                    }
                });
            }(window.document), SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
                full: "1.8.2",
                major: 1,
                minor: 8,
                dot: 2,
                codeName: "meteoric-mining"
            };
            JQLite.expando = "ng339";
            var jqCache = JQLite.cache = {}, jqId = 1;
            JQLite._data = function(node) {
                return this.cache[node[this.expando]] || {};
            };
            var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
                mouseleave: "mouseout",
                mouseenter: "mouseover"
            }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
                thead: [ "table" ],
                col: [ "colgroup", "table" ],
                tr: [ "tbody", "table" ],
                td: [ "tr", "tbody", "table" ]
            };
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
            wrapMap.th = wrapMap.td;
            var wrapMapIE9 = {
                option: [ 1, '<select multiple="multiple">', "</select>" ],
                _default: [ 0, "", "" ]
            };
            for (var key in wrapMap) {
                var wrapMapValueClosing = wrapMap[key], wrapMapValue = wrapMapValueClosing.slice().reverse();
                wrapMapIE9[key] = [ wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">" ];
            }
            wrapMapIE9.optgroup = wrapMapIE9.option;
            var jqLiteContains = window.Node.prototype.contains || function(arg) {
                return !!(16 & this.compareDocumentPosition(arg));
            }, JQLitePrototype = JQLite.prototype = {
                ready: jqLiteReady,
                toString: function() {
                    var value = [];
                    return forEach(this, function(e) {
                        value.push("" + e);
                    }), "[" + value.join(", ") + "]";
                },
                eq: function(index) {
                    return jqLite(index >= 0 ? this[index] : this[this.length + index]);
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            }, BOOLEAN_ATTR = {};
            forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
                BOOLEAN_ATTR[lowercase(value)] = value;
            });
            var BOOLEAN_ELEMENTS = {};
            forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
                BOOLEAN_ELEMENTS[value] = !0;
            });
            var ALIASED_ATTR = {
                ngMinlength: "minlength",
                ngMaxlength: "maxlength",
                ngMin: "min",
                ngMax: "max",
                ngPattern: "pattern",
                ngStep: "step"
            };
            forEach({
                data: jqLiteData,
                removeData: jqLiteRemoveData,
                hasData: jqLiteHasData,
                cleanData: function(nodes) {
                    for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i]);
                }
            }, function(fn, name) {
                JQLite[name] = fn;
            }), forEach({
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function(element) {
                    return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
                },
                isolateScope: function(element) {
                    return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
                },
                controller: jqLiteController,
                injector: function(element) {
                    return jqLiteInheritedData(element, "$injector");
                },
                removeAttr: function(element, name) {
                    element.removeAttribute(name);
                },
                hasClass: jqLiteHasClass,
                css: function(element, name, value) {
                    if (name = cssKebabToCamel(name), !isDefined(value)) return element.style[name];
                    element.style[name] = value;
                },
                attr: function(element, name, value) {
                    var ret, nodeType = element.nodeType;
                    if (nodeType !== NODE_TYPE_TEXT && 2 !== nodeType && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                        var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                        if (!isDefined(value)) return ret = element.getAttribute(name), isBooleanAttr && null !== ret && (ret = lowercasedName),
                        null === ret ? void 0 : ret;
                        null === value || !1 === value && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
                    }
                },
                prop: function(element, name, value) {
                    if (!isDefined(value)) return element[name];
                    element[name] = value;
                },
                text: function() {
                    function getText(element, value) {
                        if (isUndefined(value)) {
                            var nodeType = element.nodeType;
                            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                        }
                        element.textContent = value;
                    }
                    return getText.$dv = "", getText;
                }(),
                val: function(element, value) {
                    if (isUndefined(value)) {
                        if (element.multiple && "select" === nodeName_(element)) {
                            var result = [];
                            return forEach(element.options, function(option) {
                                option.selected && result.push(option.value || option.text);
                            }), result;
                        }
                        return element.value;
                    }
                    element.value = value;
                },
                html: function(element, value) {
                    if (isUndefined(value)) return element.innerHTML;
                    jqLiteDealoc(element, !0), element.innerHTML = value;
                },
                empty: jqLiteEmpty
            }, function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2) {
                    var i, key, nodeCount = this.length;
                    if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                        if (isObject(arg1)) {
                            for (i = 0; i < nodeCount; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                            return this;
                        }
                        for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                            var nodeValue = fn(this[j], arg1, arg2);
                            value = value ? value + nodeValue : nodeValue;
                        }
                        return value;
                    }
                    for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
                    return this;
                };
            }), forEach({
                removeData: jqLiteRemoveData,
                on: function(element, type, fn, unsupported) {
                    if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                    if (jqLiteAcceptsData(element)) {
                        var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                        handle || (handle = expandoStore.handle = createEventHandler(element, events));
                        for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                            var eventFns = events[type];
                            eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper,
                            "$destroy" === type || noEventListener || element.addEventListener(type, handle)),
                            eventFns.push(fn);
                        }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper),
                        addHandler(type, void 0, !0)) : addHandler(type);
                    }
                },
                off: jqLiteOff,
                one: function(element, type, fn) {
                    element = jqLite(element), element.on(type, function onFn() {
                        element.off(type, fn), element.off(type, onFn);
                    }), element.on(type, fn);
                },
                replaceWith: function(element, replaceNode) {
                    var index, parent = element.parentNode;
                    jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                        index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element),
                        index = node;
                    });
                },
                children: function(element) {
                    var children = [];
                    return forEach(element.childNodes, function(element) {
                        element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
                    }), children;
                },
                contents: function(element) {
                    return element.contentDocument || element.childNodes || [];
                },
                append: function(element, node) {
                    var nodeType = element.nodeType;
                    if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                        node = new JQLite(node);
                        for (var i = 0, ii = node.length; i < ii; i++) {
                            var child = node[i];
                            element.appendChild(child);
                        }
                    }
                },
                prepend: function(element, node) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        var index = element.firstChild;
                        forEach(new JQLite(node), function(child) {
                            element.insertBefore(child, index);
                        });
                    }
                },
                wrap: function(element, wrapNode) {
                    jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
                },
                remove: jqLiteRemove,
                detach: function(element) {
                    jqLiteRemove(element, !0);
                },
                after: function(element, newElement) {
                    var index = element, parent = element.parentNode;
                    if (parent) {
                        newElement = new JQLite(newElement);
                        for (var i = 0, ii = newElement.length; i < ii; i++) {
                            var node = newElement[i];
                            parent.insertBefore(node, index.nextSibling), index = node;
                        }
                    }
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function(element, selector, condition) {
                    selector && forEach(selector.split(" "), function(className) {
                        var classCondition = condition;
                        isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)),
                        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                    });
                },
                parent: function(element) {
                    var parent = element.parentNode;
                    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
                },
                next: function(element) {
                    return element.nextElementSibling;
                },
                find: function(element, selector) {
                    return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
                },
                clone: jqLiteClone,
                triggerHandler: function(element, event, extraParameters) {
                    var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
                    eventFns && (dummyEvent = {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                        },
                        isDefaultPrevented: function() {
                            return !0 === this.defaultPrevented;
                        },
                        stopImmediatePropagation: function() {
                            this.immediatePropagationStopped = !0;
                        },
                        isImmediatePropagationStopped: function() {
                            return !0 === this.immediatePropagationStopped;
                        },
                        stopPropagation: noop,
                        type: eventName,
                        target: element
                    }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns),
                    handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ],
                    forEach(eventFnsCopy, function(fn) {
                        dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
                    }));
                }
            }, function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2, arg3) {
                    for (var value, i = 0, ii = this.length; i < ii; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3),
                    isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                    return isDefined(value) ? value : this;
                };
            }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
            var nanKey = Object.create(null);
            NgMapShim.prototype = {
                _idx: function(key) {
                    return key !== this._lastKey && (this._lastKey = key, this._lastIndex = this._keys.indexOf(key)),
                    this._lastIndex;
                },
                _transformKey: function(key) {
                    return isNumberNaN(key) ? nanKey : key;
                },
                get: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    if (-1 !== idx) return this._values[idx];
                },
                has: function(key) {
                    return key = this._transformKey(key), -1 !== this._idx(key);
                },
                set: function(key, value) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    -1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key,
                    this._values[idx] = value;
                },
                delete: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    return -1 !== idx && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN,
                    this._lastIndex = -1, !0);
                }
            };
            var NgMap = NgMapShim, $$MapProvider = [ function() {
                this.$get = [ function() {
                    return NgMap;
                } ];
            } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
            createInjector.$$annotate = annotate;
            var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, $$CoreAnimateJsProvider = function() {
                this.$get = noop;
            }, $$CoreAnimateQueueProvider = function() {
                var postDigestQueue = new NgMap(), postDigestElements = [];
                this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
                    function updateData(data, classes, value) {
                        var changed = !1;
                        return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [],
                        forEach(classes, function(className) {
                            className && (changed = !0, data[className] = value);
                        })), changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function(element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                                forEach(data, function(status, className) {
                                    status !== !!existing[className] && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                                }), forEach(element, function(elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                                }), postDigestQueue.delete(element);
                            }
                        }), postDigestElements.length = 0;
                    }
                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                        (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element),
                        1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
                    }
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function(element, event, options, domOperation) {
                            domOperation && domOperation(), options = options || {}, options.from && element.css(options.from),
                            options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            var runner = new $$AnimateRunner();
                            return runner.complete(), runner;
                        }
                    };
                } ];
            }, $AnimateProvider = [ "$provide", function($provide) {
                var provider = this, classNameFilter = null, customFilter = null;
                this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
                    if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
                }, this.customFilter = function(filterFn) {
                    return 1 === arguments.length && (customFilter = isFunction(filterFn) ? filterFn : null),
                    customFilter;
                }, this.classNameFilter = function(expression) {
                    if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null)) {
                        if (new RegExp("[(\\s|\\/)]ng-animate[(\\s|\\/)]").test(classNameFilter.toString())) throw classNameFilter = null,
                        $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', "ng-animate");
                    }
                    return classNameFilter;
                }, this.$get = [ "$$animateQueue", function($$animateQueue) {
                    function domInsert(element, parentElement, afterElement) {
                        if (afterElement) {
                            var afterNode = extractElementNode(afterElement);
                            !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                        }
                        afterElement ? afterElement.after(element) : parentElement.prepend(element);
                    }
                    return {
                        on: $$animateQueue.on,
                        off: $$animateQueue.off,
                        pin: $$animateQueue.pin,
                        enabled: $$animateQueue.enabled,
                        cancel: function(runner) {
                            runner.cancel && runner.cancel();
                        },
                        enter: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(),
                            domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                        },
                        move: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(),
                            domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                        },
                        leave: function(element, options) {
                            return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                                element.remove();
                            });
                        },
                        addClass: function(element, className, options) {
                            return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className),
                            $$animateQueue.push(element, "addClass", options);
                        },
                        removeClass: function(element, className, options) {
                            return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className),
                            $$animateQueue.push(element, "removeClass", options);
                        },
                        setClass: function(element, add, remove, options) {
                            return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add),
                            options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                        },
                        animate: function(element, from, to, className, options) {
                            return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from,
                            options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate",
                            options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                        }
                    };
                } ];
            } ], $$AnimateAsyncRunFactoryProvider = function() {
                this.$get = [ "$$rAF", function($$rAF) {
                    function waitForTick(fn) {
                        waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                            for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                            waitQueue = [];
                        });
                    }
                    var waitQueue = [];
                    return function() {
                        var passed = !1;
                        return waitForTick(function() {
                            passed = !0;
                        }), function(callback) {
                            passed ? callback() : waitForTick(callback);
                        };
                    };
                } ];
            }, $$AnimateRunnerFactoryProvider = function() {
                this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun(), timeoutTick = function(fn) {
                            $timeout(fn, 0, !1);
                        };
                        this._doneCallbacks = [], this._tick = function(fn) {
                            $$isDocumentHidden() ? timeoutTick(fn) : rafTick(fn);
                        }, this._state = 0;
                    }
                    return AnimateRunner.chain = function(chain, callback) {
                        function next() {
                            if (index === chain.length) return void callback(!0);
                            chain[index](function(response) {
                                if (!1 === response) return void callback(!1);
                                index++, next();
                            });
                        }
                        var index = 0;
                        next();
                    }, AnimateRunner.all = function(runners, callback) {
                        function onProgress(response) {
                            status = status && response, ++count === runners.length && callback(status);
                        }
                        var count = 0, status = !0;
                        forEach(runners, function(runner) {
                            runner.done(onProgress);
                        });
                    }, AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {};
                        },
                        done: function(fn) {
                            2 === this._state ? fn() : this._doneCallbacks.push(fn);
                        },
                        progress: noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q(function(resolve, reject) {
                                    self.done(function(status) {
                                        !1 === status ? reject() : resolve();
                                    });
                                });
                            }
                            return this.promise;
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        catch: function(handler) {
                            return this.getPromise().catch(handler);
                        },
                        finally: function(handler) {
                            return this.getPromise().finally(handler);
                        },
                        pause: function() {
                            this.host.pause && this.host.pause();
                        },
                        resume: function() {
                            this.host.resume && this.host.resume();
                        },
                        end: function() {
                            this.host.end && this.host.end(), this._resolve(!0);
                        },
                        cancel: function() {
                            this.host.cancel && this.host.cancel(), this._resolve(!1);
                        },
                        complete: function(response) {
                            var self = this;
                            0 === self._state && (self._state = 1, self._tick(function() {
                                self._resolve(response);
                            }));
                        },
                        _resolve: function(response) {
                            2 !== this._state && (forEach(this._doneCallbacks, function(fn) {
                                fn(response);
                            }), this._doneCallbacks.length = 0, this._state = 2);
                        }
                    }, AnimateRunner;
                } ];
            }, $CoreAnimateCssProvider = function() {
                this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
                    return function(element, initialOptions) {
                        function run() {
                            return $$rAF(function() {
                                applyAnimationContents(), closed || runner.complete(), closed = !0;
                            }), runner;
                        }
                        function applyAnimationContents() {
                            options.addClass && (element.addClass(options.addClass), options.addClass = null),
                            options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null),
                            options.to && (element.css(options.to), options.to = null);
                        }
                        var options = initialOptions || {};
                        options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null),
                        options.from && (element.css(options.from), options.from = null);
                        var closed, runner = new $$AnimateRunner();
                        return {
                            start: run,
                            end: run
                        };
                    };
                } ];
            }, $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
            $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
                return this.previousValue === _UNINITIALIZED_VALUE;
            };
            var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/, $$ForceReflowProvider = function() {
                this.$get = [ "$document", function($document) {
                    return function(domNode) {
                        return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body,
                        domNode.offsetWidth + 1;
                    };
                } ];
            }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": APPLICATION_JSON + ";charset=utf-8"
            }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
                "[": /]$/,
                "{": /}$/
            }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http"), $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
            $interpolateMinErr.throwNoconcat = function(text) {
                throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
            }, $interpolateMinErr.interr = function(text, err) {
                return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
            };
            var $intervalMinErr = minErr("$interval"), $jsonpCallbacksProvider = function() {
                this.$get = function() {
                    function createCallback(callbackId) {
                        var callback = function(data) {
                            callback.data = data, callback.called = !0;
                        };
                        return callback.id = callbackId, callback;
                    }
                    var callbacks = angular.callbacks, callbackMap = {};
                    return {
                        createCallback: function(url) {
                            var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = createCallback(callbackId);
                            return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                        },
                        wasCalled: function(callbackPath) {
                            return callbackMap[callbackPath].called;
                        },
                        getResponse: function(callbackPath) {
                            return callbackMap[callbackPath].data;
                        },
                        removeCallback: function(callbackPath) {
                            var callback = callbackMap[callbackPath];
                            delete callbacks[callback.id], delete callbackMap[callbackPath];
                        }
                    };
                };
            }, PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            }, $locationMinErr = minErr("$location"), DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/, locationPrototype = {
                $$absUrl: "",
                $$html5: !1,
                $$replace: !1,
                $$compose: function() {
                    this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash), this.$$absUrl = this.$$normalizeUrl(this.$$url),
                    this.$$urlUpdatedByLocation = !0;
                },
                absUrl: locationGetter("$$absUrl"),
                url: function(url) {
                    if (isUndefined(url)) return this.$$url;
                    var match = PATH_MATCH.exec(url);
                    return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""),
                    this.hash(match[5] || ""), this;
                },
                protocol: locationGetter("$$protocol"),
                host: locationGetter("$$host"),
                port: locationGetter("$$port"),
                path: locationGetterSetter("$$path", function(path) {
                    return path = null !== path ? path.toString() : "", "/" === path.charAt(0) ? path : "/" + path;
                }),
                search: function(search, paramValue) {
                    switch (arguments.length) {
                      case 0:
                        return this.$$search;

                      case 1:
                        if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                            if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                            search = copy(search, {}), forEach(search, function(value, key) {
                                null == value && delete search[key];
                            }), this.$$search = search;
                        }
                        break;

                      default:
                        isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
                    }
                    return this.$$compose(), this;
                },
                hash: locationGetterSetter("$$hash", function(hash) {
                    return null !== hash ? hash.toString() : "";
                }),
                replace: function() {
                    return this.$$replace = !0, this;
                }
            };
            forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
                Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
                    if (!arguments.length) return this.$$state;
                    if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
                    return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0,
                    this;
                };
            });
            var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf, OPERATORS = createMap();
            forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
                OPERATORS[operator] = !0;
            });
            var ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "\t",
                v: "\v",
                "'": "'",
                '"': '"'
            }, Lexer = function(options) {
                this.options = options;
            };
            Lexer.prototype = {
                constructor: Lexer,
                lex: function(text) {
                    for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                        var ch = this.text.charAt(this.index);
                        if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                            index: this.index,
                            text: ch
                        }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                            var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                            if (op1 || op2 || op3) {
                                var token = op3 ? ch3 : op2 ? ch2 : ch;
                                this.tokens.push({
                                    index: this.index,
                                    text: token,
                                    operator: !0
                                }), this.index += token.length;
                            } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                        }
                    }
                    return this.tokens;
                },
                is: function(ch, chars) {
                    return -1 !== chars.indexOf(ch);
                },
                peek: function(i) {
                    var num = i || 1;
                    return this.index + num < this.text.length && this.text.charAt(this.index + num);
                },
                isNumber: function(ch) {
                    return "0" <= ch && ch <= "9" && "string" == typeof ch;
                },
                isWhitespace: function(ch) {
                    return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || "" === ch;
                },
                isIdentifierStart: function(ch) {
                    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
                },
                isValidIdentifierStart: function(ch) {
                    return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch;
                },
                isIdentifierContinue: function(ch) {
                    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
                },
                isValidIdentifierContinue: function(ch, cp) {
                    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
                },
                codePointAt: function(ch) {
                    return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
                },
                peekMultichar: function() {
                    var ch = this.text.charAt(this.index), peek = this.peek();
                    if (!peek) return ch;
                    var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
                    return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343 ? ch + peek : ch;
                },
                isExpOperator: function(ch) {
                    return "-" === ch || "+" === ch || this.isNumber(ch);
                },
                throwError: function(error, start, end) {
                    end = end || this.index;
                    var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                    throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
                },
                readNumber: function() {
                    for (var number = "", start = this.index; this.index < this.text.length; ) {
                        var ch = lowercase(this.text.charAt(this.index));
                        if ("." === ch || this.isNumber(ch)) number += ch; else {
                            var peekCh = this.peek();
                            if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                                if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                                this.throwError("Invalid exponent");
                            }
                        }
                        this.index++;
                    }
                    this.tokens.push({
                        index: start,
                        text: number,
                        constant: !0,
                        value: Number(number)
                    });
                },
                readIdent: function() {
                    var start = this.index;
                    for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                        var ch = this.peekMultichar();
                        if (!this.isIdentifierContinue(ch)) break;
                        this.index += ch.length;
                    }
                    this.tokens.push({
                        index: start,
                        text: this.text.slice(start, this.index),
                        identifier: !0
                    });
                },
                readString: function(quote) {
                    var start = this.index;
                    this.index++;
                    for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                        var ch = this.text.charAt(this.index);
                        if (rawString += ch, escape) {
                            if ("u" === ch) {
                                var hex = this.text.substring(this.index + 1, this.index + 5);
                                hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"),
                                this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                            } else {
                                string += ESCAPE[ch] || ch;
                            }
                            escape = !1;
                        } else if ("\\" === ch) escape = !0; else {
                            if (ch === quote) return this.index++, void this.tokens.push({
                                index: start,
                                text: rawString,
                                constant: !0,
                                value: string
                            });
                            string += ch;
                        }
                        this.index++;
                    }
                    this.throwError("Unterminated quote", start);
                }
            };
            var AST = function(lexer, options) {
                this.lexer = lexer, this.options = options;
            };
            AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression",
            AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression",
            AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression",
            AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression",
            AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression",
            AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression",
            AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter",
            AST.prototype = {
                ast: function(text) {
                    this.text = text, this.tokens = this.lexer.lex(text);
                    var value = this.program();
                    return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]),
                    value;
                },
                program: function() {
                    for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()),
                    !this.expect(";")) return {
                        type: AST.Program,
                        body: body
                    };
                },
                expressionStatement: function() {
                    return {
                        type: AST.ExpressionStatement,
                        expression: this.filterChain()
                    };
                },
                filterChain: function() {
                    for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
                    return left;
                },
                expression: function() {
                    return this.assignment();
                },
                assignment: function() {
                    var result = this.ternary();
                    if (this.expect("=")) {
                        if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                        result = {
                            type: AST.AssignmentExpression,
                            left: result,
                            right: this.assignment(),
                            operator: "="
                        };
                    }
                    return result;
                },
                ternary: function() {
                    var alternate, consequent, test = this.logicalOR();
                    return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(),
                    {
                        type: AST.ConditionalExpression,
                        test: test,
                        alternate: alternate,
                        consequent: consequent
                    }) : test;
                },
                logicalOR: function() {
                    for (var left = this.logicalAND(); this.expect("||"); ) left = {
                        type: AST.LogicalExpression,
                        operator: "||",
                        left: left,
                        right: this.logicalAND()
                    };
                    return left;
                },
                logicalAND: function() {
                    for (var left = this.equality(); this.expect("&&"); ) left = {
                        type: AST.LogicalExpression,
                        operator: "&&",
                        left: left,
                        right: this.equality()
                    };
                    return left;
                },
                equality: function() {
                    for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.relational()
                    };
                    return left;
                },
                relational: function() {
                    for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.additive()
                    };
                    return left;
                },
                additive: function() {
                    for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.multiplicative()
                    };
                    return left;
                },
                multiplicative: function() {
                    for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.unary()
                    };
                    return left;
                },
                unary: function() {
                    var token;
                    return (token = this.expect("+", "-", "!")) ? {
                        type: AST.UnaryExpression,
                        operator: token.text,
                        prefix: !0,
                        argument: this.unary()
                    } : this.primary();
                },
                primary: function() {
                    var primary;
                    this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                        type: AST.Literal,
                        value: this.options.literals[this.consume().text]
                    } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
                    for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    }, this.consume(")")) : "[" === next.text ? (primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.expression(),
                        computed: !0
                    }, this.consume("]")) : "." === next.text ? primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.identifier(),
                        computed: !1
                    } : this.throwError("IMPOSSIBLE");
                    return primary;
                },
                filter: function(baseExpression) {
                    for (var args = [ baseExpression ], result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: !0
                    }; this.expect(":"); ) args.push(this.expression());
                    return result;
                },
                parseArguments: function() {
                    var args = [];
                    if (")" !== this.peekToken().text) do {
                        args.push(this.filterChain());
                    } while (this.expect(","));
                    return args;
                },
                identifier: function() {
                    var token = this.consume();
                    return token.identifier || this.throwError("is not a valid identifier", token),
                    {
                        type: AST.Identifier,
                        name: token.text
                    };
                },
                constant: function() {
                    return {
                        type: AST.Literal,
                        value: this.consume().value
                    };
                },
                arrayDeclaration: function() {
                    var elements = [];
                    if ("]" !== this.peekToken().text) do {
                        if (this.peek("]")) break;
                        elements.push(this.expression());
                    } while (this.expect(","));
                    return this.consume("]"), {
                        type: AST.ArrayExpression,
                        elements: elements
                    };
                },
                object: function() {
                    var property, properties = [];
                    if ("}" !== this.peekToken().text) do {
                        if (this.peek("}")) break;
                        property = {
                            type: AST.Property,
                            kind: "init"
                        }, this.peek().constant ? (property.key = this.constant(), property.computed = !1,
                        this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(),
                        property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["),
                        property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"),
                        property.value = this.expression()) : this.throwError("invalid key", this.peek()),
                        properties.push(property);
                    } while (this.expect(","));
                    return this.consume("}"), {
                        type: AST.ObjectExpression,
                        properties: properties
                    };
                },
                throwError: function(msg, token) {
                    throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
                },
                consume: function(e1) {
                    if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    var token = this.expect(e1);
                    return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()),
                    token;
                },
                peekToken: function() {
                    if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    return this.tokens[0];
                },
                peek: function(e1, e2, e3, e4) {
                    return this.peekAhead(0, e1, e2, e3, e4);
                },
                peekAhead: function(i, e1, e2, e3, e4) {
                    if (this.tokens.length > i) {
                        var token = this.tokens[i], t = token.text;
                        if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
                    }
                    return !1;
                },
                expect: function(e1, e2, e3, e4) {
                    var token = this.peek(e1, e2, e3, e4);
                    return !!token && (this.tokens.shift(), token);
                },
                selfReferential: {
                    this: {
                        type: AST.ThisExpression
                    },
                    $locals: {
                        type: AST.LocalsExpression
                    }
                }
            };
            var PURITY_ABSOLUTE = 1, PURITY_RELATIVE = 2;
            ASTCompiler.prototype = {
                compile: function(ast) {
                    var self = this;
                    this.state = {
                        nextId: 0,
                        filters: {},
                        fn: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        assign: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        inputs: []
                    }, findConstantAndWatchExpressions(ast, self.$filter);
                    var assignable, extra = "";
                    if (this.stage = "assign", assignable = assignableAST(ast)) {
                        this.state.computing = "assign";
                        var result = this.nextId();
                        this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
                    }
                    var toWatch = getInputs(ast.body);
                    self.stage = "inputs", forEach(toWatch, function(watch, key) {
                        var fnKey = "fn" + key;
                        self.state[fnKey] = {
                            vars: [],
                            body: [],
                            own: {}
                        }, self.state.computing = fnKey;
                        var intoId = self.nextId();
                        self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                            name: fnKey,
                            isPure: watch.isPure
                        }), watch.watchId = key;
                    }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
                    var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                    return this.state = this.stage = void 0, fn;
                },
                USE: "use",
                STRICT: "strict",
                watchFns: function() {
                    var result = [], inputs = this.state.inputs, self = this;
                    return forEach(inputs, function(input) {
                        result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")),
                        input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
                    }), inputs.length && result.push("fn.inputs=[" + inputs.map(function(i) {
                        return i.name;
                    }).join(",") + "];"), result.join("");
                },
                generateFunction: function(name, params) {
                    return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
                },
                filterPrefix: function() {
                    var parts = [], self = this;
                    return forEach(this.state.filters, function(id, filter) {
                        parts.push(id + "=$filter(" + self.escape(filter) + ")");
                    }), parts.length ? "var " + parts.join(",") + ";" : "";
                },
                varsPrefix: function(section) {
                    return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
                },
                body: function(section) {
                    return this.state[section].body.join("");
                },
                recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var left, right, args, expression, computed, self = this;
                    if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(),
                    void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
                    switch (ast.type) {
                      case AST.Program:
                        forEach(ast.body, function(expression, pos) {
                            self.recurse(expression.expression, void 0, void 0, function(expr) {
                                right = expr;
                            }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                        });
                        break;

                      case AST.Literal:
                        expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;

                      case AST.UnaryExpression:
                        this.recurse(ast.argument, void 0, void 0, function(expr) {
                            right = expr;
                        }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression),
                        recursionFn(expression);
                        break;

                      case AST.BinaryExpression:
                        this.recurse(ast.left, void 0, void 0, function(expr) {
                            left = expr;
                        }), this.recurse(ast.right, void 0, void 0, function(expr) {
                            right = expr;
                        }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")",
                        this.assign(intoId, expression), recursionFn(expression);
                        break;

                      case AST.LogicalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)),
                        recursionFn(intoId);
                        break;

                      case AST.ConditionalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)),
                        recursionFn(intoId);
                        break;

                      case AST.Identifier:
                        intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"),
                        nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                            self.if_("inputs" === self.stage || "s", function() {
                                create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")),
                                self.assign(intoId, self.nonComputedMember("s", ast.name));
                            });
                        }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                        break;

                      case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(),
                        self.recurse(ast.object, left, void 0, function() {
                            self.if_(self.notNull(left), function() {
                                ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right),
                                create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")),
                                expression = self.computedMember(left, right), self.assign(intoId, expression),
                                nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")),
                                expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression),
                                nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                            }, function() {
                                self.assign(intoId, "undefined");
                            }), recursionFn(intoId);
                        }, !!create);
                        break;

                      case AST.CallExpression:
                        intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name),
                        args = [], forEach(ast.arguments, function(expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument), args.push(argument);
                        }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression),
                        recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                            self.if_(self.notNull(right), function() {
                                forEach(ast.arguments, function(expr) {
                                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                        args.push(argument);
                                    });
                                }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")",
                                self.assign(intoId, expression);
                            }, function() {
                                self.assign(intoId, "undefined");
                            }), recursionFn(intoId);
                        }));
                        break;

                      case AST.AssignmentExpression:
                        right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                            self.if_(self.notNull(left.context), function() {
                                self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right,
                                self.assign(intoId, expression), recursionFn(intoId || expression);
                            });
                        }, 1);
                        break;

                      case AST.ArrayExpression:
                        args = [], forEach(ast.elements, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument);
                            });
                        }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;

                      case AST.ObjectExpression:
                        args = [], computed = !1, forEach(ast.properties, function(property) {
                            property.computed && (computed = !0);
                        }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                            property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                            right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                        })) : (forEach(ast.properties, function(property) {
                            self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                            });
                        }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                        break;

                      case AST.ThisExpression:
                        this.assign(intoId, "s"), recursionFn(intoId || "s");
                        break;

                      case AST.LocalsExpression:
                        this.assign(intoId, "l"), recursionFn(intoId || "l");
                        break;

                      case AST.NGValueParameter:
                        this.assign(intoId, "v"), recursionFn(intoId || "v");
                    }
                },
                getHasOwnProperty: function(element, property) {
                    var key = element + "." + property, own = this.current().own;
                    return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")),
                    own[key];
                },
                assign: function(id, value) {
                    if (id) return this.current().body.push(id, "=", value, ";"), id;
                },
                filter: function(filterName) {
                    return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)),
                    this.state.filters[filterName];
                },
                ifDefined: function(id, defaultValue) {
                    return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
                },
                plus: function(left, right) {
                    return "plus(" + left + "," + right + ")";
                },
                return_: function(id) {
                    this.current().body.push("return ", id, ";");
                },
                if_: function(test, alternate, consequent) {
                    if (!0 === test) alternate(); else {
                        var body = this.current().body;
                        body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"),
                        consequent(), body.push("}"));
                    }
                },
                not: function(expression) {
                    return "!(" + expression + ")";
                },
                isNull: function(expression) {
                    return expression + "==null";
                },
                notNull: function(expression) {
                    return expression + "!=null";
                },
                nonComputedMember: function(left, right) {
                    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/, UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                    return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
                },
                computedMember: function(left, right) {
                    return left + "[" + right + "]";
                },
                member: function(left, right, computed) {
                    return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
                },
                getStringValue: function(item) {
                    this.assign(item, "getStringValue(" + item + ")");
                },
                lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var self = this;
                    return function() {
                        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                    };
                },
                lazyAssign: function(id, value) {
                    var self = this;
                    return function() {
                        self.assign(id, value);
                    };
                },
                stringEscapeRegex: /[^ a-zA-Z0-9]/g,
                stringEscapeFn: function(c) {
                    return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
                },
                escape: function(value) {
                    if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                    if (isNumber(value)) return value.toString();
                    if (!0 === value) return "true";
                    if (!1 === value) return "false";
                    if (null === value) return "null";
                    if (void 0 === value) return "undefined";
                    throw $parseMinErr("esc", "IMPOSSIBLE");
                },
                nextId: function(skip, init) {
                    var id = "v" + this.state.nextId++;
                    return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
                },
                current: function() {
                    return this.state[this.state.computing];
                }
            }, ASTInterpreter.prototype = {
                compile: function(ast) {
                    var self = this;
                    findConstantAndWatchExpressions(ast, self.$filter);
                    var assignable, assign;
                    (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
                    var inputs, toWatch = getInputs(ast.body);
                    toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                        var input = self.recurse(watch);
                        input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key;
                    }));
                    var expressions = [];
                    forEach(ast.body, function(expression) {
                        expressions.push(self.recurse(expression.expression));
                    });
                    var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                        var lastValue;
                        return forEach(expressions, function(exp) {
                            lastValue = exp(scope, locals);
                        }), lastValue;
                    };
                    return assign && (fn.assign = function(scope, value, locals) {
                        return assign(scope, locals, value);
                    }), inputs && (fn.inputs = inputs), fn;
                },
                recurse: function(ast, context, create) {
                    var left, right, args, self = this;
                    if (ast.input) return this.inputs(ast.input, ast.watchId);
                    switch (ast.type) {
                      case AST.Literal:
                        return this.value(ast.value, context);

                      case AST.UnaryExpression:
                        return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

                      case AST.BinaryExpression:
                      case AST.LogicalExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

                      case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

                      case AST.Identifier:
                        return self.identifier(ast.name, context, create);

                      case AST.MemberExpression:
                        return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name),
                        ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

                      case AST.CallExpression:
                        return args = [], forEach(ast.arguments, function(expr) {
                            args.push(self.recurse(expr));
                        }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)),
                        ast.filter ? function(scope, locals, assign, inputs) {
                            for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                            var value = right.apply(void 0, values, inputs);
                            return context ? {
                                context: void 0,
                                name: void 0,
                                value: value
                            } : value;
                        } : function(scope, locals, assign, inputs) {
                            var value, rhs = right(scope, locals, assign, inputs);
                            if (null != rhs.value) {
                                for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                                value = rhs.value.apply(rhs.context, values);
                            }
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.AssignmentExpression:
                        return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                            return lhs.context[lhs.name] = rhs, context ? {
                                value: rhs
                            } : rhs;
                        };

                      case AST.ArrayExpression:
                        return args = [], forEach(ast.elements, function(expr) {
                            args.push(self.recurse(expr));
                        }), function(scope, locals, assign, inputs) {
                            for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.ObjectExpression:
                        return args = [], forEach(ast.properties, function(property) {
                            property.computed ? args.push({
                                key: self.recurse(property.key),
                                computed: !0,
                                value: self.recurse(property.value)
                            }) : args.push({
                                key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                computed: !1,
                                value: self.recurse(property.value)
                            });
                        }), function(scope, locals, assign, inputs) {
                            for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.ThisExpression:
                        return function(scope) {
                            return context ? {
                                value: scope
                            } : scope;
                        };

                      case AST.LocalsExpression:
                        return function(scope, locals) {
                            return context ? {
                                value: locals
                            } : locals;
                        };

                      case AST.NGValueParameter:
                        return function(scope, locals, assign) {
                            return context ? {
                                value: assign
                            } : assign;
                        };
                    }
                },
                "unary+": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        return arg = isDefined(arg) ? +arg : 0, context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary-": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        return arg = isDefined(arg) ? -arg : -0, context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary!": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = !argument(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary+": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary-": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary*": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary/": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary%": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary===": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary&&": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary||": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "ternary?:": function(test, alternate, consequent, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                value: function(value, context) {
                    return function() {
                        return context ? {
                            context: void 0,
                            name: void 0,
                            value: value
                        } : value;
                    };
                },
                identifier: function(name, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var base = locals && name in locals ? locals : scope;
                        create && 1 !== create && base && null == base[name] && (base[name] = {});
                        var value = base ? base[name] : void 0;
                        return context ? {
                            context: base,
                            name: name,
                            value: value
                        } : value;
                    };
                },
                computedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var rhs, value, lhs = left(scope, locals, assign, inputs);
                        return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs),
                        create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]),
                        context ? {
                            context: lhs,
                            name: rhs,
                            value: value
                        } : value;
                    };
                },
                nonComputedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                        var value = null != lhs ? lhs[right] : void 0;
                        return context ? {
                            context: lhs,
                            name: right,
                            value: value
                        } : value;
                    };
                },
                inputs: function(input, watchId) {
                    return function(scope, value, locals, inputs) {
                        return inputs ? inputs[watchId] : input(scope, value, locals);
                    };
                }
            }, Parser.prototype = {
                constructor: Parser,
                parse: function(text) {
                    var ast = this.getAst(text), fn = this.astCompiler.compile(ast.ast);
                    return fn.literal = isLiteral(ast.ast), fn.constant = isConstant(ast.ast), fn.oneTime = ast.oneTime,
                    fn;
                },
                getAst: function(exp) {
                    var oneTime = !1;
                    return exp = exp.trim(), ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0,
                    exp = exp.substring(2)), {
                        ast: this.ast.ast(exp),
                        oneTime: oneTime
                    };
                }
            };
            var baseUrlParsingNode, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                MEDIA_URL: "mediaUrl",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g, $templateRequestMinErr = minErr("$templateRequest"), $timeoutMinErr = minErr("$timeout"), urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
            urlParsingNode.href = "http://[::1]";
            var ipv6InBrackets = "[::1]" === urlParsingNode.hostname;
            $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
            var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
            currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
            var DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4, 0, !1, !0),
                yy: dateGetter("FullYear", 2, 0, !0, !0),
                y: dateGetter("FullYear", 1, 0, !1, !0),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", !0),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                LLLL: dateStrGetter("Month", !1, !0),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", !0),
                a: ampmGetter,
                Z: timeZoneGetter,
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: longEraGetter
            }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
            dateFilter.$inject = [ "$locale" ];
            var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
            orderByFilter.$inject = [ "$parse" ];
            var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function(element, attr) {
                    if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                        if ("a" === element[0].nodeName.toLowerCase()) {
                            var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                            element.on("click", function(event) {
                                element.attr(href) || event.preventDefault();
                            });
                        }
                    };
                }
            }), ngAttributeAliasDirectives = {};
            forEach(BOOLEAN_ATTR, function(propName, attrName) {
                function defaultLinkFn(scope, element, attr) {
                    scope.$watch(attr[normalized], function(value) {
                        attr.$set(attrName, !!value);
                    });
                }
                if ("multiple" !== propName) {
                    var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
                    "checked" === propName && (linkFn = function(scope, element, attr) {
                        attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
                    }), ngAttributeAliasDirectives[normalized] = function() {
                        return {
                            restrict: "A",
                            priority: 100,
                            link: linkFn
                        };
                    };
                }
            }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
                ngAttributeAliasDirectives[ngAttr] = function() {
                    return {
                        priority: 100,
                        link: function(scope, element, attr) {
                            if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                                if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            }
                            scope.$watch(attr[ngAttr], function(value) {
                                attr.$set(ngAttr, value);
                            });
                        }
                    };
                };
            }), forEach([ "src", "srcset", "href" ], function(attrName) {
                var normalized = directiveNormalize("ng-" + attrName);
                ngAttributeAliasDirectives[normalized] = [ "$sce", function($sce) {
                    return {
                        priority: 99,
                        link: function(scope, element, attr) {
                            var propName = attrName, name = attrName;
                            "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref",
                            attr.$attr[name] = "xlink:href", propName = null), attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized])),
                            attr.$observe(normalized, function(value) {
                                if (!value) return void ("href" === attrName && attr.$set(name, null));
                                attr.$set(name, value), msie && propName && element.prop(propName, attr[name]);
                            });
                        }
                    };
                } ];
            });
            var nullFormCtrl = {
                $addControl: noop,
                $getControls: valueFn([]),
                $$renameControl: nullFormRenameControl,
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop,
                $$setSubmitted: noop
            }, PENDING_CLASS = "ng-pending";
            FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ],
            FormController.prototype = {
                $rollbackViewValue: function() {
                    forEach(this.$$controls, function(control) {
                        control.$rollbackViewValue();
                    });
                },
                $commitViewValue: function() {
                    forEach(this.$$controls, function(control) {
                        control.$commitViewValue();
                    });
                },
                $addControl: function(control) {
                    assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control),
                    control.$name && (this[control.$name] = control), control.$$parentForm = this;
                },
                $getControls: function() {
                    return shallowCopy(this.$$controls);
                },
                $$renameControl: function(control, newName) {
                    var oldName = control.$name;
                    this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName;
                },
                $removeControl: function(control) {
                    control.$name && this[control.$name] === control && delete this[control.$name],
                    forEach(this.$pending, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this), forEach(this.$error, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this), forEach(this.$$success, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
                },
                $setDirty: function() {
                    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS),
                    this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
                },
                $setPristine: function() {
                    this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " ng-submitted"),
                    this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                        control.$setPristine();
                    });
                },
                $setUntouched: function() {
                    forEach(this.$$controls, function(control) {
                        control.$setUntouched();
                    });
                },
                $setSubmitted: function() {
                    for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl; ) rootForm = rootForm.$$parentForm;
                    rootForm.$$setSubmitted();
                },
                $$setSubmitted: function() {
                    this.$$animate.addClass(this.$$element, "ng-submitted"), this.$submitted = !0, forEach(this.$$controls, function(control) {
                        control.$$setSubmitted && control.$$setSubmitted();
                    });
                }
            }, addSetValidityMethod({
                clazz: FormController,
                set: function(object, property, controller) {
                    var list = object[property];
                    if (list) {
                        -1 === list.indexOf(controller) && list.push(controller);
                    } else object[property] = [ controller ];
                },
                unset: function(object, property, controller) {
                    var list = object[property];
                    list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
                }
            });
            var formDirectiveFactory = function(isNgForm) {
                return [ "$timeout", "$parse", function($timeout, $parse) {
                    function getSetter(expression) {
                        return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
                    }
                    return {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: [ "form", "^^?form" ],
                        controller: FormController,
                        compile: function(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                            return {
                                pre: function(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function(event) {
                                            scope.$apply(function() {
                                                controller.$commitViewValue(), controller.$setSubmitted();
                                            }), event.preventDefault();
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                            $timeout(function() {
                                                formElement[0].removeEventListener("submit", handleFormSubmission);
                                            }, 0, !1);
                                        });
                                    }
                                    (ctrls[1] || controller.$$parentForm).$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                        controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue),
                                        (setter = getSetter(controller.$name))(scope, controller));
                                    })), formElement.on("$destroy", function() {
                                        controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                                    });
                                }
                            };
                        }
                    };
                } ];
            }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
            forEach("date,datetime-local,month,time,week".split(","), function(type) {
                PARTIAL_VALIDATION_TYPES[type] = !0;
            });
            var inputType = {
                text: textInputType,
                date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
                "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
                time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
                week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
                month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
                number: numberInputType,
                url: urlInputType,
                email: emailInputType,
                radio: radioInputType,
                range: rangeInputType,
                checkbox: checkboxInputType,
                hidden: noop,
                button: noop,
                submit: noop,
                reset: noop,
                file: noop
            }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: [ "?ngModel" ],
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                        }
                    }
                };
            } ], hiddenInputBrowserCacheDirective = function() {
                var valueProperty = {
                    configurable: !0,
                    enumerable: !1,
                    get: function() {
                        return this.getAttribute("value") || "";
                    },
                    set: function(val) {
                        this.setAttribute("value", val);
                    }
                };
                return {
                    restrict: "E",
                    priority: 200,
                    compile: function(_, attr) {
                        if ("hidden" === lowercase(attr.type)) return {
                            pre: function(scope, element, attr, ctrls) {
                                var node = element[0];
                                node.parentNode && node.parentNode.insertBefore(node, node.nextSibling), Object.defineProperty && Object.defineProperty(node, "value", valueProperty);
                            }
                        };
                    }
                };
            }, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
                function updateElementValue(element, attr, value) {
                    var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
                    element.prop("value", propValue), attr.$set("value", value);
                }
                return {
                    restrict: "A",
                    priority: 100,
                    compile: function(tpl, tplAttr) {
                        return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                            updateElementValue(elm, attr, scope.$eval(attr.ngValue));
                        } : function(scope, elm, attr) {
                            scope.$watch(attr.ngValue, function(value) {
                                updateElementValue(elm, attr, value);
                            });
                        };
                    }
                };
            }, ngBindDirective = [ "$compile", function($compile) {
                return {
                    restrict: "AC",
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                                element.textContent = stringify(value);
                            });
                        };
                    }
                };
            } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
                return {
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0],
                            attr.$observe("ngBindTemplate", function(value) {
                                element.textContent = isUndefined(value) ? "" : value;
                            });
                        };
                    }
                };
            } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                            return $sce.valueOf(val);
                        });
                        return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                                var value = ngBindHtmlGetter(scope);
                                element.html($sce.getTrustedHtml(value) || "");
                            });
                        };
                    }
                };
            } ], ngChangeDirective = valueFn({
                restrict: "A",
                require: "ngModel",
                link: function(scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push(function() {
                        scope.$eval(attr.ngChange);
                    });
                }
            }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
                compile: function(element, attr) {
                    attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
                }
            }), ngControllerDirective = [ function() {
                return {
                    restrict: "A",
                    scope: !0,
                    controller: "@",
                    priority: 500
                };
            } ], ngEventDirectives = {}, forceAsyncEvents = {
                blur: !0,
                focus: !0
            };
            forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
                var directiveName = directiveNormalize("ng-" + eventName);
                ngEventDirectives[directiveName] = [ "$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
                    return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName]);
                } ];
            });
            var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    multiElement: !0,
                    transclude: "element",
                    priority: 600,
                    terminal: !0,
                    restrict: "A",
                    $$tlb: !0,
                    link: function($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function(value) {
                            value ? childScope || $transclude(function(clone, newScope) {
                                childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf),
                                block = {
                                    clone: clone
                                }, $animate.enter(clone, $element.parent(), $element);
                            }) : (previousElements && (previousElements.remove(), previousElements = null),
                            childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone),
                            $animate.leave(previousElements).done(function(response) {
                                !1 !== response && (previousElements = null);
                            }), block = null));
                        });
                    }
                };
            } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: !0,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function(element, attr) {
                        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                        return function(scope, $element, $attr, ctrl, $transclude) {
                            var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(),
                                currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                                    !1 !== response && (previousElement = null);
                                }), previousElement = currentElement, currentElement = null);
                            };
                            scope.$watch(srcExp, function(src) {
                                var afterAnimation = function(response) {
                                    !1 === response || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                                }, thisChangeId = ++changeCounter;
                                src ? ($templateRequest(src, !0).then(function(response) {
                                    if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function(clone) {
                                            cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                                        });
                                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src),
                                        scope.$eval(onloadExp);
                                    }
                                }, function() {
                                    scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(),
                                    scope.$emit("$includeContentError", src));
                                }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(),
                                ctrl.template = null);
                            });
                        };
                    }
                };
            } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function(scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) return $element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                            $element.append(clone);
                        }, {
                            futureParentElement: $element
                        });
                        $element.html(ctrl.template), $compile($element.contents())(scope);
                    }
                };
            } ], ngInitDirective = ngDirective({
                priority: 450,
                compile: function() {
                    return {
                        pre: function(scope, element, attrs) {
                            scope.$eval(attrs.ngInit);
                        }
                    };
                }
            }), ngListDirective = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    require: "ngModel",
                    link: function(scope, element, attr, ctrl) {
                        var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                            if (!isUndefined(viewValue)) {
                                var list = [];
                                return viewValue && forEach(viewValue.split(separator), function(value) {
                                    value && list.push(trimValues ? trim(value) : value);
                                }), list;
                            }
                        };
                        ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                            if (isArray(value)) return value.join(ngList);
                        }), ctrl.$isEmpty = function(value) {
                            return !value || !value.length;
                        };
                    }
                };
            }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", ngModelMinErr = minErr("ngModel");
            NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ],
            NgModelController.prototype = {
                $$initGetterSetters: function() {
                    if (this.$options.getOption("getterSetter")) {
                        var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                        this.$$ngModelGet = function($scope) {
                            var modelValue = this.$$parsedNgModel($scope);
                            return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                        }, this.$$ngModelSet = function($scope, newValue) {
                            isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                                $$$p: newValue
                            }) : this.$$parsedNgModelAssign($scope, newValue);
                        };
                    } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
                },
                $render: noop,
                $isEmpty: function(value) {
                    return isUndefined(value) || "" === value || null === value || value !== value;
                },
                $$updateEmptyClasses: function(value) {
                    this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"),
                    this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"),
                    this.$$animate.addClass(this.$$element, "ng-not-empty"));
                },
                $setPristine: function() {
                    this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS),
                    this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
                },
                $setDirty: function() {
                    this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS),
                    this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
                },
                $setUntouched: function() {
                    this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched");
                },
                $setTouched: function() {
                    this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched");
                },
                $rollbackViewValue: function() {
                    this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue,
                    this.$render();
                },
                $validate: function() {
                    if (!isNumberNaN(this.$modelValue)) {
                        var viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), that = this;
                        this.$$runValidators(modelValue, viewValue, function(allValid) {
                            allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0,
                            that.$modelValue !== prevModelValue && that.$$writeModelToScope());
                        });
                    }
                },
                $$runValidators: function(modelValue, viewValue, doneCallback) {
                    function setValidity(name, isValid) {
                        localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
                    }
                    function validationDone(allValid) {
                        localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
                    }
                    this.$$currentValidationRunId++;
                    var localValidationRunId = this.$$currentValidationRunId, that = this;
                    return function() {
                        var errorKey = that.$$parserName;
                        return isUndefined(that.$$parserValid) ? (setValidity(errorKey, null), !0) : (that.$$parserValid || (forEach(that.$validators, function(v, name) {
                            setValidity(name, null);
                        }), forEach(that.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        })), setValidity(errorKey, that.$$parserValid), that.$$parserValid);
                    }() && function() {
                        var syncValidatorsValid = !0;
                        return forEach(that.$validators, function(validator, name) {
                            var result = Boolean(validator(modelValue, viewValue));
                            syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                        }), !!syncValidatorsValid || (forEach(that.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        }), !1);
                    }() ? void function() {
                        var validatorPromises = [], allValid = !0;
                        forEach(that.$asyncValidators, function(validator, name) {
                            var promise = validator(modelValue, viewValue);
                            if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                            setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                                setValidity(name, !0);
                            }, function() {
                                allValid = !1, setValidity(name, !1);
                            }));
                        }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                            validationDone(allValid);
                        }, noop) : validationDone(!0);
                    }() : void validationDone(!1);
                },
                $commitViewValue: function() {
                    var viewValue = this.$viewValue;
                    this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue),
                    this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
                },
                $$parseAndValidate: function() {
                    function writeToModelIfNeeded() {
                        that.$modelValue !== prevModelValue && that.$$writeModelToScope();
                    }
                    var viewValue = this.$$lastCommittedViewValue, modelValue = viewValue, that = this;
                    if (this.$$parserValid = !isUndefined(modelValue) || void 0, this.$setValidity(this.$$parserName, null),
                    this.$$parserName = "parse", this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (modelValue = this.$parsers[i](modelValue),
                    isUndefined(modelValue)) {
                        this.$$parserValid = !1;
                        break;
                    }
                    isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
                    var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
                    this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue,
                    writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                        allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
                    });
                },
                $$writeModelToScope: function() {
                    this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                        try {
                            listener();
                        } catch (e) {
                            this.$$exceptionHandler(e);
                        }
                    }, this);
                },
                $setViewValue: function(value, trigger) {
                    this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
                },
                $$debounceViewValueCommit: function(trigger) {
                    var debounceDelay = this.$options.getOption("debounce");
                    isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && -1 === this.$options.getOption("updateOn").indexOf(trigger) ? debounceDelay = debounceDelay.default : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]),
                    this.$$timeout.cancel(this.$$pendingDebounce);
                    var that = this;
                    debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout(function() {
                        that.$commitViewValue();
                    }, debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                        that.$commitViewValue();
                    });
                },
                $overrideModelOptions: function(options) {
                    this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents();
                },
                $processModelValue: function() {
                    var viewValue = this.$$format();
                    this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue,
                    this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop));
                },
                $$format: function() {
                    for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                    return viewValue;
                },
                $$setModelValue: function(modelValue) {
                    this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0,
                    this.$processModelValue();
                },
                $$setUpdateOnEvents: function() {
                    this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler),
                    this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
                },
                $$updateEventHandler: function(ev) {
                    this.$$debounceViewValueCommit(ev && ev.type);
                }
            }, addSetValidityMethod({
                clazz: NgModelController,
                set: function(object, property) {
                    object[property] = !0;
                },
                unset: function(object, property) {
                    delete object[property];
                }
            });
            var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
                return {
                    restrict: "A",
                    require: [ "ngModel", "^?form", "^?ngModelOptions" ],
                    controller: NgModelController,
                    priority: 1,
                    compile: function(element) {
                        return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS),
                        {
                            pre: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                                optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(),
                                formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                                    modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                }), scope.$on("$destroy", function() {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                });
                            },
                            post: function(scope, element, attr, ctrls) {
                                function setTouched() {
                                    modelCtrl.$setTouched();
                                }
                                var modelCtrl = ctrls[0];
                                modelCtrl.$$setUpdateOnEvents(), element.on("blur", function() {
                                    modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                                });
                            }
                        };
                    }
                };
            } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
            ModelOptions.prototype = {
                getOption: function(name) {
                    return this.$$options[name];
                },
                createChild: function(options) {
                    var inheritAll = !1;
                    return options = extend({}, options), forEach(options, function(option, key) {
                        "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key],
                        "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1,
                        options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                            return options.updateOnDefault = !0, " ";
                        })));
                    }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)),
                    defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
                }
            }, defaultModelOptions = new ModelOptions({
                updateOn: "",
                updateOnDefault: !0,
                debounce: 0,
                getterSetter: !1,
                allowInvalid: !1,
                timezone: null
            });
            var ngModelOptionsDirective = function() {
                function NgModelOptionsController($attrs, $scope) {
                    this.$$attrs = $attrs, this.$$scope = $scope;
                }
                return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
                    $onInit: function() {
                        var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                        this.$options = parentOptions.createChild(modelOptionsDefinition);
                    }
                }, {
                    restrict: "A",
                    priority: 10,
                    require: {
                        parentCtrl: "?^^ngModelOptions"
                    },
                    bindToController: !0,
                    controller: NgModelOptionsController
                };
            }, ngNonBindableDirective = ngDirective({
                terminal: !0,
                priority: 1e3
            }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue, this.viewValue = viewValue, this.label = label,
                        this.group = group, this.disabled = disabled;
                    }
                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                        }
                        return optionValuesKeys;
                    }
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                        return trackByFn(scope, locals);
                    } : function(value) {
                        return hashKey(value);
                    }, getTrackByValue = function(value, key) {
                        return getTrackByValueFn(value, getLocals(value, key));
                    }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                        return locals[keyName] = key, locals[valueName] = value, locals;
                    } : function(value) {
                        return locals[valueName] = value, locals;
                    };
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function(optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                                if (watchedArray.push(selectValue), match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label);
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen);
                                }
                            }
                            return watchedArray;
                        }),
                        getOptions: function() {
                            for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function(value) {
                                    return selectValueMap[getTrackByValue(value)];
                                },
                                getViewValueFromOption: function(option) {
                                    return trackBy ? copy(option.viewValue) : option.viewValue;
                                }
                            };
                        }
                    };
                }
                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(!1);
                        parent.appendChild(optionElement), updateOptionElement(option, optionElement);
                    }
                    function getAndUpdateSelectedOption(viewValue) {
                        var option = options.getOptionFromViewValue(viewValue), element = option && option.element;
                        return element && !element.selected && (element.selected = !0), option;
                    }
                    function updateOptionElement(option, element) {
                        option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label,
                        element.textContent = option.label), element.value = option.selectValue;
                    }
                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options) for (var i = options.items.length - 1; i >= 0; i--) {
                            var option = options.items[i];
                            jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element);
                        }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        if (options.items.forEach(function(option) {
                            var groupElement;
                            isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1),
                            listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group,
                            groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                        }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue();
                            (ngOptions.trackBy || multiple ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue),
                            ngModelCtrl.$render());
                        }
                    }
                    for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) if ("" === children[i].value) {
                        selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                        break;
                    }
                    selectElement.empty();
                    var providedEmptyOption = !!selectCtrl.emptyOption;
                    jqLite(optionTemplate.cloneNode(!1)).val("?");
                    var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
                    selectCtrl.generateUnknownOptionValue = function(val) {
                        return "?";
                    }, multiple ? (selectCtrl.writeValue = function(values) {
                        if (options) {
                            var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                            options.items.forEach(function(option) {
                                option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                            });
                        }
                    }, selectCtrl.readValue = function() {
                        var selectedValues = selectElement.val() || [], selections = [];
                        return forEach(selectedValues, function(value) {
                            var option = options.selectValueMap[value];
                            option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                        }), selections;
                    }, ngOptions.trackBy && scope.$watchCollection(function() {
                        if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map(function(value) {
                            return ngOptions.getTrackByValue(value);
                        });
                    }, function() {
                        ngModelCtrl.$render();
                    })) : (selectCtrl.writeValue = function(value) {
                        if (options) {
                            var selectedOption = selectElement[0].options[selectElement[0].selectedIndex], option = options.getOptionFromViewValue(value);
                            selectedOption && selectedOption.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(),
                            selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value);
                        }
                    }, selectCtrl.readValue = function() {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(),
                        selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
                    }, ngOptions.trackBy && scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    })), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption),
                    selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1,
                    selectCtrl.registerOption = function(optionScope, optionEl) {
                        "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl,
                        selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                            var needsRerender = selectCtrl.$isEmptyOptionSelected();
                            selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render();
                        }));
                    }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                }
                var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
                return {
                    restrict: "A",
                    terminal: !0,
                    require: [ "select", "ngModel" ],
                    link: {
                        pre: function(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: ngOptionsPostLink
                    }
                };
            } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
                var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function(scope, element, attr) {
                        function updateElementText(newText) {
                            element.text(newText || "");
                        }
                        var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                        forEach(attr, function(expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        }), forEach(whens, function(expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        }), scope.$watch(numberExp, function(newVal) {
                            var count = parseFloat(newVal), countIsNaN = isNumberNaN(count);
                            if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)),
                            !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp),
                                watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText),
                                lastCount = count;
                            }
                        });
                    }
                };
            } ], ngRefMinErr = minErr("ngRef"), ngRefDirective = [ "$parse", function($parse) {
                return {
                    priority: -1,
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var controllerName = directiveNormalize(nodeName_(tElement)), getter = $parse(tAttrs.ngRef), setter = getter.assign || function() {
                            throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
                        };
                        return function(scope, element, attrs) {
                            var refValue;
                            if (attrs.hasOwnProperty("ngRefRead")) {
                                if ("$element" === attrs.ngRefRead) refValue = element; else if (!(refValue = element.data("$" + attrs.ngRefRead + "Controller"))) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                            } else refValue = element.data("$" + controllerName + "Controller");
                            refValue = refValue || element, setter(scope, refValue), element.on("$destroy", function() {
                                getter(scope) === refValue && setter(scope, null);
                            });
                        };
                    }
                };
            } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
                var ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index,
                    scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last),
                    scope.$odd = !(scope.$even = 0 == (1 & index));
                }, getBlockStart = function(block) {
                    return block.clone[0];
                }, getBlockEnd = function(block) {
                    return block.clone[block.clone.length - 1];
                }, trackByIdArrayFn = function($scope, key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function($scope, key) {
                    return key;
                };
                return {
                    restrict: "A",
                    multiElement: !0,
                    transclude: "element",
                    priority: 1e3,
                    terminal: !0,
                    $$tlb: !0,
                    compile: function($element, $attr) {
                        var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                        if (!(match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        var trackByIdExpFn;
                        if (trackByExp) {
                            var hashFnLocals = {
                                $id: hashKey
                            }, trackByExpGetter = $parse(trackByExp);
                            trackByIdExpFn = function($scope, key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value,
                                hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                            };
                        }
                        return function($scope, $element, $attr, ctrl, $transclude) {
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function(collection) {
                                var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                                if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection,
                                trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                                    for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                                }
                                for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength),
                                index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index],
                                value = collection[key], trackById = trackByIdFn($scope, key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById],
                                delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                                    if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                        block && block.scope && (lastBlockMap[block.id] = block);
                                    }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                    nextBlockOrder[index] = {
                                        id: trackById,
                                        scope: void 0,
                                        clone: void 0
                                    }, nextBlockMap[trackById] = !0;
                                }
                                hashFnLocals && (hashFnLocals[valueIdentifier] = void 0);
                                for (var blockKey in lastBlockMap) {
                                    if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone),
                                    $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0,
                                    length = elementsToRemove.length; index < length; index++) elementsToRemove[index].$$NG_REMOVED = !0;
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index],
                                value = collection[key], block = nextBlockOrder[index], block.scope) {
                                    nextNode = previousNode;
                                    do {
                                        nextNode = nextNode.nextSibling;
                                    } while (nextNode && nextNode.$$NG_REMOVED);
                                    getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode),
                                    previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                } else $transclude(function(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(!1);
                                    clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode,
                                    block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                                lastBlockMap = nextBlockMap;
                            });
                        };
                    }
                };
            } ], ngShowDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngShow, function(value) {
                            $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            });
                        });
                    }
                };
            } ], ngHideDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngHide, function(value) {
                            $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            });
                        });
                    }
                };
            } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
                scope.$watchCollection(attr.ngStyle, function(newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                        element.css(style, "");
                    }), newStyles && element.css(newStyles);
                });
            }), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: [ "$scope", function() {
                        this.cases = {};
                    } ],
                    link: function(scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                            return function(response) {
                                !1 !== response && array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, function(value) {
                            for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                (previousLeaveAnimations[i] = $animate.leave(selected)).done(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                                selectedTransclude.transclude(function(caseElement, selectedScope) {
                                    selectedScopes.push(selectedScope);
                                    var anchor = selectedTransclude.element;
                                    caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                    var block = {
                                        clone: caseElement
                                    };
                                    selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                                });
                            });
                        });
                    }
                };
            } ], ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attrs, ctrl, $transclude) {
                    forEach(attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                        return array[index - 1] !== element;
                    }), function(whenCase) {
                        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                            transclude: $transclude,
                            element: element
                        });
                    });
                }
            }), ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    });
                }
            }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
                return {
                    restrict: "EAC",
                    compile: function(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        return tElement.empty(), function($scope, $element, $attrs, controller, $transclude) {
                            function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                                clone.length && notWhitespace(clone) ? $element.append(clone) : (useFallbackContent(),
                                transcludedScope.$destroy());
                            }
                            function useFallbackContent() {
                                fallbackLinkFn($scope, function(clone) {
                                    $element.append(clone);
                                });
                            }
                            function notWhitespace(nodes) {
                                for (var i = 0, ii = nodes.length; i < ii; i++) {
                                    var node = nodes[i];
                                    if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                                }
                            }
                            if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                            $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                            $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                        };
                    }
                };
            } ], scriptDirective = [ "$templateCache", function($templateCache) {
                return {
                    restrict: "E",
                    terminal: !0,
                    compile: function(element, attr) {
                        if ("text/ng-template" === attr.type) {
                            var templateUrl = attr.id, text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    }
                };
            } ], noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            }, SelectController = [ "$element", "$scope", function($element, $scope) {
                function scheduleRender() {
                    renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                        renderScheduled = !1, self.ngModelCtrl.$render();
                    }));
                }
                function scheduleViewValueUpdate(renderAfter) {
                    updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                        $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()),
                        renderAfter && self.ngModelCtrl.$render());
                    }));
                }
                var self = this, optionsMap = new NgMap();
                self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1,
                self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1,
                self.emptyOption = void 0, self.renderUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0),
                    $element.val(unknownVal);
                }, self.updateUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0),
                    $element.val(unknownVal);
                }, self.generateUnknownOptionValue = function(val) {
                    return "? " + hashKey(val) + " ?";
                }, self.removeUnknownOption = function() {
                    self.unknownOption.parent() && self.unknownOption.remove();
                }, self.selectEmptyOption = function() {
                    self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0));
                }, self.unselectEmptyOption = function() {
                    self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1);
                }, $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                }), self.readValue = function() {
                    var val = $element.val(), realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    return self.hasOption(realVal) ? realVal : null;
                }, self.writeValue = function(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1),
                    self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), !0);
                    } else self.selectUnknownOrEmptyOption(value);
                }, self.addOption = function(value, element) {
                    if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                        assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0,
                        self.emptyOption = element);
                        var count = optionsMap.get(value) || 0;
                        optionsMap.set(value, count + 1), scheduleRender();
                    }
                }, self.removeOption = function(value) {
                    var count = optionsMap.get(value);
                    count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1,
                    self.emptyOption = void 0)) : optionsMap.set(value, count - 1));
                }, self.hasOption = function(value) {
                    return !!optionsMap.get(value);
                }, self.$hasEmptyOption = function() {
                    return self.hasEmptyOption;
                }, self.$isUnknownOptionSelected = function() {
                    return $element[0].options[0] === self.unknownOption[0];
                }, self.$isEmptyOptionSelected = function() {
                    return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
                }, self.selectUnknownOrEmptyOption = function(value) {
                    null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
                };
                var renderScheduled = !1, updateScheduled = !1;
                self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (optionAttrs.$attr.ngValue) {
                        var oldVal, hashedVal;
                        optionAttrs.$observe("value", function(newVal) {
                            var removal, previouslySelected = optionElement.prop("selected");
                            isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal],
                            removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal,
                            self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
                        });
                    } else interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                        self.readValue();
                        var removal, previouslySelected = optionElement.prop("selected");
                        isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal,
                        self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
                    }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                        optionAttrs.$set("value", newVal);
                        var previouslySelected = optionElement.prop("selected");
                        oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement),
                        oldVal && previouslySelected && scheduleViewValueUpdate();
                    }) : self.addOption(optionAttrs.value, optionElement);
                    optionAttrs.$observe("disabled", function(newVal) {
                        ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null),
                        self.ngModelCtrl.$render()));
                    }), optionElement.on("$destroy", function() {
                        var currentValue = self.readValue(), removeValue = optionAttrs.value;
                        self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
                    });
                };
            } ], selectDirective = function() {
                function selectPreLink(scope, element, attr, ctrls) {
                    var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
                    if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                        selectCtrl.removeUnknownOption(), scope.$apply(function() {
                            ngModelCtrl.$setViewValue(selectCtrl.readValue());
                        });
                    }), attr.multiple) {
                        selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                            var array = [];
                            return forEach(element.find("option"), function(option) {
                                if (option.selected && !option.disabled) {
                                    var val = option.value;
                                    array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                                }
                            }), array;
                        }, selectCtrl.writeValue = function(value) {
                            forEach(element.find("option"), function(option) {
                                var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                                shouldBeSelected !== option.selected && setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                            });
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function() {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue),
                            ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                        }), ngModelCtrl.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        };
                    }
                }
                function selectPostLink(scope, element, attrs, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (ngModelCtrl) {
                        var selectCtrl = ctrls[0];
                        ngModelCtrl.$render = function() {
                            selectCtrl.writeValue(ngModelCtrl.$viewValue);
                        };
                    }
                }
                return {
                    restrict: "E",
                    require: [ "select", "?ngModel" ],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: selectPreLink,
                        post: selectPostLink
                    }
                };
            }, optionDirective = [ "$interpolate", function($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function(element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0)) || attr.$set("value", element.text())),
                        function(scope, element, attr) {
                            var parent = element.parent(), selectCtrl = parent.data("$selectController") || parent.parent().data("$selectController");
                            selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                        };
                    }
                };
            } ], requiredDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
                            attr.ngRequired || (attr.required = !0), ctrl.$validators.required = function(modelValue, viewValue) {
                                return !value || !ctrl.$isEmpty(viewValue);
                            }, attr.$observe("required", function(newVal) {
                                value !== newVal && (value = newVal, ctrl.$validate());
                            });
                        }
                    }
                };
            } ], patternDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    compile: function(tElm, tAttr) {
                        var patternExp, parseFn;
                        return tAttr.ngPattern && (patternExp = tAttr.ngPattern, parseFn = "/" === tAttr.ngPattern.charAt(0) && REGEX_STRING_REGEXP.test(tAttr.ngPattern) ? function() {
                            return tAttr.ngPattern;
                        } : $parse(tAttr.ngPattern)), function(scope, elm, attr, ctrl) {
                            if (ctrl) {
                                var attrVal = attr.pattern;
                                attr.ngPattern ? attrVal = parseFn(scope) : patternExp = attr.pattern;
                                var regexp = parsePatternAttr(attrVal, patternExp, elm);
                                attr.$observe("pattern", function(newVal) {
                                    var oldRegexp = regexp;
                                    regexp = parsePatternAttr(newVal, patternExp, elm), (oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString()) && ctrl.$validate();
                                }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                                    return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                                };
                            }
                        };
                    }
                };
            } ], maxlengthDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope), maxlengthParsed = parseLength(maxlength);
                            attr.$observe("maxlength", function(value) {
                                maxlength !== value && (maxlengthParsed = parseLength(value), maxlength = value,
                                ctrl.$validate());
                            }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
                            };
                        }
                    }
                };
            } ], minlengthDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var minlength = attr.minlength || $parse(attr.ngMinlength)(scope), minlengthParsed = parseLength(minlength) || -1;
                            attr.$observe("minlength", function(value) {
                                minlength !== value && (minlengthParsed = parseLength(value) || -1, minlength = value,
                                ctrl.$validate());
                            }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
                            };
                        }
                    }
                };
            } ];
            if (window.angular.bootstrap) return void (window.console && console.log("WARNING: Tried to load AngularJS more than once."));
            !function() {
                var originalCleanData;
                if (!bindJQueryFired) {
                    var jqName = jq();
                    jQuery = isUndefined(jqName) ? __webpack_provided_window_dot_jQuery : jqName ? window[jqName] : void 0,
                    jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                        scope: JQLitePrototype.scope,
                        isolateScope: JQLitePrototype.isolateScope,
                        controller: JQLitePrototype.controller,
                        injector: JQLitePrototype.injector,
                        inheritedData: JQLitePrototype.inheritedData
                    })) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
                        for (var events, elem, i = 0; null != (elem = elems[i]); i++) (events = (jqLite._data(elem) || {}).events) && events.$destroy && jqLite(elem).triggerHandler("$destroy");
                        originalCleanData(elems);
                    }, angular.element = jqLite, bindJQueryFired = !0;
                }
            }(), function(angular) {
                extend(angular, {
                    errorHandlingConfig: errorHandlingConfig,
                    bootstrap: bootstrap,
                    copy: copy,
                    extend: extend,
                    merge: merge,
                    equals: equals,
                    element: jqLite,
                    forEach: forEach,
                    injector: createInjector,
                    noop: noop,
                    bind: bind,
                    toJson: toJson,
                    fromJson: fromJson,
                    identity: identity,
                    isUndefined: isUndefined,
                    isDefined: isDefined,
                    isString: isString,
                    isFunction: isFunction,
                    isObject: isObject,
                    isNumber: isNumber,
                    isElement: isElement,
                    isArray: isArray,
                    version: version,
                    isDate: isDate,
                    callbacks: {
                        $$counter: 0
                    },
                    getTestability: getTestability,
                    reloadWithDebugInfo: reloadWithDebugInfo,
                    UNSAFE_restoreLegacyJqLiteXHTMLReplacement: UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
                    $$minErr: minErr,
                    $$csp: csp,
                    $$encodeUriSegment: encodeUriSegment,
                    $$encodeUriQuery: encodeUriQuery,
                    $$lowercase: lowercase,
                    $$stringify: stringify,
                    $$uppercase: uppercase
                }), angularModule = setupModuleLoader(window), angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
                    $provide.provider({
                        $$sanitizeUri: $$SanitizeUriProvider
                    }), $provide.provider("$compile", $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRef: ngRefDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        pattern: patternDirective,
                        ngPattern: patternDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        minlength: minlengthDirective,
                        ngMinlength: minlengthDirective,
                        maxlength: maxlengthDirective,
                        ngMaxlength: maxlengthDirective,
                        ngValue: ngValueDirective,
                        ngModelOptions: ngModelOptionsDirective
                    }).directive({
                        ngInclude: ngIncludeFillContentDirective,
                        input: hiddenInputBrowserCacheDirective
                    }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $animateCss: $CoreAnimateCssProvider,
                        $$animateJs: $$CoreAnimateJsProvider,
                        $$animateQueue: $$CoreAnimateQueueProvider,
                        $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                        $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $$isDocumentHidden: $$IsDocumentHiddenProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $$forceReflow: $$ForceReflowProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $$intervalFactory: $$IntervalFactoryProvider,
                        $http: $HttpProvider,
                        $httpParamSerializer: $HttpParamSerializerProvider,
                        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                        $httpBackend: $HttpBackendProvider,
                        $xhrFactory: $xhrFactoryProvider,
                        $jsonpCallbacks: $jsonpCallbacksProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $$q: $$QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                        $templateCache: $TemplateCacheProvider,
                        $templateRequest: $TemplateRequestProvider,
                        $$testability: $$TestabilityProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$jqLite: $$jqLiteProvider,
                        $$Map: $$MapProvider,
                        $$cookieReader: $$CookieReaderProvider
                    });
                } ]).info({
                    angularVersion: "1.8.2"
                });
            }(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
                function getDecimals(n) {
                    n += "";
                    var i = n.indexOf(".");
                    return -1 == i ? 0 : n.length - i - 1;
                }
                function getVF(n, opt_precision) {
                    var v = opt_precision;
                    void 0 === v && (v = Math.min(getDecimals(n), 3));
                    var base = Math.pow(10, v);
                    return {
                        v: v,
                        f: (n * base | 0) % base
                    };
                }
                var PLURAL_CATEGORY = {
                    ZERO: "zero",
                    ONE: "one",
                    TWO: "two",
                    FEW: "few",
                    MANY: "many",
                    OTHER: "other"
                };
                $provide.value("$locale", {
                    DATETIME_FORMATS: {
                        AMPMS: [ "AM", "PM" ],
                        DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                        ERANAMES: [ "Before Christ", "Anno Domini" ],
                        ERAS: [ "BC", "AD" ],
                        FIRSTDAYOFWEEK: 6,
                        MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                        SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                        STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        WEEKENDRANGE: [ 5, 6 ],
                        fullDate: "EEEE, MMMM d, y",
                        longDate: "MMMM d, y",
                        medium: "MMM d, y h:mm:ss a",
                        mediumDate: "MMM d, y",
                        mediumTime: "h:mm:ss a",
                        short: "M/d/yy h:mm a",
                        shortDate: "M/d/yy",
                        shortTime: "h:mm a"
                    },
                    NUMBER_FORMATS: {
                        CURRENCY_SYM: "$",
                        DECIMAL_SEP: ".",
                        GROUP_SEP: ",",
                        PATTERNS: [ {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 3,
                            minFrac: 0,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        }, {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 2,
                            minFrac: 2,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        } ]
                    },
                    id: "en-us",
                    localeID: "en_US",
                    pluralCat: function(n, opt_precision) {
                        var i = 0 | n, vf = getVF(n, opt_precision);
                        return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER;
                    }
                });
            } ]), jqLite(function() {
                angularInit(window.document, bootstrap);
            });
        }(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}'));
    }).call(exports, __webpack_require__(18));
}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    __webpack_require__(0);
    !function() {
        "use strict";
        var angular = window.angular ? window.angular : __webpack_require__(0), circular = angular.module("angularCircularNavigation", []).directive("circular", [ "$compile", function($compile) {
            return {
                restrict: "EA",
                scope: {
                    options: "="
                },
                template: '<button ng-click="toggleMenu()" class="cn-button {{options.button.size}}" ng-class="options.button.cssClass" ng-style="{ \'background\': ( options.button.background ? options.button.background : options.background ), \'color\': ( options.button.color ? options.button.color : options.color ) }">{{options.content}}</button><div class="cn-wrapper {{options.size}} items-{{options.items.length}}" ng-class="{\'opened-nav\': options.isOpen}"><ul><li ng-repeat="item in options.items"><a ng-hide="item.empty" ng-click="perform(options, item)" ng-class="{\'is-active\': item.isActive}" class="{{item.cssClass}}" ng-style="{ \'background\': ( item.background ? item.background : options.background ), \'color\': ( item.color ? item.color : options.color ) }"><span>{{item.content}}</span></a></li></ul></div>',
                controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                    $scope.toggleMenu = function() {
                        $scope.options.isOpen = !$scope.options.isOpen;
                    }, $scope.perform = function(options, item) {
                        "function" == typeof item.onclick && item.onclick(options, item), $scope.options.toggleOnClick && $scope.toggleMenu();
                    };
                } ]
            };
        } ]);
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0) ], __WEBPACK_AMD_DEFINE_FACTORY__ = circular,
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }();
}, function(module, exports, __webpack_require__) {
    (function(angular) {
        angular.module("ngDraggable", []).service("ngDraggable", [ function() {
            this.inputEvent = function(event) {
                return angular.isDefined(event.touches) ? event.touches[0] : angular.isDefined(event.originalEvent) && angular.isDefined(event.originalEvent.touches) ? event.originalEvent.touches[0] : event;
            };
        } ]).directive("ngDrag", [ "$rootScope", "$parse", "$document", "$window", "ngDraggable", function($rootScope, $parse, $document, $window, ngDraggable) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    scope.value = attrs.ngDrag;
                    var offset, _mx, _my, _tx, _ty, _mrx, _mry, _dragHandle, _centerAnchor = !1, _hasTouch = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, _moveEvents = "touchmove mousemove", _myid = scope.$id, _data = null, _dragOffset = null, _dragEnabled = !1, _pressTimer = null, onDragStartCallback = $parse(attrs.ngDragStart) || null, onDragStopCallback = $parse(attrs.ngDragStop) || null, onDragSuccessCallback = $parse(attrs.ngDragSuccess) || null, allowTransform = !angular.isDefined(attrs.allowTransform) || scope.$eval(attrs.allowTransform), getDragData = $parse(attrs.ngDragData), _deregisterRootMoveListener = angular.noop, toggleListeners = function(enable) {
                        enable && (scope.$on("$destroy", onDestroy), scope.$watch(attrs.ngDrag, onEnableChange),
                        scope.$watch(attrs.ngCenterAnchor, onCenterAnchor), _dragHandle ? _dragHandle.on("touchstart mousedown", onpress) : element.on("touchstart mousedown", onpress),
                        _hasTouch || "img" != element[0].nodeName.toLowerCase() || element.on("mousedown", function() {
                            return !1;
                        }));
                    }, onDestroy = function(enable) {
                        toggleListeners(!1);
                    }, onEnableChange = function(newVal, oldVal) {
                        _dragEnabled = newVal;
                    }, onCenterAnchor = function(newVal, oldVal) {
                        angular.isDefined(newVal) && (_centerAnchor = newVal || "true");
                    }, isClickableElement = function(evt) {
                        return angular.isDefined(angular.element(evt.target).attr("ng-cancel-drag"));
                    }, onpress = function(evt) {
                        _dragEnabled && (isClickableElement(evt) || "mousedown" == evt.type && 0 != evt.button || (_hasTouch ? (cancelPress(),
                        _pressTimer = setTimeout(function() {
                            cancelPress(), onlongpress(evt);
                        }, 100), $document.on(_moveEvents, cancelPress), $document.on("touchend mouseup", cancelPress)) : onlongpress(evt)));
                    }, cancelPress = function() {
                        clearTimeout(_pressTimer), $document.off(_moveEvents, cancelPress), $document.off("touchend mouseup", cancelPress);
                    }, onlongpress = function(evt) {
                        _dragEnabled && (evt.preventDefault(), offset = element[0].getBoundingClientRect(),
                        _dragOffset = allowTransform ? offset : {
                            left: document.body.scrollLeft,
                            top: document.body.scrollTop
                        }, element.centerX = element[0].offsetWidth / 2, element.centerY = element[0].offsetHeight / 2,
                        _mx = ngDraggable.inputEvent(evt).pageX, _my = ngDraggable.inputEvent(evt).pageY,
                        _mrx = _mx - offset.left, _mry = _my - offset.top, _centerAnchor ? (_tx = _mx - element.centerX - $window.pageXOffset,
                        _ty = _my - element.centerY - $window.pageYOffset) : (_tx = _mx - _mrx - $window.pageXOffset,
                        _ty = _my - _mry - $window.pageYOffset), $document.on(_moveEvents, onmove), $document.on("touchend mouseup", onrelease),
                        _deregisterRootMoveListener = $rootScope.$on("draggable:_triggerHandlerMove", function(event, origEvent) {
                            onmove(origEvent);
                        }));
                    }, onmove = function(evt) {
                        _dragEnabled && (evt.preventDefault(), element.hasClass("dragging") || (_data = getDragData(scope),
                        element.addClass("dragging"), $rootScope.$broadcast("draggable:start", {
                            x: _mx,
                            y: _my,
                            tx: _tx,
                            ty: _ty,
                            event: evt,
                            element: element,
                            data: _data
                        }), onDragStartCallback && scope.$apply(function() {
                            onDragStartCallback(scope, {
                                $data: _data,
                                $event: evt
                            });
                        })), _mx = ngDraggable.inputEvent(evt).pageX, _my = ngDraggable.inputEvent(evt).pageY,
                        _centerAnchor ? (_tx = _mx - element.centerX - _dragOffset.left, _ty = _my - element.centerY - _dragOffset.top) : (_tx = _mx - _mrx - _dragOffset.left,
                        _ty = _my - _mry - _dragOffset.top), moveElement(_tx, _ty), $rootScope.$broadcast("draggable:move", {
                            x: _mx,
                            y: _my,
                            tx: _tx,
                            ty: _ty,
                            event: evt,
                            element: element,
                            data: _data,
                            uid: _myid,
                            dragOffset: _dragOffset
                        }));
                    }, onrelease = function(evt) {
                        _dragEnabled && (evt.preventDefault(), $rootScope.$broadcast("draggable:end", {
                            x: _mx,
                            y: _my,
                            tx: _tx,
                            ty: _ty,
                            event: evt,
                            element: element,
                            data: _data,
                            callback: onDragComplete,
                            uid: _myid
                        }), element.removeClass("dragging"), element.parent().find(".drag-enter").removeClass("drag-enter"),
                        reset(), $document.off(_moveEvents, onmove), $document.off("touchend mouseup", onrelease),
                        onDragStopCallback && scope.$apply(function() {
                            onDragStopCallback(scope, {
                                $data: _data,
                                $event: evt
                            });
                        }), _deregisterRootMoveListener());
                    }, onDragComplete = function(evt) {
                        onDragSuccessCallback && scope.$apply(function() {
                            onDragSuccessCallback(scope, {
                                $data: _data,
                                $event: evt
                            });
                        });
                    }, reset = function() {
                        allowTransform ? element.css({
                            transform: "",
                            "z-index": "",
                            "-webkit-transform": "",
                            "-ms-transform": ""
                        }) : element.css({
                            position: "",
                            top: "",
                            left: ""
                        });
                    }, moveElement = function(x, y) {
                        allowTransform ? element.css({
                            transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + x + ", " + y + ", 0, 1)",
                            "z-index": 99999,
                            "-webkit-transform": "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + x + ", " + y + ", 0, 1)",
                            "-ms-transform": "matrix(1, 0, 0, 1, " + x + ", " + y + ")"
                        }) : element.css({
                            left: x + "px",
                            top: y + "px",
                            position: "fixed"
                        });
                    };
                    !function() {
                        if (element.attr("draggable", "false"), element[0].querySelectorAll) var dragHandles = angular.element(element[0].querySelectorAll("[ng-drag-handle]")); else var dragHandles = element.find("[ng-drag-handle]");
                        dragHandles.length && (_dragHandle = dragHandles), toggleListeners(!0);
                    }();
                }
            };
        } ]).directive("ngDrop", [ "$parse", "$timeout", "$window", "$document", "ngDraggable", function($parse, $timeout, $window, $document, ngDraggable) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    scope.value = attrs.ngDrop, scope.isTouching = !1;
                    var _lastDropTouch = null, _myid = scope.$id, _dropEnabled = !1, onDropCallback = $parse(attrs.ngDropSuccess), onDragStartCallback = $parse(attrs.ngDragStart), onDragStopCallback = $parse(attrs.ngDragStop), onDragMoveCallback = $parse(attrs.ngDragMove), toggleListeners = function(enable) {
                        enable && (scope.$watch(attrs.ngDrop, onEnableChange), scope.$on("$destroy", onDestroy),
                        scope.$on("draggable:start", onDragStart), scope.$on("draggable:move", onDragMove),
                        scope.$on("draggable:end", onDragEnd));
                    }, onDestroy = function(enable) {
                        toggleListeners(!1);
                    }, onEnableChange = function(newVal, oldVal) {
                        _dropEnabled = newVal;
                    }, onDragStart = function(evt, obj) {
                        _dropEnabled && (isTouching(obj.x, obj.y, obj.element), attrs.ngDragStart && $timeout(function() {
                            onDragStartCallback(scope, {
                                $data: obj.data,
                                $event: obj
                            });
                        }));
                    }, onDragMove = function(evt, obj) {
                        _dropEnabled && (isTouching(obj.x, obj.y, obj.element), attrs.ngDragMove && $timeout(function() {
                            onDragMoveCallback(scope, {
                                $data: obj.data,
                                $event: obj
                            });
                        }));
                    }, onDragEnd = function(evt, obj) {
                        if (!_dropEnabled || _myid === obj.uid) return void updateDragStyles(!1, obj.element);
                        isTouching(obj.x, obj.y, obj.element) && (obj.callback && obj.callback(obj), attrs.ngDropSuccess && $timeout(function() {
                            onDropCallback(scope, {
                                $data: obj.data,
                                $event: obj,
                                $target: scope.$eval(scope.value)
                            });
                        })), attrs.ngDragStop && $timeout(function() {
                            onDragStopCallback(scope, {
                                $data: obj.data,
                                $event: obj
                            });
                        }), updateDragStyles(!1, obj.element);
                    }, isTouching = function(mouseX, mouseY, dragElement) {
                        var touching = hitTest(mouseX, mouseY);
                        return scope.isTouching = touching, touching && (_lastDropTouch = element), updateDragStyles(touching, dragElement),
                        touching;
                    }, updateDragStyles = function(touching, dragElement) {
                        touching ? (element.addClass("drag-enter"), dragElement.addClass("drag-over")) : _lastDropTouch == element && (_lastDropTouch = null,
                        element.removeClass("drag-enter"), dragElement.removeClass("drag-over"));
                    }, hitTest = function(x, y) {
                        var bounds = element[0].getBoundingClientRect();
                        return x -= $document[0].body.scrollLeft + $document[0].documentElement.scrollLeft,
                        y -= $document[0].body.scrollTop + $document[0].documentElement.scrollTop, x >= bounds.left && x <= bounds.right && y <= bounds.bottom && y >= bounds.top;
                    };
                    !function() {
                        toggleListeners(!0);
                    }();
                }
            };
        } ]).directive("ngDragClone", [ "$parse", "$timeout", "ngDraggable", function($parse, $timeout, ngDraggable) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    var img, _allowClone = !0;
                    scope.clonedData = {};
                    var toggleListeners = function(enable) {
                        enable && (scope.$on("draggable:start", onDragStart), scope.$on("draggable:move", onDragMove),
                        scope.$on("draggable:end", onDragEnd), preventContextMenu());
                    }, preventContextMenu = function() {
                        img.off("mousedown touchstart touchmove touchend touchcancel", absorbEvent_), img.on("mousedown touchstart touchmove touchend touchcancel", absorbEvent_);
                    }, onDragStart = function(evt, obj, elm) {
                        _allowClone = !0, angular.isDefined(obj.data.allowClone) && (_allowClone = obj.data.allowClone),
                        _allowClone && (scope.$apply(function() {
                            scope.clonedData = obj.data;
                        }), element.css("width", obj.element[0].offsetWidth), element.css("height", obj.element[0].offsetHeight),
                        moveElement(obj.tx, obj.ty));
                    }, onDragMove = function(evt, obj) {
                        _allowClone && (_tx = obj.tx + obj.dragOffset.left, _ty = obj.ty + obj.dragOffset.top,
                        moveElement(_tx, _ty));
                    }, onDragEnd = function(evt, obj) {
                        _allowClone && reset();
                    }, reset = function() {
                        element.css({
                            left: 0,
                            top: 0,
                            position: "fixed",
                            "z-index": -1,
                            visibility: "hidden"
                        });
                    }, moveElement = function(x, y) {
                        element.css({
                            transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + x + ", " + y + ", 0, 1)",
                            "z-index": 99999,
                            visibility: "visible",
                            "-webkit-transform": "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + x + ", " + y + ", 0, 1)",
                            "-ms-transform": "matrix(1, 0, 0, 1, " + x + ", " + y + ")"
                        });
                    }, absorbEvent_ = function(event) {
                        var e = event;
                        return e.preventDefault && e.preventDefault(), e.stopPropagation && e.stopPropagation(),
                        e.cancelBubble = !0, e.returnValue = !1, !1;
                    };
                    !function() {
                        img = element.find("img"), element.attr("draggable", "false"), img.attr("draggable", "false"),
                        reset(), toggleListeners(!0);
                    }();
                }
            };
        } ]).directive("ngPreventDrag", [ "$parse", "$timeout", function($parse, $timeout) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    var toggleListeners = function(enable) {
                        enable && element.on("mousedown touchstart touchmove touchend touchcancel", absorbEvent_);
                    }, absorbEvent_ = function(event) {
                        var e = event.originalEvent;
                        return e.preventDefault && e.preventDefault(), e.stopPropagation && e.stopPropagation(),
                        e.cancelBubble = !0, e.returnValue = !1, !1;
                    };
                    !function() {
                        element.attr("draggable", "false"), toggleListeners(!0);
                    }();
                }
            };
        } ]).directive("ngCancelDrag", [ function() {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    element.find("*").attr("ng-cancel-drag", "ng-cancel-drag");
                }
            };
        } ]).directive("ngDragScroll", [ "$window", "$interval", "$timeout", "$document", "$rootScope", function($window, $interval, $timeout, $document, $rootScope) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    var lastMouseEvent = null, config = {
                        verticalScroll: attrs.verticalScroll || !0,
                        horizontalScroll: attrs.horizontalScroll || !0,
                        activationDistance: attrs.activationDistance || 75,
                        scrollDistance: attrs.scrollDistance || 15
                    }, reqAnimFrame = function() {
                        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
                            window.setTimeout(callback, 1e3 / 60);
                        };
                    }(), animationIsOn = !1, createInterval = function() {
                        function nextFrame(callback) {
                            var args = Array.prototype.slice.call(arguments);
                            animationIsOn && reqAnimFrame(function() {
                                $rootScope.$apply(function() {
                                    callback.apply(null, args), nextFrame(callback);
                                });
                            });
                        }
                        animationIsOn = !0, nextFrame(function() {
                            if (lastMouseEvent) {
                                var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0), viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0), scrollX = 0, scrollY = 0;
                                if (config.horizontalScroll && (lastMouseEvent.clientX < config.activationDistance ? scrollX = -config.scrollDistance : lastMouseEvent.clientX > viewportWidth - config.activationDistance && (scrollX = config.scrollDistance)),
                                config.verticalScroll && (lastMouseEvent.clientY < config.activationDistance ? scrollY = -config.scrollDistance : lastMouseEvent.clientY > viewportHeight - config.activationDistance && (scrollY = config.scrollDistance)),
                                0 !== scrollX || 0 !== scrollY) {
                                    var currentScrollLeft = $window.pageXOffset || $document[0].documentElement.scrollLeft, currentScrollTop = $window.pageYOffset || $document[0].documentElement.scrollTop, elementTransform = element.css("transform");
                                    element.css("transform", "initial"), $window.scrollBy(scrollX, scrollY);
                                    var horizontalScrollAmount = ($window.pageXOffset || $document[0].documentElement.scrollLeft) - currentScrollLeft, verticalScrollAmount = ($window.pageYOffset || $document[0].documentElement.scrollTop) - currentScrollTop;
                                    element.css("transform", elementTransform), lastMouseEvent.pageX += horizontalScrollAmount,
                                    lastMouseEvent.pageY += verticalScrollAmount, $rootScope.$emit("draggable:_triggerHandlerMove", lastMouseEvent);
                                }
                            }
                        });
                    }, clearInterval = function() {
                        animationIsOn = !1;
                    };
                    scope.$on("draggable:start", function(event, obj) {
                        obj.element[0] === element[0] && (animationIsOn || createInterval());
                    }), scope.$on("draggable:end", function(event, obj) {
                        obj.element[0] === element[0] && animationIsOn && clearInterval();
                    }), scope.$on("draggable:move", function(event, obj) {
                        obj.element[0] === element[0] && (lastMouseEvent = obj.event);
                    });
                }
            };
        } ]);
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    var jQuery = __webpack_require__(18);
    +function($) {
        "use strict";
        function Plugin(option) {
            return this.each(function() {
                var $this = $(this), data = $this.data("bs.tab");
                data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]();
            });
        }
        var Tab = function(element) {
            this.element = $(element);
        };
        Tab.VERSION = "3.4.1", Tab.TRANSITION_DURATION = 150, Tab.prototype.show = function() {
            var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.data("target");
            if (selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")),
            !$this.parent("li").hasClass("active")) {
                var $previous = $ul.find(".active:last a"), hideEvent = $.Event("hide.bs.tab", {
                    relatedTarget: $this[0]
                }), showEvent = $.Event("show.bs.tab", {
                    relatedTarget: $previous[0]
                });
                if ($previous.trigger(hideEvent), $this.trigger(showEvent), !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                    var $target = $(document).find(selector);
                    this.activate($this.closest("li"), $ul), this.activate($target, $target.parent(), function() {
                        $previous.trigger({
                            type: "hidden.bs.tab",
                            relatedTarget: $this[0]
                        }), $this.trigger({
                            type: "shown.bs.tab",
                            relatedTarget: $previous[0]
                        });
                    });
                }
            }
        }, Tab.prototype.activate = function(element, container, callback) {
            function next() {
                $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1),
                element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0),
                transition ? (element[0].offsetWidth, element.addClass("in")) : element.removeClass("fade"),
                element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0),
                callback && callback();
            }
            var $active = container.find("> .active"), transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
            $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(),
            $active.removeClass("in");
        };
        var old = $.fn.tab;
        $.fn.tab = Plugin, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function() {
            return $.fn.tab = old, this;
        };
        var clickHandler = function(e) {
            e.preventDefault(), Plugin.call($(this), "show");
        };
        $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
    }(jQuery);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp", [ "angularCircularNavigation", "ngDraggable" ]).filter("makeNice", function() {
            return function(item) {
                return item = item.charAt(0).toUpperCase() + item.slice(1), item.replace(/_/g, " ");
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    (function(angular) {
        angular.module("EdGuiApp").controller("ActionsCtrl", function($scope, $timeout, robot) {
            var triggerTopic = robot.ros.Topic({
                name: "trigger",
                messageType: "std_msgs/String"
            });
            $scope.trigger = function(name) {
                console.log("trigger:", name), triggerTopic.publish({
                    data: name
                });
            }, $scope.cancel = function() {
                console.log("Cancelling all actions"), robot.actionServer.cancelAllActions();
            }, $scope.present = function(language) {
                if (console.log("Starting presentation in", language), "en" != language && "nl" != language) return void console.error('Language should be "en" or "nl", now it is', language);
                var recipe = {
                    actions: [ {
                        action: "demo-presentation",
                        language: language
                    } ]
                };
                robot.actionServer.doAction(recipe);
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("CircularmenuCtrl", function($scope, robot) {
            $scope.actionList = [ {
                name: "inspect",
                entityDescription: "entity",
                icon: "camera",
                color: "red"
            }, {
                name: "pick-up",
                entityDescription: "object",
                icon: "hand-grab-o",
                color: "blue"
            }, {
                name: "navigate-to",
                entityDescription: "object",
                icon: "arrows-alt",
                color: "green"
            }, {
                name: "place",
                entityDescription: "object",
                icon: "hand-lizard-o",
                color: "red"
            } ], $scope.options = {
                items: []
            }, $scope.$watch("selectedEntityEvent", function(entityEvent) {
                var menuElement = document.getElementById("action-menu");
                if (!entityEvent.entity) return $scope.options.isOpen = !1, menuElement.style.opacity = 0,
                void (menuElement.style.zIndex = -1);
                menuElement.style.left = entityEvent.event.pageX + "px", menuElement.style.top = entityEvent.event.pageY + "px",
                menuElement.style.opacity = 1, menuElement.style.zIndex = 1, $scope.options.content = entityEvent.entity.id,
                $scope.options.items = $scope.actionList.map(function(action) {
                    return {
                        cssClass: "fa fa-" + action.icon,
                        background: action.color,
                        onclick: function(event) {
                            var recipe = {
                                actions: [ {
                                    action: action.name
                                } ]
                            };
                            recipe.actions[0][action.entityDescription] = {
                                id: entityEvent.entity.id
                            }, robot.actionServer.doAction(recipe), $scope.entitySelection({
                                event: event,
                                entity: null
                            });
                        }
                    };
                }), $scope.options.isOpen = !0;
            });
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("ConnectionCtrl", function($scope, robot) {
            $scope.connection = robot.status, robot.on("status", function(status) {
                $scope.$apply(function() {
                    $scope.connection = status;
                });
            });
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("EdCtrl", function($scope, $timeout, robot) {
            $scope.reset = function() {
                console.log("Reset ED"), robot.ed.reset(!0);
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("JointCtrl", function($scope, $timeout, robot) {
            $scope.sendJointCommand = function(cmd) {
                console.log("Joint command: ", cmd), robot.body.jointNames.leftArm = [ "arm_lift_joint", "arm_flex_joint", "arm_roll_joint", "wrist_flex_joint", "wrist_roll_joint" ],
                robot.body.jointNames.rightArm = [ "arm_lift_joint", "arm_flex_joint", "arm_roll_joint", "wrist_flex_joint", "wrist_roll_joint" ],
                robot.body.sendGoal(cmd);
            }, $scope.sendGripperCommand = function(cmd) {
                console.log("Gripper command: ", cmd), robot.body.sendGripperGoal(cmd);
            }, $scope.loadConfiguration = function() {
                $scope.joint_names = robot.body.jointNames, $scope.default_configurations = robot.body.defaultConfigurations;
            }, $scope.joint_names = robot.body.jointNames, $scope.default_configurations = robot.body.defaultConfigurations;
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("MainCtrl", function($scope, $interval, robot) {
            function updateEd() {
                setTimeout(function() {
                    robot.ed.query(updateEd);
                }, 100);
            }
            $scope.entitySelection = function(entityEvent) {
                $scope.selectedEntityEvent = entityEvent;
            }, robot.ed.query(updateEd);
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("ModellistCtrl", function($scope, robot) {
            $scope.models = robot.ed.models;
            var resolution = Number.parseInt(location.search.substr(1, location.search.length)) || 640;
            console.log("setting the resolution to", resolution, "pixels"), robot.ed.on("models", function(models) {
                function update(time_diff) {
                    _.delay(function() {
                        robot.head.getImage(resolution, function(url, _, time_diff) {
                            $scope.$apply(function() {
                                url && ($scope.camera_src = url), update(time_diff);
                            });
                        });
                    }, 2 * time_diff);
                }
                $scope.$apply(function() {
                    $scope.models = _.mapValues(models, function(v, k) {
                        return v.name = _.last(_.words(k, /\w+/g)).replace("_", " "), v;
                    });
                }), $scope.camera_src = null, update(200);
            });
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("SidebarCtrl", function($scope, $timeout, robot) {});
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("SnapshotlistCtrl", function(robot, $scope) {
            function getViewSize(div) {
                var width_pixels, height_pixels;
                if ("contain" === $scope.backgroundSize) {
                    div.offsetWidth / div.offsetHeight > 640 / 480 ? (height_pixels = div.offsetHeight,
                    width_pixels = 640 / 480 * div.offsetHeight) : (width_pixels = div.offsetWidth,
                    height_pixels = div.offsetWidth / (640 / 480));
                } else height_pixels = div.offsetHeight, width_pixels = .71 * div.offsetWidth;
                return {
                    height: height_pixels,
                    width: width_pixels
                };
            }
            $scope.isUndoing = !1, $scope.undo = function() {
                $scope.isUndoing = !0, robot.ed.undo_fit_model(function() {
                    _.delay(function() {
                        $scope.$apply(function() {
                            $scope.isUndoing = !1;
                        });
                    }, 1e3);
                });
            }, $scope.backgroundSize = "71% 100%", $scope.isAskingGPSR = !1, $scope.gpsr = function() {
                $scope.isAskingGPSR = !0, _.delay(function() {
                    $scope.$apply(function() {
                        $scope.isAskingGPSR = !1;
                    });
                }, 1e3);
            }, $scope.send_twist = function(vx, vy, vth) {
                robot.base.sendTwist(vx, vy, vth);
            }, $scope.camera_click = function(e) {
                var x = e.offsetX, y = e.offsetY, div = e.target, size = getViewSize(div), width_pixels = size.width, height_pixels = size.height;
                y -= div.offsetTop;
                var x_ratio = x / width_pixels, y_ratio = y / height_pixels;
                console.log("x_ratio and y_ratio in bg: " + (100 * x_ratio).toFixed(1) + "% x " + (100 * y_ratio).toFixed(1) + "%"),
                robot.ed.fit_model("NAVIGATE", x_ratio, y_ratio);
            }, robot.head.on("update_time", function(t) {
                $scope.$apply(function() {
                    $scope.update_time = t;
                });
            }), $scope.onDropComplete = function(data, e) {
                var div = e.element.parent()[0].parentElement, size = getViewSize(div), width_pixels = size.width, height_pixels = size.height, x = e.x, y = e.y - div.offsetTop, x_ratio = x / width_pixels, y_ratio = y / height_pixels;
                if (console.log("x_ratio and y_ratio in bg: " + (100 * x_ratio).toFixed(1) + "% x " + (100 * y_ratio).toFixed(1) + "%"),
                x_ratio > 1 || y_ratio > 1) return void console.log("skipping click");
                console.log("Fit model!", data, x_ratio, y_ratio), robot.ed.fit_model(data, x_ratio, y_ratio);
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("SpeechCtrl", function($scope, $timeout, robot) {
            $scope.speech_history = [], $scope.sentence = "", $scope.speak = function(sentence) {
                console.log("Speak command: ", sentence), robot.speech.speak({
                    sentence: sentence
                }), $scope.sentence = "", $scope.speech_history.unshift(sentence);
                var unique = [];
                $scope.speech_history.filter(function(text) {
                    -1 === unique.indexOf(text) && unique.push(text);
                }), $scope.speech_history = unique;
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").controller("TeleopCtrl", function($scope, $timeout, robot) {
            $scope.teleopBase = function(teleopEvent) {
                robot.base.sendTwist(teleopEvent.py, 0, -teleopEvent.px);
            }, $scope.teleopHead = function(teleopEvent) {
                if (0 == teleopEvent.px && 0 == teleopEvent.py) robot.head.cancelGoal(); else {
                    robot.head.sendPanTiltGoal(-1.5 * teleopEvent.px, -1.5 * teleopEvent.py);
                }
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").directive("tueBatteryStatus", function() {
            return {
                restrict: "E",
                transclude: !0,
                templateUrl: "/battery.html",
                controller: function($scope, robot) {
                    $scope.batteries = {};
                    robot.ros.Topic({
                        name: "battery",
                        messageType: "sensor_msgs/BatteryState"
                    }).subscribe(function(msg) {
                        var value = parseInt(100 * msg.percentage), type = "info";
                        type = value > 40 ? "success" : value > 20 ? "warning" : "danger", $scope.batteries[msg.location] = {
                            value: value,
                            type: type
                        };
                        var ordered = {};
                        Object.keys($scope.batteries).sort().forEach(function(key) {
                            ordered[key] = $scope.batteries[key];
                        }), $scope.batteries = ordered, $scope.$digest();
                    });
                }
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").directive("tueEbuttons", function() {
            return {
                restrict: "E",
                transclude: !0,
                templateUrl: "/ebutton.html",
                controller: function($scope, $attrs, robot) {
                    function setEbuttons(ebuttons) {
                        angular.equals(oldEbuttons, ebuttons) || (oldEbuttons = ebuttons, $scope.$apply(function() {
                            $scope.ebuttons = ebuttons;
                        }));
                    }
                    function ebuttonToScope(value) {
                        return [ {
                            name: "ebuttonToScope",
                            color: levelToClass(value ? 1 : 0),
                            icon: "glyphicon glyphicon-ban-circle"
                        } ];
                    }
                    function levelToClass(level) {
                        return levelColorMap[level] ? "btn-" + levelColorMap[level] : "";
                    }
                    var levelColorMap = {
                        0: "success",
                        1: "danger",
                        2: "warning",
                        3: "default"
                    }, DEFAULT_STATE = [ {
                        icon: "glyphicon glyphicon-question-sign",
                        class: levelColorMap[3]
                    } ];
                    $scope.ebuttons = DEFAULT_STATE;
                    var oldEbuttons;
                    robot.ros.Topic({
                        name: "runstop_button",
                        messageType: "std_msgs/Bool"
                    }).subscribe(function(msg) {
                        setEbuttons(ebuttonToScope(msg.data));
                    });
                }
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular) {
        angular.module("EdGuiApp").directive("ngTeleopCanvas", function() {
            return {
                restrict: "E",
                template: "<canvas></canvas>",
                scope: {
                    percentageChanged: "&onPercentageChanged"
                },
                controllerAs: "vm",
                controller: function() {},
                link: function(scope, element) {
                    function resizeCanvas() {
                        canvas.width = parent.width(), canvas.height = parent.height();
                    }
                    function start(x, y) {
                        startPos = {
                            x: x,
                            y: y
                        }, publishing = !0, update();
                    }
                    function move(x, y) {
                        startPos && (currentPos = {
                            x: x,
                            y: y
                        }, update());
                    }
                    function end() {
                        startPos = !1, currentPos = !1, publishing = !1, update(), scope.percentageChanged({
                            px: 0,
                            py: 0
                        });
                    }
                    function update() {
                        clearCanvas(), draw(startPos, currentPos);
                    }
                    function clearCanvas() {
                        ctx.fillStyle = "#4D4D4D", ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    function draw(pos, thumbPos) {
                        var r, radgrad;
                        pos && (ctx.save(), ctx.translate(pos.x, pos.y), r = 60, radgrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 2 * r),
                        radgrad.addColorStop(0, "rgba(0,0,0,0)"), radgrad.addColorStop(.4, "rgba(0,0,0,0)"),
                        radgrad.addColorStop(.45, "rgba(0,0,0,1)"), radgrad.addColorStop(.55, "rgba(0,0,0,1)"),
                        radgrad.addColorStop(.6, "rgba(0,0,0,0)"), radgrad.addColorStop(1, "rgba(0,0,0,0)"),
                        ctx.fillStyle = radgrad, ctx.fillRect(-2 * r, -2 * r, 4 * r, 4 * r), ctx.restore()),
                        thumbPos && (ctx.save(), ctx.translate(thumbPos.x, thumbPos.y), r = 45, radgrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r),
                        radgrad.addColorStop(0, "rgba(0,0,0,1)"), radgrad.addColorStop(.9, "rgba(0,0,0,1)"),
                        radgrad.addColorStop(1, "rgba(0,0,0,0)"), ctx.fillStyle = radgrad, ctx.fillRect(-r, -r, 2 * r, 2 * r),
                        ctx.restore());
                    }
                    element.on("$destroy", function() {
                        console.log("ngTeleopCanvas: element is destroyed");
                    }), scope.$on("$destroy", function() {
                        console.log("ngTeleopCanvas: scope is destroyed");
                    });
                    var canvas = element.children()[0], ctx = canvas.getContext("2d"), parent = element.parent();
                    resizeCanvas(), window.addEventListener("resize", resizeCanvas, !1);
                    var startPos, currentPos, publishing = !1;
                    setInterval(function() {
                        if (publishing) {
                            if (!currentPos || !startPos) return;
                            var dx = currentPos.x - startPos.x, dy = currentPos.y - startPos.y, py = -dy / canvas.height, px = dx / canvas.width;
                            scope.percentageChanged({
                                px: px,
                                py: py
                            });
                        }
                    }, 100), element.on("mousedown", function(e) {
                        start(e.offsetX, e.offsetY);
                    }), element.on("touchstart", function(e) {
                        e.preventDefault();
                        var rect = parent[0].getBoundingClientRect();
                        start(e.touches[0].pageX - rect.left, e.touches[0].pageY - rect.top);
                    }), element.on("mousemove", function(e) {
                        move(e.offsetX, e.offsetY);
                    }), element.on("touchmove", function(e) {
                        e.preventDefault();
                        var rect = parent[0].getBoundingClientRect();
                        move(e.touches[0].pageX - rect.left, e.touches[0].pageY - rect.top);
                    }), element.on("mouseup", function(e) {
                        end();
                    }), element.on("mouseleave", function(e) {
                        end();
                    }), element.on("touchend", function(e) {
                        end();
                    });
                }
            };
        });
    }).call(exports, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(angular) {
        var __WEBPACK_IMPORTED_MODULE_0__scenerenderer__ = __webpack_require__(66);
        angular.module("EdGuiApp").directive("ngWebgl", function(robot) {
            return {
                restrict: "E",
                template: "<canvas></canvas>",
                scope: {
                    entitySelection: "&onEntitySelection"
                },
                controllerAs: "vm",
                controller: function() {},
                link: function(scope, element) {
                    function entitySelection(e) {
                        console.log(e);
                        var x = e.clientX / canvas.innerWidth() * 2 - 1, y = -e.clientY / canvas.innerHeight() * 2 + 1, obj = renderer.pickingRay(x, y);
                        obj && scope.entitySelection({
                            entity: obj,
                            event: e
                        });
                    }
                    function resizeCanvas() {
                        renderer.setSize(parent.innerWidth(), parent.innerHeight());
                    }
                    window.addEventListener("onlongpress", function(e) {
                        entitySelection(e.detail);
                    }, !1), element.on("touchstart", function(e) {
                        e.preventDefault(), scope.entitySelection({
                            entity: null,
                            event: e
                        });
                    }), element.on("$destroy", function() {
                        console.log("ngWebgl: element is destroyed");
                    }), scope.$on("$destroy", function() {
                        console.log("ngWebgl: scope is destroyed");
                    });
                    var canvas = element.children(), parent = element.parent(), renderer = new __WEBPACK_IMPORTED_MODULE_0__scenerenderer__.a({
                        canvas: canvas.get(0),
                        robot: robot
                    });
                    renderer.init(), resizeCanvas(), window.addEventListener("resize", resizeCanvas, !1),
                    renderer.start(), element.on("dblclick", function(e) {
                        e.preventDefault(), entitySelection(e);
                    }), element.on("mousedown", function(e) {
                        e.preventDefault(), scope.entitySelection({
                            entity: null,
                            event: e
                        });
                    });
                }
            };
        });
    }).call(__webpack_exports__, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var __WEBPACK_IMPORTED_MODULE_0_three__ = __webpack_require__(19);
    const SceneRenderer = function(THREE) {
        function SceneRenderer(options) {
            if (!options || !options.canvas || !options.robot) throw new Error("Unspecified canvas or robot");
            this.canvas = options.canvas, this.robot = options.robot, window.SceneRenderer = this;
        }
        function stringToColor(str) {
            for (var i = 0, hash = 5381; i < str.length; hash = (hash << 5) + hash + str.charCodeAt(i++)) ;
            return hash < 0 && (hash = -hash), i = hash % COLORS.length, COLORS[i];
        }
        function convertVertices(vertices, threeVertices) {
            for (var i = 0; i < vertices.length; i++) threeVertices.push(new THREE.Vector3().fromArray(vertices[i]));
        }
        function convertFaces(faces, threeFaces) {
            for (var j = 0; j < faces.length; j++) {
                var face = faces[j];
                threeFaces.push(new THREE.Face3(face[0], face[1], face[2]));
            }
        }
        SceneRenderer.prototype.init = function() {
            var contW = this.canvas.offsetWidth, contH = this.canvas.offsetHeight;
            this.camera = new THREE.PerspectiveCamera(75, contW / contH, .1, 1e3), this.raycaster = new THREE.Raycaster(),
            this.camera.position.x = 0, this.camera.position.y = -3, this.camera.position.z = 3,
            this.camera.up = new THREE.Vector3(0, 0, 1);
            var scene = this.scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(4210752));
            var light = new THREE.DirectionalLight(16777215);
            light.position.set(3, 12, 8), scene.add(light);
            var renderer;
            renderer = function() {
                try {
                    var canvas = document.createElement("canvas");
                    return !(!window.WebGLRenderingContext || !canvas.getContext("webgl") && !canvas.getContext("experimental-webgl"));
                } catch (e) {
                    return !1;
                }
            }() ? new THREE.WebGLRenderer({
                canvas: this.canvas,
                antialias: !0
            }) : new THREE.CanvasRenderer({
                canvas: this.canvas
            }), this.renderer = renderer, renderer.setClearColor(15790320);
            var cameraControls = new THREE.OrbitControls(this.camera, renderer.domElement);
            cameraControls.enableDamping = !0, cameraControls.dampingFactor = .25, cameraControls.enableZoom = !0,
            cameraControls.rotateSpeed = .1, window.addEventListener("resize", this.onWindowResize, !1);
        }, SceneRenderer.prototype.setSize = function(width, height) {
            this.camera.aspect = width / height, this.camera.updateProjectionMatrix(), this.renderer.setSize(width, height);
        }, SceneRenderer.prototype.pickingRay = function(x, y) {
            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
            var intersects = this.raycaster.intersectObjects(this.scene.children);
            return 0 === intersects.length ? null : intersects[0].object.userData;
        }, SceneRenderer.prototype.start = function() {
            function render() {
                self._token = requestAnimationFrame(render), self.renderer.render(scene, self.camera);
            }
            for (var self = this, scene = this.scene, robot = this.robot, texture = new THREE.Texture(), geometry = new THREE.Geometry(), i = 0; i < 307200; i++) {
                var position = new THREE.Vector3();
                position.x = i % 640, position.y = Math.floor(i / 640), geometry.vertices.push(new THREE.Vector3(position));
            }
            var material = new THREE.ShaderMaterial({
                uniforms: {
                    map: {
                        type: "t",
                        value: 0,
                        texture: texture
                    },
                    width: {
                        type: "f",
                        value: 640
                    },
                    height: {
                        type: "f",
                        value: 480
                    },
                    nearClipping: {
                        type: "f",
                        value: 850
                    },
                    farClipping: {
                        type: "f",
                        value: 4e3
                    }
                },
                vertexShader: document.getElementById("vs").textContent,
                fragmentShader: document.getElementById("fs").textContent,
                depthWrite: !1
            }), mesh = new THREE.Points(geometry, material);
            mesh.position.x = 0, mesh.position.y = 0, mesh.position.z = 10, scene.add(mesh),
            robot.ed.watch({
                add: function(obj) {
                    var geometry = new THREE.Geometry();
                    convertVertices(obj.vertices, geometry.vertices), convertFaces(obj.faces, geometry.faces),
                    geometry.computeFaceNormals(), geometry.computeVertexNormals(!0);
                    var material = new THREE.MeshPhongMaterial({
                        color: stringToColor(obj.id),
                        shading: THREE.FlatShading,
                        shininess: 0,
                        emissive: 131586
                    }), mesh = new THREE.Mesh(geometry, material);
                    mesh.position.fromArray(obj.position), mesh.quaternion.fromArray(obj.quaternion),
                    scene.add(mesh), obj.userdata = mesh, mesh.userData = obj;
                },
                update: function(newObj, oldObj) {
                    var mesh = newObj.userdata = oldObj.userdata;
                    mesh.userData = newObj;
                    var geometry = mesh.geometry;
                    newObj.position !== oldObj.position && mesh.position.fromArray(newObj.position),
                    newObj.quaternion !== oldObj.quaternion && mesh.quaternion.fromArray(newObj.quaternion);
                    var vupdate = newObj.vertices !== oldObj.vertices, fupdate = newObj.faces !== oldObj.faces;
                    vupdate && (geometry.vertices = [], convertVertices(newObj.vertices, geometry.vertices)),
                    fupdate && (geometry.faces = [], convertFaces(newObj.faces, geometry.faces)), (vupdate || fupdate) && (geometry.computeFaceNormals(),
                    geometry.computeVertexNormals(!0), geometry.verticesNeedUpdate = !0, geometry.elementsNeedUpdate = !0,
                    geometry.normalsNeedUpdate = !0);
                },
                remove: function(obj) {
                    console.log("remove", obj);
                    var mesh = obj.userdata;
                    scene.remove(mesh);
                }
            }), self._token = null, render();
        }, SceneRenderer.prototype.stop = function() {
            cancelAnimationFrame(this._token);
        };
        var COLORS = [ 10066329, 10066278, 10066227, 10053273, 10053222, 10053171, 10040217, 10040166, 10040115, 6723993, 6723942, 6723891, 6710937, 6710886, 6710835, 6697881, 6697830, 6697779, 3381657, 3381606, 3381555, 3368601, 3368550, 3368499, 3355545, 3355494, 3355443 ];
        return SceneRenderer;
    }(__WEBPACK_IMPORTED_MODULE_0_three__);
    __webpack_exports__.a = SceneRenderer;
}, function(module, exports, __webpack_require__) {
    (function(THREE) {
        !function() {
            function OrbitConstraint(object) {
                this.object = object, this.target = new THREE.Vector3(), this.minDistance = 0, this.maxDistance = 1 / 0,
                this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI,
                this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1,
                this.dampingFactor = .25;
                var theta, phi, scope = this, phiDelta = 0, thetaDelta = 0, scale = 1, panOffset = new THREE.Vector3(), zoomChanged = !1;
                this.getPolarAngle = function() {
                    return phi;
                }, this.getAzimuthalAngle = function() {
                    return theta;
                }, this.rotateLeft = function(angle) {
                    thetaDelta -= angle;
                }, this.rotateUp = function(angle) {
                    phiDelta -= angle;
                }, this.panLeft = function() {
                    var v = new THREE.Vector3();
                    return function(distance) {
                        var te = this.object.matrix.elements;
                        v.set(te[0], te[1], te[2]), v.multiplyScalar(-distance), panOffset.add(v);
                    };
                }(), this.panUp = function() {
                    var v = new THREE.Vector3();
                    return function(distance) {
                        var te = this.object.matrix.elements;
                        v.set(te[4], te[5], te[6]), v.multiplyScalar(distance), panOffset.add(v);
                    };
                }(), this.pan = function(deltaX, deltaY, screenWidth, screenHeight) {
                    if (scope.object instanceof THREE.PerspectiveCamera) {
                        var position = scope.object.position, offset = position.clone().sub(scope.target), targetDistance = offset.length();
                        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180), scope.panLeft(2 * deltaX * targetDistance / screenHeight),
                        scope.panUp(2 * deltaY * targetDistance / screenHeight);
                    } else scope.object instanceof THREE.OrthographicCamera ? (scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth),
                    scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
                }, this.dollyIn = function(dollyScale) {
                    scope.object instanceof THREE.PerspectiveCamera ? scale /= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale)),
                    scope.object.updateProjectionMatrix(), zoomChanged = !0) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                }, this.dollyOut = function(dollyScale) {
                    scope.object instanceof THREE.PerspectiveCamera ? scale *= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale)),
                    scope.object.updateProjectionMatrix(), zoomChanged = !0) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                }, this.update = function() {
                    var offset = new THREE.Vector3(), quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 0, 1)), quatInverse = quat.clone().inverse(), lastPosition = new THREE.Vector3(), lastQuaternion = new THREE.Quaternion();
                    return function() {
                        var position = this.object.position;
                        offset.copy(position).sub(this.target), offset.applyQuaternion(quat), theta = Math.atan2(offset.x, offset.y),
                        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z),
                        theta += thetaDelta, phi += phiDelta, theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta)),
                        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi)), phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, phi));
                        var radius = offset.length() * scale;
                        return radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius)),
                        this.target.add(panOffset), offset.x = radius * Math.sin(phi) * Math.sin(theta),
                        offset.z = radius * Math.cos(phi), offset.y = radius * Math.sin(phi) * Math.cos(theta),
                        offset.applyQuaternion(quatInverse), position.copy(this.target).add(offset), this.object.lookAt(this.target),
                        !0 === this.enableDamping ? (thetaDelta *= 1 - this.dampingFactor, phiDelta *= 1 - this.dampingFactor) : (thetaDelta = 0,
                        phiDelta = 0), scale = 1, panOffset.set(0, 0, 0), !!(zoomChanged || lastPosition.distanceToSquared(this.object.position) > 1e-6 || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > 1e-6) && (lastPosition.copy(this.object.position),
                        lastQuaternion.copy(this.object.quaternion), zoomChanged = !1, !0);
                    };
                }();
            }
            var longpressTimer, longpressDuration = 500;
            THREE.OrbitControls = function(object, domElement) {
                function pan(deltaX, deltaY) {
                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                    constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);
                }
                function getAutoRotationAngle() {
                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
                }
                function getZoomScale() {
                    return Math.pow(.95, scope.zoomSpeed);
                }
                function onMouseDown(event) {
                    if (!1 !== scope.enabled) {
                        if (event.preventDefault(), event.button === scope.mouseButtons.ORBIT) {
                            if (!1 === scope.enableRotate) return;
                            state = STATE.ROTATE, rotateStart.set(event.clientX, event.clientY);
                        } else if (event.button === scope.mouseButtons.ZOOM) {
                            if (!1 === scope.enableZoom) return;
                            state = STATE.DOLLY, dollyStart.set(event.clientX, event.clientY);
                        } else if (event.button === scope.mouseButtons.PAN) {
                            if (!1 === scope.enablePan) return;
                            state = STATE.PAN, panStart.set(event.clientX, event.clientY);
                        }
                        state !== STATE.NONE && (document.addEventListener("mousemove", onMouseMove, !1),
                        document.addEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(startEvent));
                    }
                }
                function onMouseMove(event) {
                    if (!1 !== scope.enabled) {
                        event.preventDefault();
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        if (state === STATE.ROTATE) {
                            if (!1 === scope.enableRotate) return;
                            rotateEnd.set(event.clientX, event.clientY), rotateDelta.subVectors(rotateEnd, rotateStart),
                            constraint.rotateLeft(2 * Math.PI * -rotateDelta.x / element.clientWidth * scope.rotateSpeed),
                            constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed),
                            rotateStart.copy(rotateEnd);
                        } else if (state === STATE.DOLLY) {
                            if (!1 === scope.enableZoom) return;
                            dollyEnd.set(event.clientX, event.clientY), dollyDelta.subVectors(dollyEnd, dollyStart),
                            dollyDelta.y > 0 ? constraint.dollyIn(getZoomScale()) : dollyDelta.y < 0 && constraint.dollyOut(getZoomScale()),
                            dollyStart.copy(dollyEnd);
                        } else if (state === STATE.PAN) {
                            if (!1 === scope.enablePan) return;
                            panEnd.set(event.clientX, event.clientY), panDelta.subVectors(panEnd, panStart),
                            pan(panDelta.x, panDelta.y), panStart.copy(panEnd);
                        }
                        state !== STATE.NONE && scope.update();
                    }
                }
                function onMouseUp() {
                    !1 !== scope.enabled && (document.removeEventListener("mousemove", onMouseMove, !1),
                    document.removeEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(endEvent),
                    state = STATE.NONE);
                }
                function onMouseWheel(event) {
                    if (!1 !== scope.enabled && !1 !== scope.enableZoom && state === STATE.NONE) {
                        event.preventDefault(), event.stopPropagation();
                        var delta = 0;
                        void 0 !== event.wheelDelta ? delta = event.wheelDelta : void 0 !== event.detail && (delta = -event.detail),
                        delta > 0 ? constraint.dollyOut(getZoomScale()) : delta < 0 && constraint.dollyIn(getZoomScale()),
                        scope.update(), scope.dispatchEvent(startEvent), scope.dispatchEvent(endEvent);
                    }
                }
                function onKeyDown(event) {
                    if (!1 !== scope.enabled && !1 !== scope.enableKeys && !1 !== scope.enablePan) switch (event.keyCode) {
                      case scope.keys.UP:
                        pan(0, scope.keyPanSpeed), scope.update();
                        break;

                      case scope.keys.BOTTOM:
                        pan(0, -scope.keyPanSpeed), scope.update();
                        break;

                      case scope.keys.LEFT:
                        pan(scope.keyPanSpeed, 0), scope.update();
                        break;

                      case scope.keys.RIGHT:
                        pan(-scope.keyPanSpeed, 0), scope.update();
                    }
                }
                function touchstart(event) {
                    var longpressEvent = new CustomEvent("onlongpress", {
                        detail: event.touches[0]
                    });
                    if (longpressTimer = setTimeout(function() {
                        window.dispatchEvent(longpressEvent);
                    }, longpressDuration), !1 !== scope.enabled) {
                        switch (event.touches.length) {
                          case 1:
                            if (!1 === scope.enableRotate) return;
                            state = STATE.TOUCH_ROTATE, rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
                            break;

                          case 2:
                            if (!1 === scope.enableZoom) return;
                            state = STATE.TOUCH_DOLLY;
                            var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
                            dollyStart.set(0, distance);
                            break;

                          case 3:
                            if (!1 === scope.enablePan) return;
                            state = STATE.TOUCH_PAN, panStart.set(event.touches[0].pageX, event.touches[0].pageY);
                            break;

                          default:
                            state = STATE.NONE;
                        }
                        state !== STATE.NONE && scope.dispatchEvent(startEvent);
                    }
                }
                function touchmove(event) {
                    if (longpressTimer && clearTimeout(longpressTimer), !1 !== scope.enabled) {
                        event.preventDefault(), event.stopPropagation();
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        switch (event.touches.length) {
                          case 1:
                            if (!1 === scope.enableRotate) return;
                            if (state !== STATE.TOUCH_ROTATE) return;
                            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY), rotateDelta.subVectors(rotateEnd, rotateStart),
                            constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed),
                            constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed),
                            rotateStart.copy(rotateEnd), scope.update();
                            break;

                          case 2:
                            if (!1 === scope.enableZoom) return;
                            if (state !== STATE.TOUCH_DOLLY) return;
                            var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
                            dollyEnd.set(0, distance), dollyDelta.subVectors(dollyEnd, dollyStart), dollyDelta.y > 0 ? constraint.dollyOut(getZoomScale()) : dollyDelta.y < 0 && constraint.dollyIn(getZoomScale()),
                            dollyStart.copy(dollyEnd), scope.update();
                            break;

                          case 3:
                            if (!1 === scope.enablePan) return;
                            if (state !== STATE.TOUCH_PAN) return;
                            panEnd.set(event.touches[0].pageX, event.touches[0].pageY), panDelta.subVectors(panEnd, panStart),
                            pan(panDelta.x, panDelta.y), panStart.copy(panEnd), scope.update();
                            break;

                          default:
                            state = STATE.NONE;
                        }
                    }
                }
                function touchend() {
                    longpressTimer && clearTimeout(longpressTimer), !1 !== scope.enabled && (scope.dispatchEvent(endEvent),
                    state = STATE.NONE);
                }
                function contextmenu(event) {
                    event.preventDefault();
                }
                var constraint = new OrbitConstraint(object);
                this.domElement = void 0 !== domElement ? domElement : document, Object.defineProperty(this, "constraint", {
                    get: function() {
                        return constraint;
                    }
                }), this.getPolarAngle = function() {
                    return constraint.getPolarAngle();
                }, this.getAzimuthalAngle = function() {
                    return constraint.getAzimuthalAngle();
                }, this.enabled = !0, this.center = this.target, this.enableZoom = !0, this.zoomSpeed = 1,
                this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7,
                this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    BOTTOM: 40
                }, this.mouseButtons = {
                    ORBIT: THREE.MOUSE.LEFT,
                    ZOOM: THREE.MOUSE.MIDDLE,
                    PAN: THREE.MOUSE.RIGHT
                };
                var scope = this, rotateStart = new THREE.Vector2(), rotateEnd = new THREE.Vector2(), rotateDelta = new THREE.Vector2(), panStart = new THREE.Vector2(), panEnd = new THREE.Vector2(), panDelta = new THREE.Vector2(), dollyStart = new THREE.Vector2(), dollyEnd = new THREE.Vector2(), dollyDelta = new THREE.Vector2(), STATE = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_DOLLY: 4,
                    TOUCH_PAN: 5
                }, state = STATE.NONE;
                this.target0 = this.target.clone(), this.position0 = this.object.position.clone(),
                this.zoom0 = this.object.zoom;
                var changeEvent = {
                    type: "change"
                }, startEvent = {
                    type: "start"
                }, endEvent = {
                    type: "end"
                };
                this.update = function() {
                    this.autoRotate && state === STATE.NONE && constraint.rotateLeft(getAutoRotationAngle()),
                    !0 === constraint.update() && this.dispatchEvent(changeEvent);
                }, this.reset = function() {
                    state = STATE.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0),
                    this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(changeEvent),
                    this.update();
                }, this.dispose = function() {
                    this.domElement.removeEventListener("contextmenu", contextmenu, !1), this.domElement.removeEventListener("mousedown", onMouseDown, !1),
                    this.domElement.removeEventListener("mousewheel", onMouseWheel, !1), this.domElement.removeEventListener("DOMMouseScroll", onMouseWheel, !1),
                    this.domElement.removeEventListener("touchstart", touchstart, !1), this.domElement.removeEventListener("touchend", touchend, !1),
                    this.domElement.removeEventListener("touchmove", touchmove, !1), document.removeEventListener("mousemove", onMouseMove, !1),
                    document.removeEventListener("mouseup", onMouseUp, !1), window.removeEventListener("keydown", onKeyDown, !1);
                }, this.domElement.addEventListener("contextmenu", contextmenu, !1), this.domElement.addEventListener("mousedown", onMouseDown, !1),
                this.domElement.addEventListener("mousewheel", onMouseWheel, !1), this.domElement.addEventListener("DOMMouseScroll", onMouseWheel, !1),
                this.domElement.addEventListener("touchstart", touchstart, !1), this.domElement.addEventListener("touchend", touchend, !1),
                this.domElement.addEventListener("touchmove", touchmove, !1), window.addEventListener("keydown", onKeyDown, !1),
                this.update();
            }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype),
            THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, {
                object: {
                    get: function() {
                        return this.constraint.object;
                    }
                },
                target: {
                    get: function() {
                        return this.constraint.target;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: target is now immutable. Use target.set() instead."),
                        this.constraint.target.copy(value);
                    }
                },
                minDistance: {
                    get: function() {
                        return this.constraint.minDistance;
                    },
                    set: function(value) {
                        this.constraint.minDistance = value;
                    }
                },
                maxDistance: {
                    get: function() {
                        return this.constraint.maxDistance;
                    },
                    set: function(value) {
                        this.constraint.maxDistance = value;
                    }
                },
                minZoom: {
                    get: function() {
                        return this.constraint.minZoom;
                    },
                    set: function(value) {
                        this.constraint.minZoom = value;
                    }
                },
                maxZoom: {
                    get: function() {
                        return this.constraint.maxZoom;
                    },
                    set: function(value) {
                        this.constraint.maxZoom = value;
                    }
                },
                minPolarAngle: {
                    get: function() {
                        return this.constraint.minPolarAngle;
                    },
                    set: function(value) {
                        this.constraint.minPolarAngle = value;
                    }
                },
                maxPolarAngle: {
                    get: function() {
                        return this.constraint.maxPolarAngle;
                    },
                    set: function(value) {
                        this.constraint.maxPolarAngle = value;
                    }
                },
                minAzimuthAngle: {
                    get: function() {
                        return this.constraint.minAzimuthAngle;
                    },
                    set: function(value) {
                        this.constraint.minAzimuthAngle = value;
                    }
                },
                maxAzimuthAngle: {
                    get: function() {
                        return this.constraint.maxAzimuthAngle;
                    },
                    set: function(value) {
                        this.constraint.maxAzimuthAngle = value;
                    }
                },
                enableDamping: {
                    get: function() {
                        return this.constraint.enableDamping;
                    },
                    set: function(value) {
                        this.constraint.enableDamping = value;
                    }
                },
                dampingFactor: {
                    get: function() {
                        return this.constraint.dampingFactor;
                    },
                    set: function(value) {
                        this.constraint.dampingFactor = value;
                    }
                },
                noZoom: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                        !this.enableZoom;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                        this.enableZoom = !value;
                    }
                },
                noRotate: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                        !this.enableRotate;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                        this.enableRotate = !value;
                    }
                },
                noPan: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                        !this.enablePan;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                        this.enablePan = !value;
                    }
                },
                noKeys: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                        !this.enableKeys;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                        this.enableKeys = !value;
                    }
                },
                staticMoving: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                        !this.constraint.enableDamping;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                        this.constraint.enableDamping = !value;
                    }
                },
                dynamicDampingFactor: {
                    get: function() {
                        return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                        this.constraint.dampingFactor;
                    },
                    set: function(value) {
                        console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                        this.constraint.dampingFactor = value;
                    }
                }
            });
        }();
    }).call(exports, __webpack_require__(19));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular, FastClick) {
        angular.module("EdGuiApp").run(function() {
            FastClick.attach(document.body);
        });
    }).call(exports, __webpack_require__(0), __webpack_require__(69));
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !function() {
        "use strict";
        /**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */
        function FastClick(layer, options) {
            var oldOnClick;
            if (options = options || {}, this.trackingClick = !1, this.trackingClickStart = 0,
            this.targetElement = null, this.touchStartX = 0, this.touchStartY = 0, this.lastTouchIdentifier = 0,
            this.touchBoundary = options.touchBoundary || 10, this.layer = layer, this.tapDelay = options.tapDelay || 200,
            this.tapTimeout = options.tapTimeout || 700, !FastClick.notNeeded(layer)) {
                for (var methods = [ "onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel" ], context = this, i = 0, l = methods.length; i < l; i++) context[methods[i]] = function(method, context) {
                    return function() {
                        return method.apply(context, arguments);
                    };
                }(context[methods[i]], context);
                deviceIsAndroid && (layer.addEventListener("mouseover", this.onMouse, !0), layer.addEventListener("mousedown", this.onMouse, !0),
                layer.addEventListener("mouseup", this.onMouse, !0)), layer.addEventListener("click", this.onClick, !0),
                layer.addEventListener("touchstart", this.onTouchStart, !1), layer.addEventListener("touchmove", this.onTouchMove, !1),
                layer.addEventListener("touchend", this.onTouchEnd, !1), layer.addEventListener("touchcancel", this.onTouchCancel, !1),
                Event.prototype.stopImmediatePropagation || (layer.removeEventListener = function(type, callback, capture) {
                    var rmv = Node.prototype.removeEventListener;
                    "click" === type ? rmv.call(layer, type, callback.hijacked || callback, capture) : rmv.call(layer, type, callback, capture);
                }, layer.addEventListener = function(type, callback, capture) {
                    var adv = Node.prototype.addEventListener;
                    "click" === type ? adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                        event.propagationStopped || callback(event);
                    }), capture) : adv.call(layer, type, callback, capture);
                }), "function" == typeof layer.onclick && (oldOnClick = layer.onclick, layer.addEventListener("click", function(event) {
                    oldOnClick(event);
                }, !1), layer.onclick = null);
            }
        }
        var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0, deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0 && !deviceIsWindowsPhone, deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone, deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent), deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent), deviceIsBlackBerry10 = navigator.userAgent.indexOf("BB10") > 0;
        FastClick.prototype.needsClick = function(target) {
            switch (target.nodeName.toLowerCase()) {
              case "button":
              case "select":
              case "textarea":
                if (target.disabled) return !0;
                break;

              case "input":
                if (deviceIsIOS && "file" === target.type || target.disabled) return !0;
                break;

              case "label":
              case "iframe":
              case "video":
                return !0;
            }
            return /\bneedsclick\b/.test(target.className);
        }, FastClick.prototype.needsFocus = function(target) {
            switch (target.nodeName.toLowerCase()) {
              case "textarea":
                return !0;

              case "select":
                return !deviceIsAndroid;

              case "input":
                switch (target.type) {
                  case "button":
                  case "checkbox":
                  case "file":
                  case "image":
                  case "radio":
                  case "submit":
                    return !1;
                }
                return !target.disabled && !target.readOnly;

              default:
                return /\bneedsfocus\b/.test(target.className);
            }
        }, FastClick.prototype.sendClick = function(targetElement, event) {
            var clickEvent, touch;
            document.activeElement && document.activeElement !== targetElement && document.activeElement.blur(),
            touch = event.changedTouches[0], clickEvent = document.createEvent("MouseEvents"),
            clickEvent.initMouseEvent(this.determineEventType(targetElement), !0, !0, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, !1, !1, !1, !1, 0, null),
            clickEvent.forwardedTouchEvent = !0, targetElement.dispatchEvent(clickEvent);
        }, FastClick.prototype.determineEventType = function(targetElement) {
            return deviceIsAndroid && "select" === targetElement.tagName.toLowerCase() ? "mousedown" : "click";
        }, FastClick.prototype.focus = function(targetElement) {
            var length;
            deviceIsIOS && targetElement.setSelectionRange && 0 !== targetElement.type.indexOf("date") && "time" !== targetElement.type && "month" !== targetElement.type ? (length = targetElement.value.length,
            targetElement.setSelectionRange(length, length)) : targetElement.focus();
        }, FastClick.prototype.updateScrollParent = function(targetElement) {
            var scrollParent, parentElement;
            if (!(scrollParent = targetElement.fastClickScrollParent) || !scrollParent.contains(targetElement)) {
                parentElement = targetElement;
                do {
                    if (parentElement.scrollHeight > parentElement.offsetHeight) {
                        scrollParent = parentElement, targetElement.fastClickScrollParent = parentElement;
                        break;
                    }
                    parentElement = parentElement.parentElement;
                } while (parentElement);
            }
            scrollParent && (scrollParent.fastClickLastScrollTop = scrollParent.scrollTop);
        }, FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
            return eventTarget.nodeType === Node.TEXT_NODE ? eventTarget.parentNode : eventTarget;
        }, FastClick.prototype.onTouchStart = function(event) {
            var targetElement, touch, selection;
            if (event.targetTouches.length > 1) return !0;
            if (targetElement = this.getTargetElementFromEventTarget(event.target), touch = event.targetTouches[0],
            deviceIsIOS) {
                if (selection = window.getSelection(), selection.rangeCount && !selection.isCollapsed) return !0;
                if (!deviceIsIOS4) {
                    if (touch.identifier && touch.identifier === this.lastTouchIdentifier) return event.preventDefault(),
                    !1;
                    this.lastTouchIdentifier = touch.identifier, this.updateScrollParent(targetElement);
                }
            }
            return this.trackingClick = !0, this.trackingClickStart = event.timeStamp, this.targetElement = targetElement,
            this.touchStartX = touch.pageX, this.touchStartY = touch.pageY, event.timeStamp - this.lastClickTime < this.tapDelay && event.preventDefault(),
            !0;
        }, FastClick.prototype.touchHasMoved = function(event) {
            var touch = event.changedTouches[0], boundary = this.touchBoundary;
            return Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary;
        }, FastClick.prototype.onTouchMove = function(event) {
            return !this.trackingClick || ((this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) && (this.trackingClick = !1,
            this.targetElement = null), !0);
        }, FastClick.prototype.findControl = function(labelElement) {
            return void 0 !== labelElement.control ? labelElement.control : labelElement.htmlFor ? document.getElementById(labelElement.htmlFor) : labelElement.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea");
        }, FastClick.prototype.onTouchEnd = function(event) {
            var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
            if (!this.trackingClick) return !0;
            if (event.timeStamp - this.lastClickTime < this.tapDelay) return this.cancelNextClick = !0,
            !0;
            if (event.timeStamp - this.trackingClickStart > this.tapTimeout) return !0;
            if (this.cancelNextClick = !1, this.lastClickTime = event.timeStamp, trackingClickStart = this.trackingClickStart,
            this.trackingClick = !1, this.trackingClickStart = 0, deviceIsIOSWithBadTarget && (touch = event.changedTouches[0],
            targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement,
            targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent),
            "label" === (targetTagName = targetElement.tagName.toLowerCase())) {
                if (forElement = this.findControl(targetElement)) {
                    if (this.focus(targetElement), deviceIsAndroid) return !1;
                    targetElement = forElement;
                }
            } else if (this.needsFocus(targetElement)) return event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && "input" === targetTagName ? (this.targetElement = null,
            !1) : (this.focus(targetElement), this.sendClick(targetElement, event), deviceIsIOS && "select" === targetTagName || (this.targetElement = null,
            event.preventDefault()), !1);
            return !(!deviceIsIOS || deviceIsIOS4 || !(scrollParent = targetElement.fastClickScrollParent) || scrollParent.fastClickLastScrollTop === scrollParent.scrollTop) || (this.needsClick(targetElement) || (event.preventDefault(),
            this.sendClick(targetElement, event)), !1);
        }, FastClick.prototype.onTouchCancel = function() {
            this.trackingClick = !1, this.targetElement = null;
        }, FastClick.prototype.onMouse = function(event) {
            return !this.targetElement || (!!event.forwardedTouchEvent || (!event.cancelable || (!(!this.needsClick(this.targetElement) || this.cancelNextClick) || (event.stopImmediatePropagation ? event.stopImmediatePropagation() : event.propagationStopped = !0,
            event.stopPropagation(), event.preventDefault(), !1))));
        }, FastClick.prototype.onClick = function(event) {
            var permitted;
            return this.trackingClick ? (this.targetElement = null, this.trackingClick = !1,
            !0) : "submit" === event.target.type && 0 === event.detail || (permitted = this.onMouse(event),
            permitted || (this.targetElement = null), permitted);
        }, FastClick.prototype.destroy = function() {
            var layer = this.layer;
            deviceIsAndroid && (layer.removeEventListener("mouseover", this.onMouse, !0), layer.removeEventListener("mousedown", this.onMouse, !0),
            layer.removeEventListener("mouseup", this.onMouse, !0)), layer.removeEventListener("click", this.onClick, !0),
            layer.removeEventListener("touchstart", this.onTouchStart, !1), layer.removeEventListener("touchmove", this.onTouchMove, !1),
            layer.removeEventListener("touchend", this.onTouchEnd, !1), layer.removeEventListener("touchcancel", this.onTouchCancel, !1);
        }, FastClick.notNeeded = function(layer) {
            var metaViewport, chromeVersion, blackberryVersion;
            if (void 0 === window.ontouchstart) return !0;
            if (chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1]) {
                if (!deviceIsAndroid) return !0;
                if (metaViewport = document.querySelector("meta[name=viewport]")) {
                    if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
                    if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) return !0;
                }
            }
            if (deviceIsBlackBerry10 && (blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/),
            blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3 && (metaViewport = document.querySelector("meta[name=viewport]")))) {
                if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
                if (document.documentElement.scrollWidth <= window.outerWidth) return !0;
            }
            return "none" === layer.style.msTouchAction || "manipulation" === layer.style.touchAction || (!!(+(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1] >= 27 && (metaViewport = document.querySelector("meta[name=viewport]")) && (-1 !== metaViewport.content.indexOf("user-scalable=no") || document.documentElement.scrollWidth <= window.outerWidth)) || ("none" === layer.style.touchAction || "manipulation" === layer.style.touchAction));
        }, FastClick.attach = function(layer, options) {
            return new FastClick(layer, options);
        }, void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return FastClick;
        }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }();
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(angular, API) {
        angular.module("EdGuiApp").provider("robot", function() {
            this.setUrl = function(url) {
                this.url = url;
            }, this.$get = function() {
                var robot = window.r = new API.Robot({
                    ed: !0,
                    hardware: !0,
                    head: !0,
                    base: !0,
                    body: !0,
                    speech: !0,
                    actionServer: !0
                });
                return robot.connect(), robot;
            };
        });
    }).call(exports, __webpack_require__(0), __webpack_require__(71));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: !0
    });
    var __WEBPACK_IMPORTED_MODULE_0__action_server__ = __webpack_require__(20), __WEBPACK_IMPORTED_MODULE_1__base__ = __webpack_require__(33), __WEBPACK_IMPORTED_MODULE_2__ed__ = __webpack_require__(34), __WEBPACK_IMPORTED_MODULE_3__hardware__ = __webpack_require__(35), __WEBPACK_IMPORTED_MODULE_4__head__ = __webpack_require__(39), __WEBPACK_IMPORTED_MODULE_5__robot__ = __webpack_require__(104);
    __webpack_require__.d(__webpack_exports__, "ActionServer", function() {
        return __WEBPACK_IMPORTED_MODULE_0__action_server__.a;
    }), __webpack_require__.d(__webpack_exports__, "Base", function() {
        return __WEBPACK_IMPORTED_MODULE_1__base__.a;
    }), __webpack_require__.d(__webpack_exports__, "Ed", function() {
        return __WEBPACK_IMPORTED_MODULE_2__ed__.a;
    }), __webpack_require__.d(__webpack_exports__, "Hardware", function() {
        return __WEBPACK_IMPORTED_MODULE_3__hardware__.a;
    }), __webpack_require__.d(__webpack_exports__, "Head", function() {
        return __WEBPACK_IMPORTED_MODULE_4__head__.a;
    }), __webpack_require__.d(__webpack_exports__, "Robot", function() {
        return __WEBPACK_IMPORTED_MODULE_5__robot__.a;
    });
}, function(module, exports, __webpack_require__) {
    (function(global) {
        function Timeout(id, clearFn) {
            this._id = id, this._clearFn = clearFn;
        }
        var scope = void 0 !== global && global || "undefined" != typeof self && self || window, apply = Function.prototype.apply;
        exports.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
        }, exports.setInterval = function() {
            return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
        }, exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout && timeout.close();
        }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
            this._clearFn.call(scope, this._id);
        }, exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
        }, exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
        }, exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            msecs >= 0 && (item._idleTimeoutId = setTimeout(function() {
                item._onTimeout && item._onTimeout();
            }, msecs));
        }, __webpack_require__(73), exports.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== global && global.setImmediate || this && this.setImmediate,
        exports.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== global && global.clearImmediate || this && this.clearImmediate;
    }).call(exports, __webpack_require__(11));
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        !function(global, undefined) {
            "use strict";
            function setImmediate(callback) {
                "function" != typeof callback && (callback = new Function("" + callback));
                for (var args = new Array(arguments.length - 1), i = 0; i < args.length; i++) args[i] = arguments[i + 1];
                var task = {
                    callback: callback,
                    args: args
                };
                return tasksByHandle[nextHandle] = task, registerImmediate(nextHandle), nextHandle++;
            }
            function clearImmediate(handle) {
                delete tasksByHandle[handle];
            }
            function run(task) {
                var callback = task.callback, args = task.args;
                switch (args.length) {
                  case 0:
                    callback();
                    break;

                  case 1:
                    callback(args[0]);
                    break;

                  case 2:
                    callback(args[0], args[1]);
                    break;

                  case 3:
                    callback(args[0], args[1], args[2]);
                    break;

                  default:
                    callback.apply(undefined, args);
                }
            }
            function runIfPresent(handle) {
                if (currentlyRunningATask) setTimeout(runIfPresent, 0, handle); else {
                    var task = tasksByHandle[handle];
                    if (task) {
                        currentlyRunningATask = !0;
                        try {
                            run(task);
                        } finally {
                            clearImmediate(handle), currentlyRunningATask = !1;
                        }
                    }
                }
            }
            if (!global.setImmediate) {
                var registerImmediate, nextHandle = 1, tasksByHandle = {}, currentlyRunningATask = !1, doc = global.document, attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                attachTo = attachTo && attachTo.setTimeout ? attachTo : global, "[object process]" === {}.toString.call(global.process) ? function() {
                    registerImmediate = function(handle) {
                        process.nextTick(function() {
                            runIfPresent(handle);
                        });
                    };
                }() : function() {
                    if (global.postMessage && !global.importScripts) {
                        var postMessageIsAsynchronous = !0, oldOnMessage = global.onmessage;
                        return global.onmessage = function() {
                            postMessageIsAsynchronous = !1;
                        }, global.postMessage("", "*"), global.onmessage = oldOnMessage, postMessageIsAsynchronous;
                    }
                }() ? function() {
                    var messagePrefix = "setImmediate$" + Math.random() + "$", onGlobalMessage = function(event) {
                        event.source === global && "string" == typeof event.data && 0 === event.data.indexOf(messagePrefix) && runIfPresent(+event.data.slice(messagePrefix.length));
                    };
                    global.addEventListener ? global.addEventListener("message", onGlobalMessage, !1) : global.attachEvent("onmessage", onGlobalMessage),
                    registerImmediate = function(handle) {
                        global.postMessage(messagePrefix + handle, "*");
                    };
                }() : global.MessageChannel ? function() {
                    var channel = new MessageChannel();
                    channel.port1.onmessage = function(event) {
                        runIfPresent(event.data);
                    }, registerImmediate = function(handle) {
                        channel.port2.postMessage(handle);
                    };
                }() : doc && "onreadystatechange" in doc.createElement("script") ? function() {
                    var html = doc.documentElement;
                    registerImmediate = function(handle) {
                        var script = doc.createElement("script");
                        script.onreadystatechange = function() {
                            runIfPresent(handle), script.onreadystatechange = null, html.removeChild(script),
                            script = null;
                        }, html.appendChild(script);
                    };
                }() : function() {
                    registerImmediate = function(handle) {
                        setTimeout(runIfPresent, 0, handle);
                    };
                }(), attachTo.setImmediate = setImmediate, attachTo.clearImmediate = clearImmediate;
            }
        }("undefined" == typeof self ? void 0 === global ? this : global : self);
    }).call(exports, __webpack_require__(11), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    var mixin = __webpack_require__(14), core = module.exports = {
        Ros: __webpack_require__(15),
        Topic: __webpack_require__(8),
        Message: __webpack_require__(6),
        Param: __webpack_require__(83),
        Service: __webpack_require__(12),
        ServiceRequest: __webpack_require__(7),
        ServiceResponse: __webpack_require__(22)
    };
    mixin(core.Ros, [ "Param", "Service", "Topic" ], core);
}, function(module, exports, __webpack_require__) {
    function WorkerSocket(uri) {
        this.socket_ = work(workerSocketImpl), this.socket_.addEventListener("message", this.handleWorkerMessage_.bind(this)),
        this.socket_.postMessage({
            uri: uri
        });
    }
    var work = __webpack_require__(76), workerSocketImpl = __webpack_require__(77);
    WorkerSocket.prototype.handleWorkerMessage_ = function(ev) {
        var data = ev.data;
        if (data instanceof ArrayBuffer || "string" == typeof data) this.onmessage(ev); else {
            var type = data.type;
            if ("close" === type) this.onclose(null); else if ("open" === type) this.onopen(null); else {
                if ("error" !== type) throw "Unknown message from workersocket";
                this.onerror(null);
            }
        }
    }, WorkerSocket.prototype.send = function(data) {
        this.socket_.postMessage(data);
    }, WorkerSocket.prototype.close = function() {
        this.socket_.postMessage({
            close: !0
        });
    }, module.exports = WorkerSocket;
}, function(module, exports) {
    var bundleFn = arguments[3], sources = arguments[4], cache = arguments[5], stringify = JSON.stringify;
    module.exports = function(fn, options) {
        function resolveSources(key) {
            workerSources[key] = !0;
            for (var depPath in sources[key][1]) {
                var depKey = sources[key][1][depPath];
                workerSources[depKey] || resolveSources(depKey);
            }
        }
        for (var wkey, cacheKeys = Object.keys(cache), i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i], exp = cache[key].exports;
            if (exp === fn || exp && exp.default === fn) {
                wkey = key;
                break;
            }
        }
        if (!wkey) {
            wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
            for (var wcache = {}, i = 0, l = cacheKeys.length; i < l; i++) {
                var key = cacheKeys[i];
                wcache[key] = key;
            }
            sources[wkey] = [ "function(require,module,exports){" + fn + "(self); }", wcache ];
        }
        var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16), scache = {};
        scache[wkey] = wkey, sources[skey] = [ "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}", scache ];
        var workerSources = {};
        resolveSources(skey);
        var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map(function(key) {
            return stringify(key) + ":[" + sources[key][0] + "," + stringify(sources[key][1]) + "]";
        }).join(",") + "},{},[" + stringify(skey) + "])", URL = window.URL || window.webkitURL || window.mozURL || window.msURL, blob = new Blob([ src ], {
            type: "text/javascript"
        });
        if (options && options.bare) return blob;
        var workerUrl = URL.createObjectURL(blob), worker = new Worker(workerUrl);
        return worker.objectURL = workerUrl, worker;
    };
}, function(module, exports, __webpack_require__) {
    var WebSocket = WebSocket || __webpack_require__(21);
    module.exports = function(self) {
        function handleSocketMessage(ev) {
            var data = ev.data;
            data instanceof ArrayBuffer ? self.postMessage(data, [ data ]) : self.postMessage(data);
        }
        function handleSocketControl(ev) {
            self.postMessage({
                type: ev.type
            });
        }
        var socket = null;
        self.addEventListener("message", function(ev) {
            var data = ev.data;
            if ("string" == typeof data) socket.send(data); else if (data.hasOwnProperty("close")) socket.close(),
            socket = null; else {
                if (!data.hasOwnProperty("uri")) throw "Unknown message to WorkerSocket";
                var uri = data.uri;
                socket = new WebSocket(uri), socket.binaryType = "arraybuffer", socket.onmessage = handleSocketMessage,
                socket.onclose = handleSocketControl, socket.onopen = handleSocketControl, socket.onerror = handleSocketControl;
            }
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function SocketAdapter(client) {
        function handleMessage(message) {
            "publish" === message.op ? client.emit(message.topic, message.msg) : "service_response" === message.op ? client.emit(message.id, message) : "call_service" === message.op ? client.emit(message.service, message) : "status" === message.op && (message.id ? client.emit("status:" + message.id, message) : client.emit("status", message));
        }
        function handlePng(message, callback) {
            "png" === message.op ? decompressPng(message.data, callback) : callback(message);
        }
        function decodeBSON(data, callback) {
            if (!BSON) throw "Cannot process BSON encoded message without BSON header.";
            var reader = new FileReader();
            reader.onload = function() {
                var uint8Array = new Uint8Array(this.result), msg = BSON.deserialize(uint8Array);
                callback(msg);
            }, reader.readAsArrayBuffer(data);
        }
        return {
            onopen: function(event) {
                client.isConnected = !0, client.emit("connection", event);
            },
            onclose: function(event) {
                client.isConnected = !1, client.emit("close", event);
            },
            onerror: function(event) {
                client.emit("error", event);
            },
            onmessage: function(data) {
                if ("undefined" != typeof Blob && data.data instanceof Blob) decodeBSON(data.data, function(message) {
                    handlePng(message, handleMessage);
                }); else if (data.data instanceof ArrayBuffer) {
                    var decoded = CBOR.decode(data.data, typedArrayTagger);
                    handleMessage(decoded);
                } else {
                    var message = JSON.parse("string" == typeof data ? data : data.data);
                    handlePng(message, handleMessage);
                }
            }
        };
    }
    var decompressPng = __webpack_require__(79), CBOR = __webpack_require__(81), typedArrayTagger = __webpack_require__(82), BSON = null;
    "undefined" != typeof bson && (BSON = bson().BSON), module.exports = SocketAdapter;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function decompressPng(data, callback) {
        var image = new Image();
        image.onload = function() {
            var canvas = new Canvas(), context = canvas.getContext("2d");
            canvas.width = image.width, canvas.height = image.height, context.imageSmoothingEnabled = !1,
            context.webkitImageSmoothingEnabled = !1, context.mozImageSmoothingEnabled = !1,
            context.drawImage(image, 0, 0);
            for (var imageData = context.getImageData(0, 0, image.width, image.height).data, jsonData = "", i = 0; i < imageData.length; i += 4) jsonData += String.fromCharCode(imageData[i], imageData[i + 1], imageData[i + 2]);
            callback(JSON.parse(jsonData));
        }, image.src = "data:image/png;base64," + data;
    }
    var Canvas = __webpack_require__(80), Image = Canvas.Image || window.Image;
    module.exports = decompressPng;
}, function(module, exports) {
    module.exports = function() {
        return document.createElement("canvas");
    };
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
    !function(global, undefined) {
        "use strict";
        function encode(value) {
            function ensureSpace(length) {
                for (var newByteLength = data.byteLength, requiredLength = offset + length; newByteLength < requiredLength; ) newByteLength *= 2;
                if (newByteLength !== data.byteLength) {
                    var oldDataView = dataView;
                    data = new ArrayBuffer(newByteLength), dataView = new DataView(data);
                    for (var uint32count = offset + 3 >> 2, i = 0; i < uint32count; ++i) dataView.setUint32(4 * i, oldDataView.getUint32(4 * i));
                }
                return lastLength = length, dataView;
            }
            function write() {
                offset += lastLength;
            }
            function writeFloat64(value) {
                write(ensureSpace(8).setFloat64(offset, value));
            }
            function writeUint8(value) {
                write(ensureSpace(1).setUint8(offset, value));
            }
            function writeUint8Array(value) {
                for (var dataView = ensureSpace(value.length), i = 0; i < value.length; ++i) dataView.setUint8(offset + i, value[i]);
                write();
            }
            function writeUint16(value) {
                write(ensureSpace(2).setUint16(offset, value));
            }
            function writeUint32(value) {
                write(ensureSpace(4).setUint32(offset, value));
            }
            function writeUint64(value) {
                var low = value % POW_2_32, high = (value - low) / POW_2_32, dataView = ensureSpace(8);
                dataView.setUint32(offset, high), dataView.setUint32(offset + 4, low), write();
            }
            function writeTypeAndLength(type, length) {
                length < 24 ? writeUint8(type << 5 | length) : length < 256 ? (writeUint8(type << 5 | 24),
                writeUint8(length)) : length < 65536 ? (writeUint8(type << 5 | 25), writeUint16(length)) : length < 4294967296 ? (writeUint8(type << 5 | 26),
                writeUint32(length)) : (writeUint8(type << 5 | 27), writeUint64(length));
            }
            function encodeItem(value) {
                var i;
                if (!1 === value) return writeUint8(244);
                if (!0 === value) return writeUint8(245);
                if (null === value) return writeUint8(246);
                if (value === undefined) return writeUint8(247);
                switch (typeof value) {
                  case "number":
                    if (Math.floor(value) === value) {
                        if (0 <= value && value <= POW_2_53) return writeTypeAndLength(0, value);
                        if (-POW_2_53 <= value && value < 0) return writeTypeAndLength(1, -(value + 1));
                    }
                    return writeUint8(251), writeFloat64(value);

                  case "string":
                    var utf8data = [];
                    for (i = 0; i < value.length; ++i) {
                        var charCode = value.charCodeAt(i);
                        charCode < 128 ? utf8data.push(charCode) : charCode < 2048 ? (utf8data.push(192 | charCode >> 6),
                        utf8data.push(128 | 63 & charCode)) : charCode < 55296 ? (utf8data.push(224 | charCode >> 12),
                        utf8data.push(128 | charCode >> 6 & 63), utf8data.push(128 | 63 & charCode)) : (charCode = (1023 & charCode) << 10,
                        charCode |= 1023 & value.charCodeAt(++i), charCode += 65536, utf8data.push(240 | charCode >> 18),
                        utf8data.push(128 | charCode >> 12 & 63), utf8data.push(128 | charCode >> 6 & 63),
                        utf8data.push(128 | 63 & charCode));
                    }
                    return writeTypeAndLength(3, utf8data.length), writeUint8Array(utf8data);

                  default:
                    var length;
                    if (Array.isArray(value)) for (length = value.length, writeTypeAndLength(4, length),
                    i = 0; i < length; ++i) encodeItem(value[i]); else if (value instanceof Uint8Array) writeTypeAndLength(2, value.length),
                    writeUint8Array(value); else {
                        var keys = Object.keys(value);
                        for (length = keys.length, writeTypeAndLength(5, length), i = 0; i < length; ++i) {
                            var key = keys[i];
                            encodeItem(key), encodeItem(value[key]);
                        }
                    }
                }
            }
            var lastLength, data = new ArrayBuffer(256), dataView = new DataView(data), offset = 0;
            if (encodeItem(value), "slice" in data) return data.slice(0, offset);
            for (var ret = new ArrayBuffer(offset), retView = new DataView(ret), i = 0; i < offset; ++i) retView.setUint8(i, dataView.getUint8(i));
            return ret;
        }
        function decode(data, tagger, simpleValue) {
            function read(value, length) {
                return offset += length, value;
            }
            function readArrayBuffer(length) {
                return read(new Uint8Array(data, offset, length), length);
            }
            function readFloat16() {
                var tempArrayBuffer = new ArrayBuffer(4), tempDataView = new DataView(tempArrayBuffer), value = readUint16(), sign = 32768 & value, exponent = 31744 & value, fraction = 1023 & value;
                if (31744 === exponent) exponent = 261120; else if (0 !== exponent) exponent += 114688; else if (0 !== fraction) return fraction * POW_2_24;
                return tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13),
                tempDataView.getFloat32(0);
            }
            function readFloat32() {
                return read(dataView.getFloat32(offset), 4);
            }
            function readFloat64() {
                return read(dataView.getFloat64(offset), 8);
            }
            function readUint8() {
                return read(dataView.getUint8(offset), 1);
            }
            function readUint16() {
                return read(dataView.getUint16(offset), 2);
            }
            function readUint32() {
                return read(dataView.getUint32(offset), 4);
            }
            function readUint64() {
                return readUint32() * POW_2_32 + readUint32();
            }
            function readBreak() {
                return 255 === dataView.getUint8(offset) && (offset += 1, !0);
            }
            function readLength(additionalInformation) {
                if (additionalInformation < 24) return additionalInformation;
                if (24 === additionalInformation) return readUint8();
                if (25 === additionalInformation) return readUint16();
                if (26 === additionalInformation) return readUint32();
                if (27 === additionalInformation) return readUint64();
                if (31 === additionalInformation) return -1;
                throw "Invalid length encoding";
            }
            function readIndefiniteStringLength(majorType) {
                var initialByte = readUint8();
                if (255 === initialByte) return -1;
                var length = readLength(31 & initialByte);
                if (length < 0 || initialByte >> 5 !== majorType) throw "Invalid indefinite length element";
                return length;
            }
            function appendUtf16data(utf16data, length) {
                for (var i = 0; i < length; ++i) {
                    var value = readUint8();
                    128 & value && (value < 224 ? (value = (31 & value) << 6 | 63 & readUint8(), length -= 1) : value < 240 ? (value = (15 & value) << 12 | (63 & readUint8()) << 6 | 63 & readUint8(),
                    length -= 2) : (value = (15 & value) << 18 | (63 & readUint8()) << 12 | (63 & readUint8()) << 6 | 63 & readUint8(),
                    length -= 3)), value < 65536 ? utf16data.push(value) : (value -= 65536, utf16data.push(55296 | value >> 10),
                    utf16data.push(56320 | 1023 & value));
                }
            }
            function decodeItem() {
                var i, length, initialByte = readUint8(), majorType = initialByte >> 5, additionalInformation = 31 & initialByte;
                if (7 === majorType) switch (additionalInformation) {
                  case 25:
                    return readFloat16();

                  case 26:
                    return readFloat32();

                  case 27:
                    return readFloat64();
                }
                if ((length = readLength(additionalInformation)) < 0 && (majorType < 2 || 6 < majorType)) throw "Invalid length";
                switch (majorType) {
                  case 0:
                    return length;

                  case 1:
                    return -1 - length;

                  case 2:
                    if (length < 0) {
                        for (var elements = [], fullArrayLength = 0; (length = readIndefiniteStringLength(majorType)) >= 0; ) fullArrayLength += length,
                        elements.push(readArrayBuffer(length));
                        var fullArray = new Uint8Array(fullArrayLength), fullArrayOffset = 0;
                        for (i = 0; i < elements.length; ++i) fullArray.set(elements[i], fullArrayOffset),
                        fullArrayOffset += elements[i].length;
                        return fullArray;
                    }
                    return readArrayBuffer(length);

                  case 3:
                    var utf16data = [];
                    if (length < 0) for (;(length = readIndefiniteStringLength(majorType)) >= 0; ) appendUtf16data(utf16data, length); else appendUtf16data(utf16data, length);
                    return String.fromCharCode.apply(null, utf16data);

                  case 4:
                    var retArray;
                    if (length < 0) for (retArray = []; !readBreak(); ) retArray.push(decodeItem()); else for (retArray = new Array(length),
                    i = 0; i < length; ++i) retArray[i] = decodeItem();
                    return retArray;

                  case 5:
                    var retObject = {};
                    for (i = 0; i < length || length < 0 && !readBreak(); ++i) {
                        retObject[decodeItem()] = decodeItem();
                    }
                    return retObject;

                  case 6:
                    return tagger(decodeItem(), length);

                  case 7:
                    switch (length) {
                      case 20:
                        return !1;

                      case 21:
                        return !0;

                      case 22:
                        return null;

                      case 23:
                        return undefined;

                      default:
                        return simpleValue(length);
                    }
                }
            }
            var dataView = new DataView(data), offset = 0;
            "function" != typeof tagger && (tagger = function(value) {
                return value;
            }), "function" != typeof simpleValue && (simpleValue = function() {
                return undefined;
            });
            var ret = decodeItem();
            if (offset !== data.byteLength) throw "Remaining bytes";
            return ret;
        }
        var POW_2_24 = Math.pow(2, -24), POW_2_32 = Math.pow(2, 32), POW_2_53 = Math.pow(2, 53), obj = {
            encode: encode,
            decode: decode
        };
        __WEBPACK_AMD_DEFINE_FACTORY__ = obj, (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__) !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }();
}, function(module, exports, __webpack_require__) {
    "use strict";
    function warnPrecision() {
        warnedPrecision || (warnedPrecision = !0, console.warn("CBOR 64-bit integer array values may lose precision. No further warnings."));
    }
    function decodeUint64LE(bytes) {
        warnPrecision();
        for (var byteLen = bytes.byteLength, offset = bytes.byteOffset, arrLen = byteLen / 8, buffer = bytes.buffer.slice(offset, offset + byteLen), uint32View = new Uint32Array(buffer), arr = new Array(arrLen), i = 0; i < arrLen; i++) {
            var si = 2 * i, lo = uint32View[si], hi = uint32View[si + 1];
            arr[i] = lo + UPPER32 * hi;
        }
        return arr;
    }
    function decodeInt64LE(bytes) {
        warnPrecision();
        for (var byteLen = bytes.byteLength, offset = bytes.byteOffset, arrLen = byteLen / 8, buffer = bytes.buffer.slice(offset, offset + byteLen), uint32View = new Uint32Array(buffer), int32View = new Int32Array(buffer), arr = new Array(arrLen), i = 0; i < arrLen; i++) {
            var si = 2 * i, lo = uint32View[si], hi = int32View[si + 1];
            arr[i] = lo + UPPER32 * hi;
        }
        return arr;
    }
    function decodeNativeArray(bytes, ArrayType) {
        var byteLen = bytes.byteLength, offset = bytes.byteOffset;
        return new ArrayType(bytes.buffer.slice(offset, offset + byteLen));
    }
    function cborTypedArrayTagger(data, tag) {
        if (tag in nativeArrayTypes) {
            return decodeNativeArray(data, nativeArrayTypes[tag]);
        }
        return tag in conversionArrayTypes ? conversionArrayTypes[tag](data) : data;
    }
    var UPPER32 = Math.pow(2, 32), warnedPrecision = !1, nativeArrayTypes = {
        64: Uint8Array,
        69: Uint16Array,
        70: Uint32Array,
        72: Int8Array,
        77: Int16Array,
        78: Int32Array,
        85: Float32Array,
        86: Float64Array
    }, conversionArrayTypes = {
        71: decodeUint64LE,
        79: decodeInt64LE
    };
    void 0 !== module && module.exports && (module.exports = cborTypedArrayTagger);
}, function(module, exports, __webpack_require__) {
    function Param(options) {
        options = options || {}, this.ros = options.ros, this.name = options.name;
    }
    var Service = __webpack_require__(12), ServiceRequest = __webpack_require__(7);
    Param.prototype.get = function(callback) {
        var paramClient = new Service({
            ros: this.ros,
            name: "/rosapi/get_param",
            serviceType: "rosapi/GetParam"
        }), request = new ServiceRequest({
            name: this.name
        });
        paramClient.callService(request, function(result) {
            var value = JSON.parse(result.value);
            callback(value);
        });
    }, Param.prototype.set = function(value, callback) {
        var paramClient = new Service({
            ros: this.ros,
            name: "/rosapi/set_param",
            serviceType: "rosapi/SetParam"
        }), request = new ServiceRequest({
            name: this.name,
            value: JSON.stringify(value)
        });
        paramClient.callService(request, callback);
    }, Param.prototype.delete = function(callback) {
        var paramClient = new Service({
            ros: this.ros,
            name: "/rosapi/delete_param",
            serviceType: "rosapi/DeleteParam"
        }), request = new ServiceRequest({
            name: this.name
        });
        paramClient.callService(request, callback);
    }, module.exports = Param;
}, function(module, exports, __webpack_require__) {
    var Ros = __webpack_require__(15);
    __webpack_require__(14)(Ros, [ "ActionClient", "SimpleActionServer" ], module.exports = {
        ActionClient: __webpack_require__(23),
        ActionListener: __webpack_require__(85),
        Goal: __webpack_require__(24),
        SimpleActionServer: __webpack_require__(86)
    });
}, function(module, exports, __webpack_require__) {
    function ActionListener(options) {
        var that = this;
        options = options || {}, this.ros = options.ros, this.serverName = options.serverName,
        this.actionName = options.actionName, this.timeout = options.timeout, this.omitFeedback = options.omitFeedback,
        this.omitStatus = options.omitStatus, this.omitResult = options.omitResult;
        var goalListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/goal",
            messageType: this.actionName + "Goal"
        }), feedbackListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/feedback",
            messageType: this.actionName + "Feedback"
        }), statusListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/status",
            messageType: "actionlib_msgs/GoalStatusArray"
        }), resultListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/result",
            messageType: this.actionName + "Result"
        });
        goalListener.subscribe(function(goalMessage) {
            that.emit("goal", goalMessage);
        }), statusListener.subscribe(function(statusMessage) {
            statusMessage.status_list.forEach(function(status) {
                that.emit("status", status);
            });
        }), feedbackListener.subscribe(function(feedbackMessage) {
            that.emit("status", feedbackMessage.status), that.emit("feedback", feedbackMessage.feedback);
        }), resultListener.subscribe(function(resultMessage) {
            that.emit("status", resultMessage.status), that.emit("result", resultMessage.result);
        });
    }
    var Topic = __webpack_require__(8), EventEmitter2 = (__webpack_require__(6), __webpack_require__(3).EventEmitter2);
    ActionListener.prototype.__proto__ = EventEmitter2.prototype, module.exports = ActionListener;
}, function(module, exports, __webpack_require__) {
    function SimpleActionServer(options) {
        var that = this;
        options = options || {}, this.ros = options.ros, this.serverName = options.serverName,
        this.actionName = options.actionName, this.feedbackPublisher = new Topic({
            ros: this.ros,
            name: this.serverName + "/feedback",
            messageType: this.actionName + "Feedback"
        }), this.feedbackPublisher.advertise();
        var statusPublisher = new Topic({
            ros: this.ros,
            name: this.serverName + "/status",
            messageType: "actionlib_msgs/GoalStatusArray"
        });
        statusPublisher.advertise(), this.resultPublisher = new Topic({
            ros: this.ros,
            name: this.serverName + "/result",
            messageType: this.actionName + "Result"
        }), this.resultPublisher.advertise();
        var goalListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/goal",
            messageType: this.actionName + "Goal"
        }), cancelListener = new Topic({
            ros: this.ros,
            name: this.serverName + "/cancel",
            messageType: "actionlib_msgs/GoalID"
        });
        this.statusMessage = new Message({
            header: {
                stamp: {
                    secs: 0,
                    nsecs: 100
                },
                frame_id: ""
            },
            status_list: []
        }), this.currentGoal = null, this.nextGoal = null, goalListener.subscribe(function(goalMessage) {
            that.currentGoal ? (that.nextGoal = goalMessage, that.emit("cancel")) : (that.statusMessage.status_list = [ {
                goal_id: goalMessage.goal_id,
                status: 1
            } ], that.currentGoal = goalMessage, that.emit("goal", goalMessage.goal));
        });
        var isEarlier = function(t1, t2) {
            return !(t1.secs > t2.secs) && (t1.secs < t2.secs || t1.nsecs < t2.nsecs);
        };
        cancelListener.subscribe(function(cancelMessage) {
            0 === cancelMessage.stamp.secs && 0 === cancelMessage.stamp.secs && "" === cancelMessage.id ? (that.nextGoal = null,
            that.currentGoal && that.emit("cancel")) : (that.currentGoal && cancelMessage.id === that.currentGoal.goal_id.id ? that.emit("cancel") : that.nextGoal && cancelMessage.id === that.nextGoal.goal_id.id && (that.nextGoal = null),
            that.nextGoal && isEarlier(that.nextGoal.goal_id.stamp, cancelMessage.stamp) && (that.nextGoal = null),
            that.currentGoal && isEarlier(that.currentGoal.goal_id.stamp, cancelMessage.stamp) && that.emit("cancel"));
        });
        setInterval(function() {
            var currentTime = new Date(), secs = Math.floor(currentTime.getTime() / 1e3), nsecs = Math.round(1e9 * (currentTime.getTime() / 1e3 - secs));
            that.statusMessage.header.stamp.secs = secs, that.statusMessage.header.stamp.nsecs = nsecs,
            statusPublisher.publish(that.statusMessage);
        }, 500);
    }
    var Topic = __webpack_require__(8), Message = __webpack_require__(6), EventEmitter2 = __webpack_require__(3).EventEmitter2;
    SimpleActionServer.prototype.__proto__ = EventEmitter2.prototype, SimpleActionServer.prototype.setSucceeded = function(result2) {
        var resultMessage = new Message({
            status: {
                goal_id: this.currentGoal.goal_id,
                status: 3
            },
            result: result2
        });
        this.resultPublisher.publish(resultMessage), this.statusMessage.status_list = [],
        this.nextGoal ? (this.currentGoal = this.nextGoal, this.nextGoal = null, this.emit("goal", this.currentGoal.goal)) : this.currentGoal = null;
    }, SimpleActionServer.prototype.sendFeedback = function(feedback2) {
        var feedbackMessage = new Message({
            status: {
                goal_id: this.currentGoal.goal_id,
                status: 1
            },
            feedback: feedback2
        });
        this.feedbackPublisher.publish(feedbackMessage);
    }, SimpleActionServer.prototype.setPreempted = function() {
        this.statusMessage.status_list = [];
        var resultMessage = new Message({
            status: {
                goal_id: this.currentGoal.goal_id,
                status: 2
            }
        });
        this.resultPublisher.publish(resultMessage), this.nextGoal ? (this.currentGoal = this.nextGoal,
        this.nextGoal = null, this.emit("goal", this.currentGoal.goal)) : this.currentGoal = null;
    }, module.exports = SimpleActionServer;
}, function(module, exports, __webpack_require__) {
    module.exports = {
        Pose: __webpack_require__(16),
        Quaternion: __webpack_require__(9),
        Transform: __webpack_require__(25),
        Vector3: __webpack_require__(4)
    };
}, function(module, exports, __webpack_require__) {
    var Ros = __webpack_require__(15);
    __webpack_require__(14)(Ros, [ "TFClient" ], module.exports = {
        TFClient: __webpack_require__(89)
    });
}, function(module, exports, __webpack_require__) {
    function TFClient(options) {
        options = options || {}, this.ros = options.ros, this.fixedFrame = options.fixedFrame || "/base_link",
        this.angularThres = options.angularThres || 2, this.transThres = options.transThres || .01,
        this.rate = options.rate || 10, this.updateDelay = options.updateDelay || 50;
        var seconds = options.topicTimeout || 2, secs = Math.floor(seconds), nsecs = Math.floor(1e9 * (seconds - secs));
        this.topicTimeout = {
            secs: secs,
            nsecs: nsecs
        }, this.serverName = options.serverName || "/tf2_web_republisher", this.repubServiceName = options.repubServiceName || "/republish_tfs",
        this.currentGoal = !1, this.currentTopic = !1, this.frameInfos = {}, this.republisherUpdateRequested = !1,
        this.actionClient = new ActionClient({
            ros: options.ros,
            serverName: this.serverName,
            actionName: "tf2_web_republisher/TFSubscriptionAction",
            omitStatus: !0,
            omitResult: !0
        }), this.serviceClient = new Service({
            ros: options.ros,
            name: this.repubServiceName,
            serviceType: "tf2_web_republisher/RepublishTFs"
        });
    }
    var ActionClient = __webpack_require__(23), Goal = __webpack_require__(24), Service = __webpack_require__(12), ServiceRequest = __webpack_require__(7), Topic = __webpack_require__(8), Transform = __webpack_require__(25);
    TFClient.prototype.processTFArray = function(tf) {
        tf.transforms.forEach(function(transform) {
            var frameID = transform.child_frame_id;
            "/" === frameID[0] && (frameID = frameID.substring(1));
            var info = this.frameInfos[frameID];
            info && (info.transform = new Transform({
                translation: transform.transform.translation,
                rotation: transform.transform.rotation
            }), info.cbs.forEach(function(cb) {
                cb(info.transform);
            }));
        }, this);
    }, TFClient.prototype.updateGoal = function() {
        var goalMessage = {
            source_frames: Object.keys(this.frameInfos),
            target_frame: this.fixedFrame,
            angular_thres: this.angularThres,
            trans_thres: this.transThres,
            rate: this.rate
        };
        if (this.ros.groovyCompatibility) this.currentGoal && this.currentGoal.cancel(),
        this.currentGoal = new Goal({
            actionClient: this.actionClient,
            goalMessage: goalMessage
        }), this.currentGoal.on("feedback", this.processTFArray.bind(this)), this.currentGoal.send(); else {
            goalMessage.timeout = this.topicTimeout;
            var request = new ServiceRequest(goalMessage);
            this.serviceClient.callService(request, this.processResponse.bind(this));
        }
        this.republisherUpdateRequested = !1;
    }, TFClient.prototype.processResponse = function(response) {
        this.currentTopic && this.currentTopic.unsubscribe(), this.currentTopic = new Topic({
            ros: this.ros,
            name: response.topic_name,
            messageType: "tf2_web_republisher/TFArray"
        }), this.currentTopic.subscribe(this.processTFArray.bind(this));
    }, TFClient.prototype.subscribe = function(frameID, callback) {
        "/" === frameID[0] && (frameID = frameID.substring(1)), this.frameInfos[frameID] ? this.frameInfos[frameID].transform && callback(this.frameInfos[frameID].transform) : (this.frameInfos[frameID] = {
            cbs: []
        }, this.republisherUpdateRequested || (setTimeout(this.updateGoal.bind(this), this.updateDelay),
        this.republisherUpdateRequested = !0)), this.frameInfos[frameID].cbs.push(callback);
    }, TFClient.prototype.unsubscribe = function(frameID, callback) {
        "/" === frameID[0] && (frameID = frameID.substring(1));
        for (var info = this.frameInfos[frameID], cbs = info && info.cbs || [], idx = cbs.length; idx--; ) cbs[idx] === callback && cbs.splice(idx, 1);
        callback && 0 !== cbs.length || delete this.frameInfos[frameID];
    }, TFClient.prototype.dispose = function() {
        this.actionClient.dispose(), this.currentTopic && this.currentTopic.unsubscribe();
    }, module.exports = TFClient;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(2)({
        UrdfBox: __webpack_require__(26),
        UrdfColor: __webpack_require__(27),
        UrdfCylinder: __webpack_require__(28),
        UrdfLink: __webpack_require__(29),
        UrdfMaterial: __webpack_require__(17),
        UrdfMesh: __webpack_require__(31),
        UrdfModel: __webpack_require__(91),
        UrdfSphere: __webpack_require__(32),
        UrdfVisual: __webpack_require__(30)
    }, __webpack_require__(10));
}, function(module, exports, __webpack_require__) {
    function UrdfModel(options) {
        options = options || {};
        var xmlDoc = options.xml, string = options.string;
        if (this.materials = {}, this.links = {}, this.joints = {}, string) {
            xmlDoc = new DOMParser().parseFromString(string, "text/xml");
        }
        var robotXml = xmlDoc.documentElement;
        this.name = robotXml.getAttribute("name");
        for (var nodes = robotXml.childNodes, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("material" === node.tagName) {
                var material = new UrdfMaterial({
                    xml: node
                });
                void 0 !== this.materials[material.name] ? this.materials[material.name].isLink() ? this.materials[material.name].assign(material) : console.warn("Material " + material.name + "is not unique.") : this.materials[material.name] = material;
            } else if ("link" === node.tagName) {
                var link = new UrdfLink({
                    xml: node
                });
                if (void 0 !== this.links[link.name]) console.warn("Link " + link.name + " is not unique."); else {
                    for (var j = 0; j < link.visuals.length; j++) {
                        var mat = link.visuals[j].material;
                        null !== mat && (void 0 !== this.materials[mat.name] ? link.visuals[j].material = this.materials[mat.name] : this.materials[mat.name] = mat);
                    }
                    this.links[link.name] = link;
                }
            } else if ("joint" === node.tagName) {
                var joint = new UrdfJoint({
                    xml: node
                });
                this.joints[joint.name] = joint;
            }
        }
    }
    var UrdfMaterial = __webpack_require__(17), UrdfLink = __webpack_require__(29), UrdfJoint = __webpack_require__(92), DOMParser = __webpack_require__(93).DOMParser;
    module.exports = UrdfModel;
}, function(module, exports, __webpack_require__) {
    function UrdfJoint(options) {
        this.name = options.xml.getAttribute("name"), this.type = options.xml.getAttribute("type");
        var parents = options.xml.getElementsByTagName("parent");
        parents.length > 0 && (this.parent = parents[0].getAttribute("link"));
        var children = options.xml.getElementsByTagName("child");
        children.length > 0 && (this.child = children[0].getAttribute("link"));
        var limits = options.xml.getElementsByTagName("limit");
        limits.length > 0 && (this.minval = parseFloat(limits[0].getAttribute("lower")),
        this.maxval = parseFloat(limits[0].getAttribute("upper")));
        var origins = options.xml.getElementsByTagName("origin");
        if (0 === origins.length) this.origin = new Pose(); else {
            var xyz = origins[0].getAttribute("xyz"), position = new Vector3();
            xyz && (xyz = xyz.split(" "), position = new Vector3({
                x: parseFloat(xyz[0]),
                y: parseFloat(xyz[1]),
                z: parseFloat(xyz[2])
            }));
            var rpy = origins[0].getAttribute("rpy"), orientation = new Quaternion();
            if (rpy) {
                rpy = rpy.split(" ");
                var roll = parseFloat(rpy[0]), pitch = parseFloat(rpy[1]), yaw = parseFloat(rpy[2]), phi = roll / 2, the = pitch / 2, psi = yaw / 2, x = Math.sin(phi) * Math.cos(the) * Math.cos(psi) - Math.cos(phi) * Math.sin(the) * Math.sin(psi), y = Math.cos(phi) * Math.sin(the) * Math.cos(psi) + Math.sin(phi) * Math.cos(the) * Math.sin(psi), z = Math.cos(phi) * Math.cos(the) * Math.sin(psi) - Math.sin(phi) * Math.sin(the) * Math.cos(psi), w = Math.cos(phi) * Math.cos(the) * Math.cos(psi) + Math.sin(phi) * Math.sin(the) * Math.sin(psi);
                orientation = new Quaternion({
                    x: x,
                    y: y,
                    z: z,
                    w: w
                }), orientation.normalize();
            }
            this.origin = new Pose({
                position: position,
                orientation: orientation
            });
        }
    }
    var Pose = __webpack_require__(16), Vector3 = __webpack_require__(4), Quaternion = __webpack_require__(9);
    module.exports = UrdfJoint;
}, function(module, exports) {
    exports.DOMImplementation = window.DOMImplementation, exports.XMLSerializer = window.XMLSerializer,
    exports.DOMParser = window.DOMParser;
}, function(module, exports, __webpack_require__) {
    function debounce(func, wait, options) {
        function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
        }
        function leadingEdge(time) {
            return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) return trailingEdge(time);
            timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
            return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0,
            result);
        }
        function cancel() {
            void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
            return void 0 === timerId ? result : trailingEdge(now());
        }
        function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                if (void 0 === timerId) return leadingEdge(lastCallTime);
                if (maxing) return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait),
                invokeFunc(lastCallTime);
            }
            return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
        }
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
        if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
        return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading,
        maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait,
        trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel,
        debounced.flush = flush, debounced;
    }
    var isObject = __webpack_require__(36), now = __webpack_require__(95), toNumber = __webpack_require__(97), FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min;
    module.exports = debounce;
}, function(module, exports, __webpack_require__) {
    var root = __webpack_require__(37), now = function() {
        return root.Date.now();
    };
    module.exports = now;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var freeGlobal = "object" == typeof global && global && global.Object === Object && global;
        module.exports = freeGlobal;
    }).call(exports, __webpack_require__(11));
}, function(module, exports, __webpack_require__) {
    function toNumber(value) {
        if ("number" == typeof value) return value;
        if (isSymbol(value)) return NAN;
        if (isObject(value)) {
            var other = "function" == typeof value.valueOf ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
        }
        if ("string" != typeof value) return 0 === value ? value : +value;
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var isObject = __webpack_require__(36), isSymbol = __webpack_require__(98), NAN = NaN, reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
    module.exports = toNumber;
}, function(module, exports, __webpack_require__) {
    function isSymbol(value) {
        return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var baseGetTag = __webpack_require__(99), isObjectLike = __webpack_require__(102), symbolTag = "[object Symbol]";
    module.exports = isSymbol;
}, function(module, exports, __webpack_require__) {
    function baseGetTag(value) {
        return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    var Symbol = __webpack_require__(38), getRawTag = __webpack_require__(100), objectToString = __webpack_require__(101), nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    module.exports = baseGetTag;
}, function(module, exports, __webpack_require__) {
    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
            value[symToStringTag] = void 0;
            var unmasked = !0;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]),
        result;
    }
    var Symbol = __webpack_require__(38), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    module.exports = getRawTag;
}, function(module, exports) {
    function objectToString(value) {
        return nativeObjectToString.call(value);
    }
    var objectProto = Object.prototype, nativeObjectToString = objectProto.toString;
    module.exports = objectToString;
}, function(module, exports) {
    function isObjectLike(value) {
        return null != value && "object" == typeof value;
    }
    module.exports = isObjectLike;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    for (var propertiesTable = {
        all: [ !0, !1, !1 ],
        base: [ !1, !1, !0 ],
        spindle: [ !0, !0, !0 ],
        left_arm: [ !0, !1, !0 ],
        right_arm: [ !0, !1, !0 ],
        head: [ !1, !1, !1 ]
    }, properties = {}, _i = 0, _Object$keys = Object.keys(propertiesTable); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i], v = propertiesTable[name];
        properties[name] = {
            homeable: v[0],
            homeable_mandatory: v[1],
            resetable: v[2]
        };
    }
    __webpack_exports__.a = properties;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    var __WEBPACK_IMPORTED_MODULE_0_os__ = __webpack_require__(105), __WEBPACK_IMPORTED_MODULE_1_eventemitter2__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_os__),
    __webpack_require__(5)), __WEBPACK_IMPORTED_MODULE_2_roslib__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_eventemitter2__),
    __webpack_require__(1)), __WEBPACK_IMPORTED_MODULE_3__ed_robocup__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_roslib__),
    __webpack_require__(106)), __WEBPACK_IMPORTED_MODULE_4__hardware__ = __webpack_require__(35), __WEBPACK_IMPORTED_MODULE_5__head__ = __webpack_require__(39), __WEBPACK_IMPORTED_MODULE_6__base__ = __webpack_require__(33), __WEBPACK_IMPORTED_MODULE_7__body__ = __webpack_require__(109), __WEBPACK_IMPORTED_MODULE_8__speech__ = __webpack_require__(110), __WEBPACK_IMPORTED_MODULE_9__action_server__ = __webpack_require__(20), host = Object(__WEBPACK_IMPORTED_MODULE_0_os__.hostname)() || "localhost", defaultUrl = "ws://".concat(host, ":9090"), RECONNECT_TIMEOUT = 5e3, Robot = function(_EventEmitter) {
        function Robot() {
            var _this, modules = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return _classCallCheck(this, Robot), _this = _super.call(this), _this.ros = new __WEBPACK_IMPORTED_MODULE_2_roslib__.Ros({
                encoding: "ascii"
            }), _this.ros.on("connection", _this.onConnection.bind(_assertThisInitialized(_this))),
            _this.ros.on("close", _this.onClose.bind(_assertThisInitialized(_this))), _this.ros.on("error", _this.onError.bind(_assertThisInitialized(_this))),
            _this.on("status", function(status) {
                switch (status) {
                  case "closed":
                    setTimeout(this.connect.bind(this), RECONNECT_TIMEOUT);
                }
            }), console.log("Creating a robot with the following settings:", modules), "ed" in modules && (_this.ed = new __WEBPACK_IMPORTED_MODULE_3__ed_robocup__.a(_assertThisInitialized(_this))),
            "hardware" in modules && (_this.hardware = new __WEBPACK_IMPORTED_MODULE_4__hardware__.a(_assertThisInitialized(_this))),
            "head" in modules && (_this.head = new __WEBPACK_IMPORTED_MODULE_5__head__.a(_assertThisInitialized(_this))),
            "base" in modules && (_this.base = new __WEBPACK_IMPORTED_MODULE_6__base__.a(_assertThisInitialized(_this))),
            "body" in modules && (_this.body = new __WEBPACK_IMPORTED_MODULE_7__body__.a(_assertThisInitialized(_this))),
            "speech" in modules && (_this.speech = new __WEBPACK_IMPORTED_MODULE_8__speech__.a(_assertThisInitialized(_this))),
            "actionServer" in modules && (_this.actionServer = new __WEBPACK_IMPORTED_MODULE_9__action_server__.a(_assertThisInitialized(_this))),
            _this;
        }
        _inherits(Robot, _EventEmitter);
        var _super = _createSuper(Robot);
        return _createClass(Robot, [ {
            key: "connect",
            value: function(url) {
                this.url = url || this.url || defaultUrl, console.log("connecting to ".concat(this.url)),
                this.ros.connect(this.url), this.status = "connecting";
            }
        }, {
            key: "onConnection",
            value: function() {
                console.log("connection"), this.status = "connected";
            }
        }, {
            key: "onClose",
            value: function() {
                console.log("connection closed"), this.status = "closed";
            }
        }, {
            key: "onError",
            value: function() {
                this.status = "error";
            }
        }, {
            key: "status",
            get: function() {
                return this._status;
            },
            set: function(value) {
                this._status = value, this.emit("status", value);
            }
        } ]), Robot;
    }(__WEBPACK_IMPORTED_MODULE_1_eventemitter2__.EventEmitter2);
    __webpack_exports__.a = Robot;
}, function(module, exports) {
    exports.endianness = function() {
        return "LE";
    }, exports.hostname = function() {
        return "undefined" != typeof location ? location.hostname : "";
    }, exports.loadavg = function() {
        return [];
    }, exports.uptime = function() {
        return 0;
    }, exports.freemem = function() {
        return Number.MAX_VALUE;
    }, exports.totalmem = function() {
        return Number.MAX_VALUE;
    }, exports.cpus = function() {
        return [];
    }, exports.type = function() {
        return "Browser";
    }, exports.release = function() {
        return "undefined" != typeof navigator ? navigator.appVersion : "";
    }, exports.networkInterfaces = exports.getNetworkInterfaces = function() {
        return {};
    }, exports.arch = function() {
        return "javascript";
    }, exports.platform = function() {
        return "browser";
    }, exports.tmpdir = exports.tmpDir = function() {
        return "/tmp";
    }, exports.EOL = "\n", exports.homedir = function() {
        return "/";
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" == typeof o.length) {
                it && (o = it);
                var i = 0, F = function() {};
                return {
                    s: F,
                    n: function() {
                        return i >= o.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: o[i++]
                        };
                    },
                    e: function(_e) {
                        throw _e;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var err, normalCompletion = !0, didErr = !1;
        return {
            s: function() {
                it = o[Symbol.iterator]();
            },
            n: function() {
                var step = it.next();
                return normalCompletion = step.done, step;
            },
            e: function(_e2) {
                didErr = !0, err = _e2;
            },
            f: function() {
                try {
                    normalCompletion || null == it.return || it.return();
                } finally {
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (o) {
            if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
        }
    }
    function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function() {
            var result, Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0;
        } catch (e) {
            return !1;
        }
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return EdRobocup;
    });
    var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(107), __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__), __WEBPACK_IMPORTED_MODULE_1__ed__ = __webpack_require__(34), NAVIGATE_TYPES = {
        NAVIGATE_TO_PIXEL: 1,
        TURN_LEFT: 2,
        TURN_RIGHT: 3
    }, EdRobocup = function(_Ed) {
        function EdRobocup(robot) {
            var _this;
            _classCallCheck(this, EdRobocup), _this = _super.call(this, robot), _defineProperty(_assertThisInitialized(_this), "updateModels", function() {
                var request = {};
                _this.modelsService.callService(request, function(response) {
                    var _step, _iterator = _createForOfIteratorHelper(response.models);
                    try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                            var model = _step.value, name = model.name, encoding = model.encoding, data = model.data;
                            _this.models[name] = {
                                src: "data:image/".concat(encoding, ";base64,").concat(data)
                            };
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally {
                        _iterator.f();
                    }
                    _this.emit("models", _this.models);
                }, function(message) {
                    console.warn("update models failed:", message), __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.delay(_this.updateModels, 5e3);
                });
            });
            var ros = robot.ros;
            return _this.models = {}, _this.modelsService = ros.Service({
                name: "ed/get_model_images",
                serviceType: "ed_robocup_msgs/GetModelImages"
            }), _this.updateModels(), _this.fitModelService = ros.Service({
                name: "ed/fit_entity_in_image",
                serviceType: "ed_robocup_msgs/FitEntityInImage"
            }), _this.navigateToService = ros.Service({
                name: "ed/navigate_to",
                serviceType: "ed_sensor_integration_msgs/NavigateTo"
            }), _this.createWallsService = ros.Service({
                name: "ed/create_walls",
                serviceType: "std_srvs/Empty"
            }), _this;
        }
        _inherits(EdRobocup, _Ed);
        var _super = _createSuper(EdRobocup);
        return _createClass(EdRobocup, [ {
            key: "fit_model",
            value: function(model_name, px, py) {
                var request = {
                    entity_type: model_name,
                    px: px,
                    py: py
                };
                this.fitModelService.callService(request, function(response) {
                    var error_msg = response.error_msg;
                    error_msg && console.warn("fit model error:", error_msg);
                });
            }
        }, {
            key: "undo_fit_model",
            value: function(callback) {
                var request = {
                    undo_latest_fit: !0
                };
                this.fitModelService.callService(request, function(response) {
                    var error_msg = response.error_msg;
                    error_msg ? (console.warn("fit model error:", error_msg), callback(error_msg)) : callback(null);
                }, function(err) {
                    console.warn("fit model error:", err), callback(err);
                });
            }
        }, {
            key: "navigate_to",
            value: function(x, y, snapshot_id) {
                this.navigateToService.callService({
                    snapshot_id: snapshot_id,
                    navigation_type: NAVIGATE_TYPES.NAVIGATE_TO_PIXEL,
                    click_x_ratio: x,
                    click_y_ratio: y
                }, function(result) {
                    var error_msg = result.error_msg;
                    error_msg && console.warn(error_msg);
                });
            }
        }, {
            key: "create_walls",
            value: function(callback) {
                callback = callback || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.noop, this.createWallsService.callService({}, function() {
                    callback();
                });
            }
        } ]), EdRobocup;
    }(__WEBPACK_IMPORTED_MODULE_1__ed__.a);
}, function(module, exports, __webpack_require__) {
    (function(global, module) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        (function() {
            function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);

                  case 1:
                    return func.call(thisArg, args[0]);

                  case 2:
                    return func.call(thisArg, args[0], args[1]);

                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
            }
            function arrayAggregator(array, setter, iteratee, accumulator) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
                    var value = array[index];
                    setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
            }
            function arrayEach(array, iteratee) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array); ) ;
                return array;
            }
            function arrayEachRight(array, iteratee) {
                for (var length = null == array ? 0 : array.length; length-- && !1 !== iteratee(array[length], length, array); ) ;
                return array;
            }
            function arrayEvery(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (!predicate(array[index], index, array)) return !1;
                return !0;
            }
            function arrayFilter(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                    var value = array[index];
                    predicate(value, index, array) && (result[resIndex++] = value);
                }
                return result;
            }
            function arrayIncludes(array, value) {
                return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
            }
            function arrayIncludesWith(array, value, comparator) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (comparator(value, array[index])) return !0;
                return !1;
            }
            function arrayMap(array, iteratee) {
                for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
                return result;
            }
            function arrayPush(array, values) {
                for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
                return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1, length = null == array ? 0 : array.length;
                for (initAccum && length && (accumulator = array[++index]); ++index < length; ) accumulator = iteratee(accumulator, array[index], index, array);
                return accumulator;
            }
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                var length = null == array ? 0 : array.length;
                for (initAccum && length && (accumulator = array[--length]); length--; ) accumulator = iteratee(accumulator, array[length], length, array);
                return accumulator;
            }
            function arraySome(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
                return !1;
            }
            function asciiToArray(string) {
                return string.split("");
            }
            function asciiWords(string) {
                return string.match(reAsciiWord) || [];
            }
            function baseFindKey(collection, predicate, eachFunc) {
                var result;
                return eachFunc(collection, function(value, key, collection) {
                    if (predicate(value, key, collection)) return result = key, !1;
                }), result;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
                for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
                return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            function baseIndexOfWith(array, value, fromIndex, comparator) {
                for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (comparator(array[index], value)) return index;
                return -1;
            }
            function baseIsNaN(value) {
                return value !== value;
            }
            function baseMean(array, iteratee) {
                var length = null == array ? 0 : array.length;
                return length ? baseSum(array, iteratee) / length : NAN;
            }
            function baseProperty(key) {
                return function(object) {
                    return null == object ? undefined : object[key];
                };
            }
            function basePropertyOf(object) {
                return function(key) {
                    return null == object ? undefined : object[key];
                };
            }
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                return eachFunc(collection, function(value, index, collection) {
                    accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection);
                }), accumulator;
            }
            function baseSortBy(array, comparer) {
                var length = array.length;
                for (array.sort(comparer); length--; ) array[length] = array[length].value;
                return array;
            }
            function baseSum(array, iteratee) {
                for (var result, index = -1, length = array.length; ++index < length; ) {
                    var current = iteratee(array[index]);
                    current !== undefined && (result = result === undefined ? current : result + current);
                }
                return result;
            }
            function baseTimes(n, iteratee) {
                for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
                return result;
            }
            function baseToPairs(object, props) {
                return arrayMap(props, function(key) {
                    return [ key, object[key] ];
                });
            }
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            function baseValues(object, props) {
                return arrayMap(props, function(key) {
                    return object[key];
                });
            }
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            function charsStartIndex(strSymbols, chrSymbols) {
                for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
                return index;
            }
            function charsEndIndex(strSymbols, chrSymbols) {
                for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
                return index;
            }
            function countHolders(array, placeholder) {
                for (var length = array.length, result = 0; length--; ) array[length] === placeholder && ++result;
                return result;
            }
            function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
            }
            function getValue(object, key) {
                return null == object ? undefined : object[key];
            }
            function hasUnicode(string) {
                return reHasUnicode.test(string);
            }
            function hasUnicodeWord(string) {
                return reHasUnicodeWord.test(string);
            }
            function iteratorToArray(iterator) {
                for (var data, result = []; !(data = iterator.next()).done; ) result.push(data.value);
                return result;
            }
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                return map.forEach(function(value, key) {
                    result[++index] = [ key, value ];
                }), result;
            }
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            function replaceHolders(array, placeholder) {
                for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                    var value = array[index];
                    value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index);
                }
                return result;
            }
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                return set.forEach(function(value) {
                    result[++index] = value;
                }), result;
            }
            function setToPairs(set) {
                var index = -1, result = Array(set.size);
                return set.forEach(function(value) {
                    result[++index] = [ value, value ];
                }), result;
            }
            function strictIndexOf(array, value, fromIndex) {
                for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
                return -1;
            }
            function strictLastIndexOf(array, value, fromIndex) {
                for (var index = fromIndex + 1; index--; ) if (array[index] === value) return index;
                return index;
            }
            function stringSize(string) {
                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
            }
            function stringToArray(string) {
                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            function unicodeSize(string) {
                for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); ) ++result;
                return result;
            }
            function unicodeToArray(string) {
                return string.match(reUnicode) || [];
            }
            function unicodeWords(string) {
                return string.match(reUnicodeWord) || [];
            }
            var undefined, LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [ [ "ary", WRAP_ARY_FLAG ], [ "bind", WRAP_BIND_FLAG ], [ "bindKey", WRAP_BIND_KEY_FLAG ], [ "curry", WRAP_CURRY_FLAG ], [ "curryRight", WRAP_CURRY_RIGHT_FLAG ], [ "flip", WRAP_FLIP_FLAG ], [ "partial", WRAP_PARTIAL_FLAG ], [ "partialRight", WRAP_PARTIAL_RIGHT_FLAG ], [ "rearg", WRAP_REARG_FLAG ] ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]", rsMisc = "[^\\ud800-\\udfff" + rsBreakRange + "\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", reOptMod = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?", rsOptJoin = "(?:\\u200d(?:" + [ "[^\\ud800-\\udfff]", rsRegional, rsSurrPair ].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*", rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ "[\\u2700-\\u27bf]", rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ "[^\\ud800-\\udfff]" + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, "[\\ud800-\\udfff]" ].join("|") + ")", reApos = RegExp("[']", "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([ rsUpper + "?" + rsLower + "+(?:['](?:d|ll|m|re|s|t|ve))?(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", "(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=" + [ rsBreak, rsUpper + rsMiscLower, "$" ].join("|") + ")", rsUpper + "?" + rsMiscLower + "+(?:['](?:d|ll|m|re|s|t|ve))?", rsUpper + "+(?:['](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", rsEmoji ].join("|"), "g"), reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff" + rsComboRange + "\\ufe0e\\ufe0f]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ], templateCounter = -1, typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0,
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0,
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
            var deburredLetters = {
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "c",
                "": "D",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "N",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "Y",
                "": "y",
                "": "y",
                "": "Ae",
                "": "ae",
                "": "Th",
                "": "th",
                "": "ss",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "J",
                "": "j",
                "": "K",
                "": "k",
                "": "k",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "t",
                "": "t",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "W",
                "": "w",
                "": "Y",
                "": "y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "z",
                "": "IJ",
                "": "ij",
                "": "Oe",
                "": "oe",
                "": "'n",
                "": "s"
            }, htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            }, htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            }, stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
                try {
                    var types = freeModule && freeModule.require && freeModule.require("util").types;
                    return types || freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, asciiSize = baseProperty("length"), deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes), unescapeHtmlChar = basePropertyOf(htmlUnescapes), _ = function runInContext(context) {
                function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                        if (value instanceof LodashWrapper) return value;
                        if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
                    }
                    return new LodashWrapper(value);
                }
                function baseLodash() {}
                function LodashWrapper(value, chainAll) {
                    this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0,
                    this.__values__ = undefined;
                }
                function LazyWrapper(value) {
                    this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1,
                    this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
                }
                function lazyClone() {
                    var result = new LazyWrapper(this.__wrapped__);
                    return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__,
                    result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__),
                    result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__),
                    result;
                }
                function lazyReverse() {
                    if (this.__filtered__) {
                        var result = new LazyWrapper(this);
                        result.__dir__ = -1, result.__filtered__ = !0;
                    } else result = this.clone(), result.__dir__ *= -1;
                    return result;
                }
                function lazyValue() {
                    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                    if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
                    var result = [];
                    outer: for (;length-- && resIndex < takeCount; ) {
                        index += dir;
                        for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
                            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                            if (type == LAZY_MAP_FLAG) value = computed; else if (!computed) {
                                if (type == LAZY_FILTER_FLAG) continue outer;
                                break outer;
                            }
                        }
                        result[resIndex++] = value;
                    }
                    return result;
                }
                function Hash(entries) {
                    var index = -1, length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length; ) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
                }
                function hashDelete(key) {
                    var result = this.has(key) && delete this.__data__[key];
                    return this.size -= result ? 1 : 0, result;
                }
                function hashGet(key) {
                    var data = this.__data__;
                    if (nativeCreate) {
                        var result = data[key];
                        return result === HASH_UNDEFINED ? undefined : result;
                    }
                    return hasOwnProperty.call(data, key) ? data[key] : undefined;
                }
                function hashHas(key) {
                    var data = this.__data__;
                    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
                }
                function hashSet(key, value) {
                    var data = this.__data__;
                    return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value,
                    this;
                }
                function ListCache(entries) {
                    var index = -1, length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length; ) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                function listCacheClear() {
                    this.__data__ = [], this.size = 0;
                }
                function listCacheDelete(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1),
                    --this.size, !0);
                }
                function listCacheGet(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    return index < 0 ? undefined : data[index][1];
                }
                function listCacheHas(key) {
                    return assocIndexOf(this.__data__, key) > -1;
                }
                function listCacheSet(key, value) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value,
                    this;
                }
                function MapCache(entries) {
                    var index = -1, length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length; ) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                function mapCacheClear() {
                    this.size = 0, this.__data__ = {
                        hash: new Hash(),
                        map: new (Map || ListCache)(),
                        string: new Hash()
                    };
                }
                function mapCacheDelete(key) {
                    var result = getMapData(this, key).delete(key);
                    return this.size -= result ? 1 : 0, result;
                }
                function mapCacheGet(key) {
                    return getMapData(this, key).get(key);
                }
                function mapCacheHas(key) {
                    return getMapData(this, key).has(key);
                }
                function mapCacheSet(key, value) {
                    var data = getMapData(this, key), size = data.size;
                    return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
                }
                function SetCache(values) {
                    var index = -1, length = null == values ? 0 : values.length;
                    for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
                }
                function setCacheAdd(value) {
                    return this.__data__.set(value, HASH_UNDEFINED), this;
                }
                function setCacheHas(value) {
                    return this.__data__.has(value);
                }
                function Stack(entries) {
                    var data = this.__data__ = new ListCache(entries);
                    this.size = data.size;
                }
                function stackClear() {
                    this.__data__ = new ListCache(), this.size = 0;
                }
                function stackDelete(key) {
                    var data = this.__data__, result = data.delete(key);
                    return this.size = data.size, result;
                }
                function stackGet(key) {
                    return this.__data__.get(key);
                }
                function stackHas(key) {
                    return this.__data__.has(key);
                }
                function stackSet(key, value) {
                    var data = this.__data__;
                    if (data instanceof ListCache) {
                        var pairs = data.__data__;
                        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]),
                        this.size = ++data.size, this;
                        data = this.__data__ = new MapCache(pairs);
                    }
                    return data.set(key, value), this.size = data.size, this;
                }
                function arrayLikeKeys(value, inherited) {
                    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                    for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
                    return result;
                }
                function arraySample(array) {
                    var length = array.length;
                    return length ? array[baseRandom(0, length - 1)] : undefined;
                }
                function arraySampleSize(array, n) {
                    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                }
                function arrayShuffle(array) {
                    return shuffleSelf(copyArray(array));
                }
                function assignMergeValue(object, key, value) {
                    (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
                }
                function assignValue(object, key, value) {
                    var objValue = object[key];
                    hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
                }
                function assocIndexOf(array, key) {
                    for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
                    return -1;
                }
                function baseAggregator(collection, setter, iteratee, accumulator) {
                    return baseEach(collection, function(value, key, collection) {
                        setter(accumulator, value, iteratee(value), collection);
                    }), accumulator;
                }
                function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object);
                }
                function baseAssignIn(object, source) {
                    return object && copyObject(source, keysIn(source), object);
                }
                function baseAssignValue(object, key, value) {
                    "__proto__" == key && defineProperty ? defineProperty(object, key, {
                        configurable: !0,
                        enumerable: !0,
                        value: value,
                        writable: !0
                    }) : object[key] = value;
                }
                function baseAt(object, paths) {
                    for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length; ) result[index] = skip ? undefined : get(object, paths[index]);
                    return result;
                }
                function baseClamp(number, lower, upper) {
                    return number === number && (upper !== undefined && (number = number <= upper ? number : upper),
                    lower !== undefined && (number = number >= lower ? number : lower)), number;
                }
                function baseClone(value, bitmask, customizer, key, object, stack) {
                    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                    if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)),
                    result !== undefined) return result;
                    if (!isObject(value)) return value;
                    var isArr = isArray(value);
                    if (isArr) {
                        if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
                    } else {
                        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                        if (isBuffer(value)) return cloneBuffer(value, isDeep);
                        if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                        } else {
                            if (!cloneableTags[tag]) return object ? value : {};
                            result = initCloneByTag(value, tag, isDeep);
                        }
                    }
                    stack || (stack = new Stack());
                    var stacked = stack.get(value);
                    if (stacked) return stacked;
                    stack.set(value, result), isSet(value) ? value.forEach(function(subValue) {
                        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                    }) : isMap(value) && value.forEach(function(subValue, key) {
                        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                    });
                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined : keysFunc(value);
                    return arrayEach(props || value, function(subValue, key) {
                        props && (key = subValue, subValue = value[key]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                    }), result;
                }
                function baseConforms(source) {
                    var props = keys(source);
                    return function(object) {
                        return baseConformsTo(object, source, props);
                    };
                }
                function baseConformsTo(object, source, props) {
                    var length = props.length;
                    if (null == object) return !length;
                    for (object = Object(object); length--; ) {
                        var key = props[length], predicate = source[key], value = object[key];
                        if (value === undefined && !(key in object) || !predicate(value)) return !1;
                    }
                    return !0;
                }
                function baseDelay(func, wait, args) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return setTimeout(function() {
                        func.apply(undefined, args);
                    }, wait);
                }
                function baseDifference(array, values, iteratee, comparator) {
                    var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
                    if (!length) return result;
                    iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith,
                    isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1,
                    values = new SetCache(values));
                    outer: for (;++index < length; ) {
                        var value = array[index], computed = null == iteratee ? value : iteratee(value);
                        if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                            for (var valuesIndex = valuesLength; valuesIndex--; ) if (values[valuesIndex] === computed) continue outer;
                            result.push(value);
                        } else includes(values, computed, comparator) || result.push(value);
                    }
                    return result;
                }
                function baseEvery(collection, predicate) {
                    var result = !0;
                    return baseEach(collection, function(value, index, collection) {
                        return result = !!predicate(value, index, collection);
                    }), result;
                }
                function baseExtremum(array, iteratee, comparator) {
                    for (var index = -1, length = array.length; ++index < length; ) {
                        var value = array[index], current = iteratee(value);
                        if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
                    }
                    return result;
                }
                function baseFill(array, value, start, end) {
                    var length = array.length;
                    for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start),
                    end = end === undefined || end > length ? length : toInteger(end), end < 0 && (end += length),
                    end = start > end ? 0 : toLength(end); start < end; ) array[start++] = value;
                    return array;
                }
                function baseFilter(collection, predicate) {
                    var result = [];
                    return baseEach(collection, function(value, index, collection) {
                        predicate(value, index, collection) && result.push(value);
                    }), result;
                }
                function baseFlatten(array, depth, predicate, isStrict, result) {
                    var index = -1, length = array.length;
                    for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
                        var value = array[index];
                        depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
                    }
                    return result;
                }
                function baseForOwn(object, iteratee) {
                    return object && baseFor(object, iteratee, keys);
                }
                function baseForOwnRight(object, iteratee) {
                    return object && baseForRight(object, iteratee, keys);
                }
                function baseFunctions(object, props) {
                    return arrayFilter(props, function(key) {
                        return isFunction(object[key]);
                    });
                }
                function baseGet(object, path) {
                    path = castPath(path, object);
                    for (var index = 0, length = path.length; null != object && index < length; ) object = object[toKey(path[index++])];
                    return index && index == length ? object : undefined;
                }
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                }
                function baseGetTag(value) {
                    return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
                }
                function baseGt(value, other) {
                    return value > other;
                }
                function baseHas(object, key) {
                    return null != object && hasOwnProperty.call(object, key);
                }
                function baseHasIn(object, key) {
                    return null != object && key in Object(object);
                }
                function baseInRange(number, start, end) {
                    return number >= nativeMin(start, end) && number < nativeMax(start, end);
                }
                function baseIntersection(arrays, iteratee, comparator) {
                    for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
                        var array = arrays[othIndex];
                        othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength),
                        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
                    }
                    array = arrays[0];
                    var index = -1, seen = caches[0];
                    outer: for (;++index < length && result.length < maxLength; ) {
                        var value = array[index], computed = iteratee ? iteratee(value) : value;
                        if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                            for (othIndex = othLength; --othIndex; ) {
                                var cache = caches[othIndex];
                                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
                            }
                            seen && seen.push(computed), result.push(value);
                        }
                    }
                    return result;
                }
                function baseInverter(object, setter, iteratee, accumulator) {
                    return baseForOwn(object, function(value, key, object) {
                        setter(accumulator, iteratee(value), key, object);
                    }), accumulator;
                }
                function baseInvoke(object, path, args) {
                    path = castPath(path, object), object = parent(object, path);
                    var func = null == object ? object : object[toKey(last(path))];
                    return null == func ? undefined : apply(func, object, args);
                }
                function baseIsArguments(value) {
                    return isObjectLike(value) && baseGetTag(value) == argsTag;
                }
                function baseIsArrayBuffer(value) {
                    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                }
                function baseIsDate(value) {
                    return isObjectLike(value) && baseGetTag(value) == dateTag;
                }
                function baseIsEqual(value, other, bitmask, customizer, stack) {
                    return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack));
                }
                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                    objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                    if (isSameTag && isBuffer(object)) {
                        if (!isBuffer(other)) return !1;
                        objIsArr = !0, objIsObj = !1;
                    }
                    if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                            return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                        }
                    }
                    return !!isSameTag && (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack));
                }
                function baseIsMap(value) {
                    return isObjectLike(value) && getTag(value) == mapTag;
                }
                function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length, length = index, noCustomizer = !customizer;
                    if (null == object) return !length;
                    for (object = Object(object); index--; ) {
                        var data = matchData[index];
                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1;
                    }
                    for (;++index < length; ) {
                        data = matchData[index];
                        var key = data[0], objValue = object[key], srcValue = data[1];
                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) return !1;
                        } else {
                            var stack = new Stack();
                            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                            if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return !1;
                        }
                    }
                    return !0;
                }
                function baseIsNative(value) {
                    return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
                }
                function baseIsRegExp(value) {
                    return isObjectLike(value) && baseGetTag(value) == regexpTag;
                }
                function baseIsSet(value) {
                    return isObjectLike(value) && getTag(value) == setTag;
                }
                function baseIsTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                }
                function baseIteratee(value) {
                    return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
                }
                function baseKeys(object) {
                    if (!isPrototype(object)) return nativeKeys(object);
                    var result = [];
                    for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                    return result;
                }
                function baseKeysIn(object) {
                    if (!isObject(object)) return nativeKeysIn(object);
                    var isProto = isPrototype(object), result = [];
                    for (var key in object) ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
                    return result;
                }
                function baseLt(value, other) {
                    return value < other;
                }
                function baseMap(collection, iteratee) {
                    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                    return baseEach(collection, function(value, key, collection) {
                        result[++index] = iteratee(value, key, collection);
                    }), result;
                }
                function baseMatches(source) {
                    var matchData = getMatchData(source);
                    return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                        return object === source || baseIsMatch(object, source, matchData);
                    };
                }
                function baseMatchesProperty(path, srcValue) {
                    return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                        var objValue = get(object, path);
                        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                    };
                }
                function baseMerge(object, source, srcIndex, customizer, stack) {
                    object !== source && baseFor(source, function(srcValue, key) {
                        if (stack || (stack = new Stack()), isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                            newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue);
                        }
                    }, keysIn);
                }
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                    if (stacked) return void assignMergeValue(object, key, stacked);
                    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined, isCommon = newValue === undefined;
                    if (isCommon) {
                        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                        newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1,
                        newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue,
                        isArguments(objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue))) : isCommon = !1;
                    }
                    isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack),
                    stack.delete(srcValue)), assignMergeValue(object, key, newValue);
                }
                function baseNth(array, n) {
                    var length = array.length;
                    if (length) return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined;
                }
                function baseOrderBy(collection, iteratees, orders) {
                    iteratees = iteratees.length ? arrayMap(iteratees, function(iteratee) {
                        return isArray(iteratee) ? function(value) {
                            return baseGet(value, 1 === iteratee.length ? iteratee[0] : iteratee);
                        } : iteratee;
                    }) : [ identity ];
                    var index = -1;
                    return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseSortBy(baseMap(collection, function(value, key, collection) {
                        return {
                            criteria: arrayMap(iteratees, function(iteratee) {
                                return iteratee(value);
                            }),
                            index: ++index,
                            value: value
                        };
                    }), function(object, other) {
                        return compareMultiple(object, other, orders);
                    });
                }
                function basePick(object, paths) {
                    return basePickBy(object, paths, function(value, path) {
                        return hasIn(object, path);
                    });
                }
                function basePickBy(object, paths, predicate) {
                    for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
                        var path = paths[index], value = baseGet(object, path);
                        predicate(value, path) && baseSet(result, castPath(path, object), value);
                    }
                    return result;
                }
                function basePropertyDeep(path) {
                    return function(object) {
                        return baseGet(object, path);
                    };
                }
                function basePullAll(array, values, iteratee, comparator) {
                    var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                    for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length; ) for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; ) seen !== array && splice.call(seen, fromIndex, 1),
                    splice.call(array, fromIndex, 1);
                    return array;
                }
                function basePullAt(array, indexes) {
                    for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
                        var index = indexes[length];
                        if (length == lastIndex || index !== previous) {
                            var previous = index;
                            isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
                        }
                    }
                    return array;
                }
                function baseRandom(lower, upper) {
                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                }
                function baseRange(start, end, step, fromRight) {
                    for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; ) result[fromRight ? length : ++index] = start,
                    start += step;
                    return result;
                }
                function baseRepeat(string, n) {
                    var result = "";
                    if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
                    do {
                        n % 2 && (result += string), (n = nativeFloor(n / 2)) && (string += string);
                    } while (n);
                    return result;
                }
                function baseRest(func, start) {
                    return setToString(overRest(func, start, identity), func + "");
                }
                function baseSample(collection) {
                    return arraySample(values(collection));
                }
                function baseSampleSize(collection, n) {
                    var array = values(collection);
                    return shuffleSelf(array, baseClamp(n, 0, array.length));
                }
                function baseSet(object, path, value, customizer) {
                    if (!isObject(object)) return object;
                    path = castPath(path, object);
                    for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length; ) {
                        var key = toKey(path[index]), newValue = value;
                        if ("__proto__" === key || "constructor" === key || "prototype" === key) return object;
                        if (index != lastIndex) {
                            var objValue = nested[key];
                            newValue = customizer ? customizer(objValue, key, nested) : undefined, newValue === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {});
                        }
                        assignValue(nested, key, newValue), nested = nested[key];
                    }
                    return object;
                }
                function baseShuffle(collection) {
                    return shuffleSelf(values(collection));
                }
                function baseSlice(array, start, end) {
                    var index = -1, length = array.length;
                    start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end,
                    end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
                    for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
                    return result;
                }
                function baseSome(collection, predicate) {
                    var result;
                    return baseEach(collection, function(value, index, collection) {
                        return !(result = predicate(value, index, collection));
                    }), !!result;
                }
                function baseSortedIndex(array, value, retHighest) {
                    var low = 0, high = null == array ? low : array.length;
                    if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                        for (;low < high; ) {
                            var mid = low + high >>> 1, computed = array[mid];
                            null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
                        }
                        return high;
                    }
                    return baseSortedIndexBy(array, value, identity, retHighest);
                }
                function baseSortedIndexBy(array, value, iteratee, retHighest) {
                    var low = 0, high = null == array ? 0 : array.length;
                    if (0 === high) return 0;
                    value = iteratee(value);
                    for (var valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; low < high; ) {
                        var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = null === computed, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                        if (valIsNaN) var setLow = retHighest || othIsReflexive; else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
                        setLow ? low = mid + 1 : high = mid;
                    }
                    return nativeMin(high, MAX_ARRAY_INDEX);
                }
                function baseSortedUniq(array, iteratee) {
                    for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                        var value = array[index], computed = iteratee ? iteratee(value) : value;
                        if (!index || !eq(computed, seen)) {
                            var seen = computed;
                            result[resIndex++] = 0 === value ? 0 : value;
                        }
                    }
                    return result;
                }
                function baseToNumber(value) {
                    return "number" == typeof value ? value : isSymbol(value) ? NAN : +value;
                }
                function baseToString(value) {
                    if ("string" == typeof value) return value;
                    if (isArray(value)) return arrayMap(value, baseToString) + "";
                    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
                    var result = value + "";
                    return "0" == result && 1 / value == -INFINITY ? "-0" : result;
                }
                function baseUniq(array, iteratee, comparator) {
                    var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
                    if (comparator) isCommon = !1, includes = arrayIncludesWith; else if (length >= LARGE_ARRAY_SIZE) {
                        var set = iteratee ? null : createSet(array);
                        if (set) return setToArray(set);
                        isCommon = !1, includes = cacheHas, seen = new SetCache();
                    } else seen = iteratee ? [] : result;
                    outer: for (;++index < length; ) {
                        var value = array[index], computed = iteratee ? iteratee(value) : value;
                        if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                            for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
                            iteratee && seen.push(computed), result.push(value);
                        } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed),
                        result.push(value));
                    }
                    return result;
                }
                function baseUnset(object, path) {
                    return path = castPath(path, object), null == (object = parent(object, path)) || delete object[toKey(last(path))];
                }
                function baseUpdate(object, path, updater, customizer) {
                    return baseSet(object, path, updater(baseGet(object, path)), customizer);
                }
                function baseWhile(array, predicate, isDrop, fromRight) {
                    for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); ) ;
                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                }
                function baseWrapperValue(value, actions) {
                    var result = value;
                    return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function(result, action) {
                        return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
                    }, result);
                }
                function baseXor(arrays, iteratee, comparator) {
                    var length = arrays.length;
                    if (length < 2) return length ? baseUniq(arrays[0]) : [];
                    for (var index = -1, result = Array(length); ++index < length; ) for (var array = arrays[index], othIndex = -1; ++othIndex < length; ) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
                    return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                }
                function baseZipObject(props, values, assignFunc) {
                    for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length; ) {
                        var value = index < valsLength ? values[index] : undefined;
                        assignFunc(result, props[index], value);
                    }
                    return result;
                }
                function castArrayLikeObject(value) {
                    return isArrayLikeObject(value) ? value : [];
                }
                function castFunction(value) {
                    return "function" == typeof value ? value : identity;
                }
                function castPath(value, object) {
                    return isArray(value) ? value : isKey(value, object) ? [ value ] : stringToPath(toString(value));
                }
                function castSlice(array, start, end) {
                    var length = array.length;
                    return end = end === undefined ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
                }
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) return buffer.slice();
                    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                    return buffer.copy(result), result;
                }
                function cloneArrayBuffer(arrayBuffer) {
                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
                }
                function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }
                function cloneRegExp(regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    return result.lastIndex = regexp.lastIndex, result;
                }
                function cloneSymbol(symbol) {
                    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                }
                function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }
                function compareAscending(value, other) {
                    if (value !== other) {
                        var valIsDefined = value !== undefined, valIsNull = null === value, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined, othIsNull = null === other, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
                    }
                    return 0;
                }
                function compareMultiple(object, other, orders) {
                    for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
                        var result = compareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) return result;
                            return result * ("desc" == orders[index] ? -1 : 1);
                        }
                    }
                    return object.index - other.index;
                }
                function composeArgs(args, partials, holders, isCurried) {
                    for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; ) result[leftIndex] = partials[leftIndex];
                    for (;++argsIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
                    for (;rangeLength--; ) result[leftIndex++] = args[argsIndex++];
                    return result;
                }
                function composeArgsRight(args, partials, holders, isCurried) {
                    for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; ) result[argsIndex] = args[argsIndex];
                    for (var offset = argsIndex; ++rightIndex < rightLength; ) result[offset + rightIndex] = partials[rightIndex];
                    for (;++holdersIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
                    return result;
                }
                function copyArray(source, array) {
                    var index = -1, length = source.length;
                    for (array || (array = Array(length)); ++index < length; ) array[index] = source[index];
                    return array;
                }
                function copyObject(source, props, object, customizer) {
                    var isNew = !object;
                    object || (object = {});
                    for (var index = -1, length = props.length; ++index < length; ) {
                        var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                        newValue === undefined && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
                    }
                    return object;
                }
                function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object);
                }
                function copySymbolsIn(source, object) {
                    return copyObject(source, getSymbolsIn(source), object);
                }
                function createAggregator(setter, initializer) {
                    return function(collection, iteratee) {
                        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                    };
                }
                function createAssigner(assigner) {
                    return baseRest(function(object, sources) {
                        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                        for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--,
                        customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined : customizer,
                        length = 1), object = Object(object); ++index < length; ) {
                            var source = sources[index];
                            source && assigner(object, source, index, customizer);
                        }
                        return object;
                    });
                }
                function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        if (null == collection) return collection;
                        if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                        for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && !1 !== iteratee(iterable[index], index, iterable); ) ;
                        return collection;
                    };
                }
                function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                            var key = props[fromRight ? length : ++index];
                            if (!1 === iteratee(iterable[key], key, iterable)) break;
                        }
                        return object;
                    };
                }
                function createBind(func, bitmask, thisArg) {
                    function wrapper() {
                        return (this && this !== root && this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, arguments);
                    }
                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                    return wrapper;
                }
                function createCaseFirst(methodName) {
                    return function(string) {
                        string = toString(string);
                        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                        return chr[methodName]() + trailing;
                    };
                }
                function createCompounder(callback) {
                    return function(string) {
                        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                    };
                }
                function createCtor(Ctor) {
                    return function() {
                        var args = arguments;
                        switch (args.length) {
                          case 0:
                            return new Ctor();

                          case 1:
                            return new Ctor(args[0]);

                          case 2:
                            return new Ctor(args[0], args[1]);

                          case 3:
                            return new Ctor(args[0], args[1], args[2]);

                          case 4:
                            return new Ctor(args[0], args[1], args[2], args[3]);

                          case 5:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                          case 6:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                          case 7:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                        }
                        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding;
                    };
                }
                function createCurry(func, bitmask, arity) {
                    function wrapper() {
                        for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--; ) args[index] = arguments[index];
                        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                        return (length -= holders.length) < arity ? createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length) : apply(this && this !== root && this instanceof wrapper ? Ctor : func, this, args);
                    }
                    var Ctor = createCtor(func);
                    return wrapper;
                }
                function createFind(findIndexFunc) {
                    return function(collection, predicate, fromIndex) {
                        var iterable = Object(collection);
                        if (!isArrayLike(collection)) {
                            var iteratee = getIteratee(predicate, 3);
                            collection = keys(collection), predicate = function(key) {
                                return iteratee(iterable[key], key, iterable);
                            };
                        }
                        var index = findIndexFunc(collection, predicate, fromIndex);
                        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                    };
                }
                function createFlow(fromRight) {
                    return flatRest(function(funcs) {
                        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                        for (fromRight && funcs.reverse(); index--; ) {
                            var func = funcs[index];
                            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                            if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], !0);
                        }
                        for (index = wrapper ? index : length; ++index < length; ) {
                            func = funcs[index];
                            var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                            wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                        }
                        return function() {
                            var args = arguments, value = args[0];
                            if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                            for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length; ) result = funcs[index].call(this, result);
                            return result;
                        };
                    });
                }
                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                    function wrapper() {
                        for (var length = arguments.length, args = Array(length), index = length; index--; ) args[index] = arguments[index];
                        if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                        if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)),
                        length -= holdersCount, isCurried && length < arity) {
                            var newHolders = replaceHolders(args, placeholder);
                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                        }
                        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                        return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(),
                        isAry && ary < length && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)),
                        fn.apply(thisBinding, args);
                    }
                    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
                    return wrapper;
                }
                function createInverter(setter, toIteratee) {
                    return function(object, iteratee) {
                        return baseInverter(object, setter, toIteratee(iteratee), {});
                    };
                }
                function createMathOperation(operator, defaultValue) {
                    return function(value, other) {
                        var result;
                        if (value === undefined && other === undefined) return defaultValue;
                        if (value !== undefined && (result = value), other !== undefined) {
                            if (result === undefined) return other;
                            "string" == typeof value || "string" == typeof other ? (value = baseToString(value),
                            other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)),
                            result = operator(value, other);
                        }
                        return result;
                    };
                }
                function createOver(arrayFunc) {
                    return flatRest(function(iteratees) {
                        return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
                            var thisArg = this;
                            return arrayFunc(iteratees, function(iteratee) {
                                return apply(iteratee, thisArg, args);
                            });
                        });
                    });
                }
                function createPadding(length, chars) {
                    chars = chars === undefined ? " " : baseToString(chars);
                    var charsLength = chars.length;
                    if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
                    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
                }
                function createPartial(func, bitmask, thisArg, partials) {
                    function wrapper() {
                        for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; ) args[leftIndex] = partials[leftIndex];
                        for (;argsLength--; ) args[leftIndex++] = arguments[++argsIndex];
                        return apply(fn, isBind ? thisArg : this, args);
                    }
                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                    return wrapper;
                }
                function createRange(fromRight) {
                    return function(start, end, step) {
                        return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined),
                        start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end),
                        step = step === undefined ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
                    };
                }
                function createRelationalOperation(operator) {
                    return function(value, other) {
                        return "string" == typeof value && "string" == typeof other || (value = toNumber(value),
                        other = toNumber(other)), operator(value, other);
                    };
                }
                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, (bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)) & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
                    var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ], result = wrapFunc.apply(undefined, newData);
                    return isLaziable(func) && setData(result, newData), result.placeholder = placeholder,
                    setWrapToString(result, func, bitmask);
                }
                function createRound(methodName) {
                    var func = Math[methodName];
                    return function(number, precision) {
                        if (number = toNumber(number), (precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) && nativeIsFinite(number)) {
                            var pair = (toString(number) + "e").split("e");
                            return pair = (toString(func(pair[0] + "e" + (+pair[1] + precision))) + "e").split("e"),
                            +(pair[0] + "e" + (+pair[1] - precision));
                        }
                        return func(number);
                    };
                }
                function createToPairs(keysFunc) {
                    return function(object) {
                        var tag = getTag(object);
                        return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
                    };
                }
                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                    if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    var length = partials ? partials.length : 0;
                    if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined),
                    ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity),
                    length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                        var partialsRight = partials, holdersRight = holders;
                        partials = holders = undefined;
                    }
                    var data = isBindKey ? undefined : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
                    if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2],
                    partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0),
                    !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)),
                    bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials); else var result = createBind(func, bitmask, thisArg);
                    return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask);
                }
                function customDefaultsAssignIn(objValue, srcValue, key, object) {
                    return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue;
                }
                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                    return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue),
                    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack), stack.delete(srcValue)),
                    objValue;
                }
                function customOmitClone(value) {
                    return isPlainObject(value) ? undefined : value;
                }
                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
                    var arrStacked = stack.get(array), othStacked = stack.get(other);
                    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
                    var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
                    for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                        var arrValue = array[index], othValue = other[index];
                        if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                        if (compared !== undefined) {
                            if (compared) continue;
                            result = !1;
                            break;
                        }
                        if (seen) {
                            if (!arraySome(other, function(othValue, othIndex) {
                                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                            })) {
                                result = !1;
                                break;
                            }
                        } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                            result = !1;
                            break;
                        }
                    }
                    return stack.delete(array), stack.delete(other), result;
                }
                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                    switch (tag) {
                      case dataViewTag:
                        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                        object = object.buffer, other = other.buffer;

                      case arrayBufferTag:
                        return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

                      case boolTag:
                      case dateTag:
                      case numberTag:
                        return eq(+object, +other);

                      case errorTag:
                        return object.name == other.name && object.message == other.message;

                      case regexpTag:
                      case stringTag:
                        return object == other + "";

                      case mapTag:
                        var convert = mapToArray;

                      case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                        if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                        var stacked = stack.get(object);
                        if (stacked) return stacked == other;
                        bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                        return stack.delete(object), result;

                      case symbolTag:
                        if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                    return !1;
                }
                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length;
                    if (objLength != getAllKeys(other).length && !isPartial) return !1;
                    for (var index = objLength; index--; ) {
                        var key = objProps[index];
                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
                    }
                    var objStacked = stack.get(object), othStacked = stack.get(other);
                    if (objStacked && othStacked) return objStacked == other && othStacked == object;
                    var result = !0;
                    stack.set(object, other), stack.set(other, object);
                    for (var skipCtor = isPartial; ++index < objLength; ) {
                        key = objProps[index];
                        var objValue = object[key], othValue = other[key];
                        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                            result = !1;
                            break;
                        }
                        skipCtor || (skipCtor = "constructor" == key);
                    }
                    if (result && !skipCtor) {
                        var objCtor = object.constructor, othCtor = other.constructor;
                        objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
                    }
                    return stack.delete(object), stack.delete(other), result;
                }
                function flatRest(func) {
                    return setToString(overRest(func, undefined, flatten), func + "");
                }
                function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols);
                }
                function getAllKeysIn(object) {
                    return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }
                function getFuncName(func) {
                    for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--; ) {
                        var data = array[length], otherFunc = data.func;
                        if (null == otherFunc || otherFunc == func) return data.name;
                    }
                    return result;
                }
                function getHolder(func) {
                    return (hasOwnProperty.call(lodash, "placeholder") ? lodash : func).placeholder;
                }
                function getIteratee() {
                    var result = lodash.iteratee || iteratee;
                    return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result;
                }
                function getMapData(map, key) {
                    var data = map.__data__;
                    return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
                }
                function getMatchData(object) {
                    for (var result = keys(object), length = result.length; length--; ) {
                        var key = result[length], value = object[key];
                        result[length] = [ key, value, isStrictComparable(value) ];
                    }
                    return result;
                }
                function getNative(object, key) {
                    var value = getValue(object, key);
                    return baseIsNative(value) ? value : undefined;
                }
                function getRawTag(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                    try {
                        value[symToStringTag] = undefined;
                        var unmasked = !0;
                    } catch (e) {}
                    var result = nativeObjectToString.call(value);
                    return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]),
                    result;
                }
                function getView(start, end, transforms) {
                    for (var index = -1, length = transforms.length; ++index < length; ) {
                        var data = transforms[index], size = data.size;
                        switch (data.type) {
                          case "drop":
                            start += size;
                            break;

                          case "dropRight":
                            end -= size;
                            break;

                          case "take":
                            end = nativeMin(end, start + size);
                            break;

                          case "takeRight":
                            start = nativeMax(start, end - size);
                        }
                    }
                    return {
                        start: start,
                        end: end
                    };
                }
                function getWrapDetails(source) {
                    var match = source.match(reWrapDetails);
                    return match ? match[1].split(reSplitDetails) : [];
                }
                function hasPath(object, path, hasFunc) {
                    path = castPath(path, object);
                    for (var index = -1, length = path.length, result = !1; ++index < length; ) {
                        var key = toKey(path[index]);
                        if (!(result = null != object && hasFunc(object, key))) break;
                        object = object[key];
                    }
                    return result || ++index != length ? result : !!(length = null == object ? 0 : object.length) && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                }
                function initCloneArray(array) {
                    var length = array.length, result = new array.constructor(length);
                    return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index,
                    result.input = array.input), result;
                }
                function initCloneObject(object) {
                    return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
                }
                function initCloneByTag(object, tag, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                      case arrayBufferTag:
                        return cloneArrayBuffer(object);

                      case boolTag:
                      case dateTag:
                        return new Ctor(+object);

                      case dataViewTag:
                        return cloneDataView(object, isDeep);

                      case float32Tag:
                      case float64Tag:
                      case int8Tag:
                      case int16Tag:
                      case int32Tag:
                      case uint8Tag:
                      case uint8ClampedTag:
                      case uint16Tag:
                      case uint32Tag:
                        return cloneTypedArray(object, isDeep);

                      case mapTag:
                        return new Ctor();

                      case numberTag:
                      case stringTag:
                        return new Ctor(object);

                      case regexpTag:
                        return cloneRegExp(object);

                      case setTag:
                        return new Ctor();

                      case symbolTag:
                        return cloneSymbol(object);
                    }
                }
                function insertWrapDetails(source, details) {
                    var length = details.length;
                    if (!length) return source;
                    var lastIndex = length - 1;
                    return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "),
                    source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                }
                function isFlattenable(value) {
                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                }
                function isIndex(value, length) {
                    var type = typeof value;
                    return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
                }
                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) return !1;
                    var type = typeof index;
                    return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value);
                }
                function isKey(value, object) {
                    if (isArray(value)) return !1;
                    var type = typeof value;
                    return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || (reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object));
                }
                function isKeyable(value) {
                    var type = typeof value;
                    return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
                }
                function isLaziable(func) {
                    var funcName = getFuncName(func), other = lodash[funcName];
                    if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return !1;
                    if (func === other) return !0;
                    var data = getData(other);
                    return !!data && func === data[0];
                }
                function isMasked(func) {
                    return !!maskSrcKey && maskSrcKey in func;
                }
                function isPrototype(value) {
                    var Ctor = value && value.constructor;
                    return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
                }
                function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }
                function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                        return null != object && (object[key] === srcValue && (srcValue !== undefined || key in Object(object)));
                    };
                }
                function mergeData(data, source) {
                    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                    if (!isCommon && !isCombo) return data;
                    srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
                    var value = source[3];
                    if (value) {
                        var partials = data[3];
                        data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                    }
                    return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value,
                    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7],
                    value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])),
                    null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask,
                    data;
                }
                function nativeKeysIn(object) {
                    var result = [];
                    if (null != object) for (var key in Object(object)) result.push(key);
                    return result;
                }
                function objectToString(value) {
                    return nativeObjectToString.call(value);
                }
                function overRest(func, start, transform) {
                    return start = nativeMax(start === undefined ? func.length - 1 : start, 0), function() {
                        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
                        index = -1;
                        for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
                        return otherArgs[start] = transform(array), apply(func, this, otherArgs);
                    };
                }
                function parent(object, path) {
                    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                }
                function reorder(array, indexes) {
                    for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
                        var index = indexes[length];
                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                    }
                    return array;
                }
                function safeGet(object, key) {
                    if (("constructor" !== key || "function" != typeof object[key]) && "__proto__" != key) return object[key];
                }
                function setWrapToString(wrapper, reference, bitmask) {
                    var source = reference + "";
                    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                }
                function shortOut(func) {
                    var count = 0, lastCalled = 0;
                    return function() {
                        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                        if (lastCalled = stamp, remaining > 0) {
                            if (++count >= HOT_COUNT) return arguments[0];
                        } else count = 0;
                        return func.apply(undefined, arguments);
                    };
                }
                function shuffleSelf(array, size) {
                    var index = -1, length = array.length, lastIndex = length - 1;
                    for (size = size === undefined ? length : size; ++index < size; ) {
                        var rand = baseRandom(index, lastIndex), value = array[rand];
                        array[rand] = array[index], array[index] = value;
                    }
                    return array.length = size, array;
                }
                function toKey(value) {
                    if ("string" == typeof value || isSymbol(value)) return value;
                    var result = value + "";
                    return "0" == result && 1 / value == -INFINITY ? "-0" : result;
                }
                function toSource(func) {
                    if (null != func) {
                        try {
                            return funcToString.call(func);
                        } catch (e) {}
                        try {
                            return func + "";
                        } catch (e) {}
                    }
                    return "";
                }
                function updateWrapDetails(details, bitmask) {
                    return arrayEach(wrapFlags, function(pair) {
                        var value = "_." + pair[0];
                        bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
                    }), details.sort();
                }
                function wrapperClone(wrapper) {
                    if (wrapper instanceof LazyWrapper) return wrapper.clone();
                    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                    return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__,
                    result.__values__ = wrapper.__values__, result;
                }
                function chunk(array, size, guard) {
                    size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
                    var length = null == array ? 0 : array.length;
                    if (!length || size < 1) return [];
                    for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length; ) result[resIndex++] = baseSlice(array, index, index += size);
                    return result;
                }
                function compact(array) {
                    for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                        var value = array[index];
                        value && (result[resIndex++] = value);
                    }
                    return result;
                }
                function concat() {
                    var length = arguments.length;
                    if (!length) return [];
                    for (var args = Array(length - 1), array = arguments[0], index = length; index--; ) args[index - 1] = arguments[index];
                    return arrayPush(isArray(array) ? copyArray(array) : [ array ], baseFlatten(args, 1));
                }
                function drop(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : [];
                }
                function dropRight(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n,
                    baseSlice(array, 0, n < 0 ? 0 : n)) : [];
                }
                function dropRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
                }
                function dropWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
                }
                function fill(array, value, start, end) {
                    var length = null == array ? 0 : array.length;
                    return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0,
                    end = length), baseFill(array, value, start, end)) : [];
                }
                function findIndex(array, predicate, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = null == fromIndex ? 0 : toInteger(fromIndex);
                    return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
                }
                function findLastIndex(array, predicate, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = length - 1;
                    return fromIndex !== undefined && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)),
                    baseFindIndex(array, getIteratee(predicate, 3), index, !0);
                }
                function flatten(array) {
                    return (null == array ? 0 : array.length) ? baseFlatten(array, 1) : [];
                }
                function flattenDeep(array) {
                    return (null == array ? 0 : array.length) ? baseFlatten(array, INFINITY) : [];
                }
                function flattenDepth(array, depth) {
                    return (null == array ? 0 : array.length) ? (depth = depth === undefined ? 1 : toInteger(depth),
                    baseFlatten(array, depth)) : [];
                }
                function fromPairs(pairs) {
                    for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
                        var pair = pairs[index];
                        result[pair[0]] = pair[1];
                    }
                    return result;
                }
                function head(array) {
                    return array && array.length ? array[0] : undefined;
                }
                function indexOf(array, value, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = null == fromIndex ? 0 : toInteger(fromIndex);
                    return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
                }
                function initial(array) {
                    return (null == array ? 0 : array.length) ? baseSlice(array, 0, -1) : [];
                }
                function join(array, separator) {
                    return null == array ? "" : nativeJoin.call(array, separator);
                }
                function last(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? array[length - 1] : undefined;
                }
                function lastIndexOf(array, value, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = length;
                    return fromIndex !== undefined && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)),
                    value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
                }
                function nth(array, n) {
                    return array && array.length ? baseNth(array, toInteger(n)) : undefined;
                }
                function pullAll(array, values) {
                    return array && array.length && values && values.length ? basePullAll(array, values) : array;
                }
                function pullAllBy(array, values, iteratee) {
                    return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
                }
                function pullAllWith(array, values, comparator) {
                    return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
                }
                function remove(array, predicate) {
                    var result = [];
                    if (!array || !array.length) return result;
                    var index = -1, indexes = [], length = array.length;
                    for (predicate = getIteratee(predicate, 3); ++index < length; ) {
                        var value = array[index];
                        predicate(value, index, array) && (result.push(value), indexes.push(index));
                    }
                    return basePullAt(array, indexes), result;
                }
                function reverse(array) {
                    return null == array ? array : nativeReverse.call(array);
                }
                function slice(array, start, end) {
                    var length = null == array ? 0 : array.length;
                    return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0,
                    end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)),
                    baseSlice(array, start, end)) : [];
                }
                function sortedIndex(array, value) {
                    return baseSortedIndex(array, value);
                }
                function sortedIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                }
                function sortedIndexOf(array, value) {
                    var length = null == array ? 0 : array.length;
                    if (length) {
                        var index = baseSortedIndex(array, value);
                        if (index < length && eq(array[index], value)) return index;
                    }
                    return -1;
                }
                function sortedLastIndex(array, value) {
                    return baseSortedIndex(array, value, !0);
                }
                function sortedLastIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0);
                }
                function sortedLastIndexOf(array, value) {
                    if (null == array ? 0 : array.length) {
                        var index = baseSortedIndex(array, value, !0) - 1;
                        if (eq(array[index], value)) return index;
                    }
                    return -1;
                }
                function sortedUniq(array) {
                    return array && array.length ? baseSortedUniq(array) : [];
                }
                function sortedUniqBy(array, iteratee) {
                    return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
                }
                function tail(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseSlice(array, 1, length) : [];
                }
                function take(array, n, guard) {
                    return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n),
                    baseSlice(array, 0, n < 0 ? 0 : n)) : [];
                }
                function takeRight(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n,
                    baseSlice(array, n < 0 ? 0 : n, length)) : [];
                }
                function takeRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
                }
                function takeWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                }
                function uniq(array) {
                    return array && array.length ? baseUniq(array) : [];
                }
                function uniqBy(array, iteratee) {
                    return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                }
                function uniqWith(array, comparator) {
                    return comparator = "function" == typeof comparator ? comparator : undefined, array && array.length ? baseUniq(array, undefined, comparator) : [];
                }
                function unzip(array) {
                    if (!array || !array.length) return [];
                    var length = 0;
                    return array = arrayFilter(array, function(group) {
                        if (isArrayLikeObject(group)) return length = nativeMax(group.length, length), !0;
                    }), baseTimes(length, function(index) {
                        return arrayMap(array, baseProperty(index));
                    });
                }
                function unzipWith(array, iteratee) {
                    if (!array || !array.length) return [];
                    var result = unzip(array);
                    return null == iteratee ? result : arrayMap(result, function(group) {
                        return apply(iteratee, undefined, group);
                    });
                }
                function zipObject(props, values) {
                    return baseZipObject(props || [], values || [], assignValue);
                }
                function zipObjectDeep(props, values) {
                    return baseZipObject(props || [], values || [], baseSet);
                }
                function chain(value) {
                    var result = lodash(value);
                    return result.__chain__ = !0, result;
                }
                function tap(value, interceptor) {
                    return interceptor(value), value;
                }
                function thru(value, interceptor) {
                    return interceptor(value);
                }
                function wrapperChain() {
                    return chain(this);
                }
                function wrapperCommit() {
                    return new LodashWrapper(this.value(), this.__chain__);
                }
                function wrapperNext() {
                    this.__values__ === undefined && (this.__values__ = toArray(this.value()));
                    var done = this.__index__ >= this.__values__.length;
                    return {
                        done: done,
                        value: done ? undefined : this.__values__[this.__index__++]
                    };
                }
                function wrapperToIterator() {
                    return this;
                }
                function wrapperPlant(value) {
                    for (var result, parent = this; parent instanceof baseLodash; ) {
                        var clone = wrapperClone(parent);
                        clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
                        var previous = clone;
                        parent = parent.__wrapped__;
                    }
                    return previous.__wrapped__ = value, result;
                }
                function wrapperReverse() {
                    var value = this.__wrapped__;
                    if (value instanceof LazyWrapper) {
                        var wrapped = value;
                        return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(),
                        wrapped.__actions__.push({
                            func: thru,
                            args: [ reverse ],
                            thisArg: undefined
                        }), new LodashWrapper(wrapped, this.__chain__);
                    }
                    return this.thru(reverse);
                }
                function wrapperValue() {
                    return baseWrapperValue(this.__wrapped__, this.__actions__);
                }
                function every(collection, predicate, guard) {
                    var func = isArray(collection) ? arrayEvery : baseEvery;
                    return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
                    func(collection, getIteratee(predicate, 3));
                }
                function filter(collection, predicate) {
                    return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3));
                }
                function flatMap(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), 1);
                }
                function flatMapDeep(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), INFINITY);
                }
                function flatMapDepth(collection, iteratee, depth) {
                    return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth);
                }
                function forEach(collection, iteratee) {
                    return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee, 3));
                }
                function forEachRight(collection, iteratee) {
                    return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee, 3));
                }
                function includes(collection, value, fromIndex, guard) {
                    collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                    var length = collection.length;
                    return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                }
                function map(collection, iteratee) {
                    return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee, 3));
                }
                function orderBy(collection, iteratees, orders, guard) {
                    return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [ iteratees ]),
                    orders = guard ? undefined : orders, isArray(orders) || (orders = null == orders ? [] : [ orders ]),
                    baseOrderBy(collection, iteratees, orders));
                }
                function reduce(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                }
                function reduceRight(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                }
                function reject(collection, predicate) {
                    return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)));
                }
                function sample(collection) {
                    return (isArray(collection) ? arraySample : baseSample)(collection);
                }
                function sampleSize(collection, n, guard) {
                    return n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n),
                    (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n);
                }
                function shuffle(collection) {
                    return (isArray(collection) ? arrayShuffle : baseShuffle)(collection);
                }
                function size(collection) {
                    if (null == collection) return 0;
                    if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
                    var tag = getTag(collection);
                    return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
                }
                function some(collection, predicate, guard) {
                    var func = isArray(collection) ? arraySome : baseSome;
                    return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
                    func(collection, getIteratee(predicate, 3));
                }
                function after(n, func) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return n = toInteger(n), function() {
                        if (--n < 1) return func.apply(this, arguments);
                    };
                }
                function ary(func, n, guard) {
                    return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
                }
                function before(n, func) {
                    var result;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return n = toInteger(n), function() {
                        return --n > 0 && (result = func.apply(this, arguments)), n <= 1 && (func = undefined),
                        result;
                    };
                }
                function curry(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    return result.placeholder = curry.placeholder, result;
                }
                function curryRight(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    return result.placeholder = curryRight.placeholder, result;
                }
                function debounce(func, wait, options) {
                    function invokeFunc(time) {
                        var args = lastArgs, thisArg = lastThis;
                        return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args);
                    }
                    function leadingEdge(time) {
                        return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                    }
                    function remainingWait(time) {
                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                    }
                    function shouldInvoke(time) {
                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                    }
                    function timerExpired() {
                        var time = now();
                        if (shouldInvoke(time)) return trailingEdge(time);
                        timerId = setTimeout(timerExpired, remainingWait(time));
                    }
                    function trailingEdge(time) {
                        return timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined,
                        result);
                    }
                    function cancel() {
                        timerId !== undefined && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined;
                    }
                    function flush() {
                        return timerId === undefined ? result : trailingEdge(now());
                    }
                    function debounced() {
                        var time = now(), isInvoking = shouldInvoke(time);
                        if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                            if (timerId === undefined) return leadingEdge(lastCallTime);
                            if (maxing) return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait),
                            invokeFunc(lastCallTime);
                        }
                        return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result;
                    }
                    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading,
                    maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait,
                    trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel,
                    debounced.flush = flush, debounced;
                }
                function flip(func) {
                    return createWrap(func, WRAP_FLIP_FLAG);
                }
                function memoize(func, resolver) {
                    if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
                    var memoized = function() {
                        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                        if (cache.has(key)) return cache.get(key);
                        var result = func.apply(this, args);
                        return memoized.cache = cache.set(key, result) || cache, result;
                    };
                    return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
                }
                function negate(predicate) {
                    if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
                    return function() {
                        var args = arguments;
                        switch (args.length) {
                          case 0:
                            return !predicate.call(this);

                          case 1:
                            return !predicate.call(this, args[0]);

                          case 2:
                            return !predicate.call(this, args[0], args[1]);

                          case 3:
                            return !predicate.call(this, args[0], args[1], args[2]);
                        }
                        return !predicate.apply(this, args);
                    };
                }
                function once(func) {
                    return before(2, func);
                }
                function rest(func, start) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return start = start === undefined ? start : toInteger(start), baseRest(func, start);
                }
                function spread(func, start) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
                        var array = args[start], otherArgs = castSlice(args, 0, start);
                        return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
                    });
                }
                function throttle(func, wait, options) {
                    var leading = !0, trailing = !0;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return isObject(options) && (leading = "leading" in options ? !!options.leading : leading,
                    trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                        leading: leading,
                        maxWait: wait,
                        trailing: trailing
                    });
                }
                function unary(func) {
                    return ary(func, 1);
                }
                function wrap(value, wrapper) {
                    return partial(castFunction(wrapper), value);
                }
                function castArray() {
                    if (!arguments.length) return [];
                    var value = arguments[0];
                    return isArray(value) ? value : [ value ];
                }
                function clone(value) {
                    return baseClone(value, CLONE_SYMBOLS_FLAG);
                }
                function cloneWith(value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                }
                function cloneDeep(value) {
                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }
                function cloneDeepWith(value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                }
                function conformsTo(object, source) {
                    return null == source || baseConformsTo(object, source, keys(source));
                }
                function eq(value, other) {
                    return value === other || value !== value && other !== other;
                }
                function isArrayLike(value) {
                    return null != value && isLength(value.length) && !isFunction(value);
                }
                function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value);
                }
                function isBoolean(value) {
                    return !0 === value || !1 === value || isObjectLike(value) && baseGetTag(value) == boolTag;
                }
                function isElement(value) {
                    return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value);
                }
                function isEmpty(value) {
                    if (null == value) return !0;
                    if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
                    var tag = getTag(value);
                    if (tag == mapTag || tag == setTag) return !value.size;
                    if (isPrototype(value)) return !baseKeys(value).length;
                    for (var key in value) if (hasOwnProperty.call(value, key)) return !1;
                    return !0;
                }
                function isEqual(value, other) {
                    return baseIsEqual(value, other);
                }
                function isEqualWith(value, other, customizer) {
                    customizer = "function" == typeof customizer ? customizer : undefined;
                    var result = customizer ? customizer(value, other) : undefined;
                    return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
                }
                function isError(value) {
                    if (!isObjectLike(value)) return !1;
                    var tag = baseGetTag(value);
                    return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value);
                }
                function isFinite(value) {
                    return "number" == typeof value && nativeIsFinite(value);
                }
                function isFunction(value) {
                    if (!isObject(value)) return !1;
                    var tag = baseGetTag(value);
                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                }
                function isInteger(value) {
                    return "number" == typeof value && value == toInteger(value);
                }
                function isLength(value) {
                    return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                function isObject(value) {
                    var type = typeof value;
                    return null != value && ("object" == type || "function" == type);
                }
                function isObjectLike(value) {
                    return null != value && "object" == typeof value;
                }
                function isMatch(object, source) {
                    return object === source || baseIsMatch(object, source, getMatchData(source));
                }
                function isMatchWith(object, source, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer);
                }
                function isNaN(value) {
                    return isNumber(value) && value != +value;
                }
                function isNative(value) {
                    if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
                    return baseIsNative(value);
                }
                function isNull(value) {
                    return null === value;
                }
                function isNil(value) {
                    return null == value;
                }
                function isNumber(value) {
                    return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag;
                }
                function isPlainObject(value) {
                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
                    var proto = getPrototype(value);
                    if (null === proto) return !0;
                    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                    return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                }
                function isSafeInteger(value) {
                    return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                }
                function isString(value) {
                    return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                }
                function isSymbol(value) {
                    return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
                }
                function isUndefined(value) {
                    return value === undefined;
                }
                function isWeakMap(value) {
                    return isObjectLike(value) && getTag(value) == weakMapTag;
                }
                function isWeakSet(value) {
                    return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                }
                function toArray(value) {
                    if (!value) return [];
                    if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
                    if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
                    var tag = getTag(value);
                    return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value);
                }
                function toFinite(value) {
                    if (!value) return 0 === value ? value : 0;
                    if ((value = toNumber(value)) === INFINITY || value === -INFINITY) {
                        return (value < 0 ? -1 : 1) * MAX_INTEGER;
                    }
                    return value === value ? value : 0;
                }
                function toInteger(value) {
                    var result = toFinite(value), remainder = result % 1;
                    return result === result ? remainder ? result - remainder : result : 0;
                }
                function toLength(value) {
                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                }
                function toNumber(value) {
                    if ("number" == typeof value) return value;
                    if (isSymbol(value)) return NAN;
                    if (isObject(value)) {
                        var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                        value = isObject(other) ? other + "" : other;
                    }
                    if ("string" != typeof value) return 0 === value ? value : +value;
                    value = value.replace(reTrim, "");
                    var isBinary = reIsBinary.test(value);
                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                }
                function toPlainObject(value) {
                    return copyObject(value, keysIn(value));
                }
                function toSafeInteger(value) {
                    return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0;
                }
                function toString(value) {
                    return null == value ? "" : baseToString(value);
                }
                function create(prototype, properties) {
                    var result = baseCreate(prototype);
                    return null == properties ? result : baseAssign(result, properties);
                }
                function findKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                }
                function findLastKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                }
                function forIn(object, iteratee) {
                    return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
                }
                function forInRight(object, iteratee) {
                    return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                }
                function forOwn(object, iteratee) {
                    return object && baseForOwn(object, getIteratee(iteratee, 3));
                }
                function forOwnRight(object, iteratee) {
                    return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                }
                function functions(object) {
                    return null == object ? [] : baseFunctions(object, keys(object));
                }
                function functionsIn(object) {
                    return null == object ? [] : baseFunctions(object, keysIn(object));
                }
                function get(object, path, defaultValue) {
                    var result = null == object ? undefined : baseGet(object, path);
                    return result === undefined ? defaultValue : result;
                }
                function has(object, path) {
                    return null != object && hasPath(object, path, baseHas);
                }
                function hasIn(object, path) {
                    return null != object && hasPath(object, path, baseHasIn);
                }
                function keys(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }
                function keysIn(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
                }
                function mapKeys(object, iteratee) {
                    var result = {};
                    return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                        baseAssignValue(result, iteratee(value, key, object), value);
                    }), result;
                }
                function mapValues(object, iteratee) {
                    var result = {};
                    return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                        baseAssignValue(result, key, iteratee(value, key, object));
                    }), result;
                }
                function omitBy(object, predicate) {
                    return pickBy(object, negate(getIteratee(predicate)));
                }
                function pickBy(object, predicate) {
                    if (null == object) return {};
                    var props = arrayMap(getAllKeysIn(object), function(prop) {
                        return [ prop ];
                    });
                    return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path) {
                        return predicate(value, path[0]);
                    });
                }
                function result(object, path, defaultValue) {
                    path = castPath(path, object);
                    var index = -1, length = path.length;
                    for (length || (length = 1, object = undefined); ++index < length; ) {
                        var value = null == object ? undefined : object[toKey(path[index])];
                        value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value;
                    }
                    return object;
                }
                function set(object, path, value) {
                    return null == object ? object : baseSet(object, path, value);
                }
                function setWith(object, path, value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer);
                }
                function transform(object, iteratee, accumulator) {
                    var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                    if (iteratee = getIteratee(iteratee, 4), null == accumulator) {
                        var Ctor = object && object.constructor;
                        accumulator = isArrLike ? isArr ? new Ctor() : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    }
                    return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                        return iteratee(accumulator, value, index, object);
                    }), accumulator;
                }
                function unset(object, path) {
                    return null == object || baseUnset(object, path);
                }
                function update(object, path, updater) {
                    return null == object ? object : baseUpdate(object, path, castFunction(updater));
                }
                function updateWith(object, path, updater, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer);
                }
                function values(object) {
                    return null == object ? [] : baseValues(object, keys(object));
                }
                function valuesIn(object) {
                    return null == object ? [] : baseValues(object, keysIn(object));
                }
                function clamp(number, lower, upper) {
                    return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = toNumber(upper),
                    upper = upper === upper ? upper : 0), lower !== undefined && (lower = toNumber(lower),
                    lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper);
                }
                function inRange(number, start, end) {
                    return start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end),
                    number = toNumber(number), baseInRange(number, start, end);
                }
                function random(lower, upper, floating) {
                    if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined),
                    floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower,
                    lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toFinite(lower),
                    upper === undefined ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
                        var temp = lower;
                        lower = upper, upper = temp;
                    }
                    if (floating || lower % 1 || upper % 1) {
                        var rand = nativeRandom();
                        return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                    }
                    return baseRandom(lower, upper);
                }
                function capitalize(string) {
                    return upperFirst(toString(string).toLowerCase());
                }
                function deburr(string) {
                    return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                }
                function endsWith(string, target, position) {
                    string = toString(string), target = baseToString(target);
                    var length = string.length;
                    position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                    var end = position;
                    return (position -= target.length) >= 0 && string.slice(position, end) == target;
                }
                function escape(string) {
                    return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                }
                function escapeRegExp(string) {
                    return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                }
                function pad(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    if (!length || strLength >= length) return string;
                    var mid = (length - strLength) / 2;
                    return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                }
                function padEnd(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                }
                function padStart(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                }
                function parseInt(string, radix, guard) {
                    return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
                }
                function repeat(string, n, guard) {
                    return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n),
                    baseRepeat(toString(string), n);
                }
                function replace() {
                    var args = arguments, string = toString(args[0]);
                    return args.length < 3 ? string : string.replace(args[1], args[2]);
                }
                function split(string, separator, limit) {
                    return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined),
                    (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string),
                    string && ("string" == typeof separator || null != separator && !isRegExp(separator)) && !(separator = baseToString(separator)) && hasUnicode(string) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit)) : [];
                }
                function startsWith(string, target, position) {
                    return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length),
                    target = baseToString(target), string.slice(position, position + target.length) == target;
                }
                function template(string, options, guard) {
                    var settings = lodash.templateSettings;
                    guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string),
                    options = assignInWith({}, options, settings, customDefaultsAssignIn);
                    var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar),
                        escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"),
                        evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"),
                        interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"),
                        index = offset + match.length, match;
                    }), source += "';\n";
                    var variable = hasOwnProperty.call(options, "variable") && options.variable;
                    variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"),
                    source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                    var result = attempt(function() {
                        return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
                    });
                    if (result.source = source, isError(result)) throw result;
                    return result;
                }
                function toLower(value) {
                    return toString(value).toLowerCase();
                }
                function toUpper(value) {
                    return toString(value).toUpperCase();
                }
                function trim(string, chars, guard) {
                    if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrim, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars);
                    return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("");
                }
                function trimEnd(string, chars, guard) {
                    if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string);
                    return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join("");
                }
                function trimStart(string, chars, guard) {
                    if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimStart, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string);
                    return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join("");
                }
                function truncate(string, options) {
                    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                    if (isObject(options)) {
                        var separator = "separator" in options ? options.separator : separator;
                        length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission;
                    }
                    string = toString(string);
                    var strLength = string.length;
                    if (hasUnicode(string)) {
                        var strSymbols = stringToArray(string);
                        strLength = strSymbols.length;
                    }
                    if (length >= strLength) return string;
                    var end = length - stringSize(omission);
                    if (end < 1) return omission;
                    var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                    if (separator === undefined) return result + omission;
                    if (strSymbols && (end += result.length - end), isRegExp(separator)) {
                        if (string.slice(end).search(separator)) {
                            var match, substring = result;
                            for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")),
                            separator.lastIndex = 0; match = separator.exec(substring); ) var newEnd = match.index;
                            result = result.slice(0, newEnd === undefined ? end : newEnd);
                        }
                    } else if (string.indexOf(baseToString(separator), end) != end) {
                        var index = result.lastIndexOf(separator);
                        index > -1 && (result = result.slice(0, index));
                    }
                    return result + omission;
                }
                function unescape(string) {
                    return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                }
                function words(string, pattern, guard) {
                    return string = toString(string), pattern = guard ? undefined : pattern, pattern === undefined ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
                }
                function cond(pairs) {
                    var length = null == pairs ? 0 : pairs.length, toIteratee = getIteratee();
                    return pairs = length ? arrayMap(pairs, function(pair) {
                        if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
                        return [ toIteratee(pair[0]), pair[1] ];
                    }) : [], baseRest(function(args) {
                        for (var index = -1; ++index < length; ) {
                            var pair = pairs[index];
                            if (apply(pair[0], this, args)) return apply(pair[1], this, args);
                        }
                    });
                }
                function conforms(source) {
                    return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                }
                function constant(value) {
                    return function() {
                        return value;
                    };
                }
                function defaultTo(value, defaultValue) {
                    return null == value || value !== value ? defaultValue : value;
                }
                function identity(value) {
                    return value;
                }
                function iteratee(func) {
                    return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG));
                }
                function matches(source) {
                    return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                }
                function matchesProperty(path, srcValue) {
                    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                }
                function mixin(object, source, options) {
                    var props = keys(source), methodNames = baseFunctions(source, props);
                    null != options || isObject(source) && (methodNames.length || !props.length) || (options = source,
                    source = object, object = this, methodNames = baseFunctions(source, keys(source)));
                    var chain = !(isObject(options) && "chain" in options && !options.chain), isFunc = isFunction(object);
                    return arrayEach(methodNames, function(methodName) {
                        var func = source[methodName];
                        object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
                            var chainAll = this.__chain__;
                            if (chain || chainAll) {
                                var result = object(this.__wrapped__);
                                return (result.__actions__ = copyArray(this.__actions__)).push({
                                    func: func,
                                    args: arguments,
                                    thisArg: object
                                }), result.__chain__ = chainAll, result;
                            }
                            return func.apply(object, arrayPush([ this.value() ], arguments));
                        });
                    }), object;
                }
                function noConflict() {
                    return root._ === this && (root._ = oldDash), this;
                }
                function noop() {}
                function nthArg(n) {
                    return n = toInteger(n), baseRest(function(args) {
                        return baseNth(args, n);
                    });
                }
                function property(path) {
                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }
                function propertyOf(object) {
                    return function(path) {
                        return null == object ? undefined : baseGet(object, path);
                    };
                }
                function stubArray() {
                    return [];
                }
                function stubFalse() {
                    return !1;
                }
                function stubObject() {
                    return {};
                }
                function stubString() {
                    return "";
                }
                function stubTrue() {
                    return !0;
                }
                function times(n, iteratee) {
                    if ((n = toInteger(n)) < 1 || n > MAX_SAFE_INTEGER) return [];
                    var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                    iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
                    for (var result = baseTimes(length, iteratee); ++index < n; ) iteratee(index);
                    return result;
                }
                function toPath(value) {
                    return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [ value ] : copyArray(stringToPath(toString(value)));
                }
                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return toString(prefix) + id;
                }
                function max(array) {
                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
                }
                function maxBy(array, iteratee) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
                }
                function mean(array) {
                    return baseMean(array, identity);
                }
                function meanBy(array, iteratee) {
                    return baseMean(array, getIteratee(iteratee, 2));
                }
                function min(array) {
                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
                }
                function minBy(array, iteratee) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
                }
                function sum(array) {
                    return array && array.length ? baseSum(array, identity) : 0;
                }
                function sumBy(array, iteratee) {
                    return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
                }
                context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                    return uid ? "Symbol(src)_1." + uid : "";
                }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), oldDash = root._, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined, defineProperty = function() {
                    try {
                        var func = getNative(Object, "defineProperty");
                        return func({}, "", {}), func;
                    } catch (e) {}
                }(), ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout, nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create"), metaMap = WeakMap && new WeakMap(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined, baseCreate = function() {
                    function object() {}
                    return function(proto) {
                        if (!isObject(proto)) return {};
                        if (objectCreate) return objectCreate(proto);
                        object.prototype = proto;
                        var result = new object();
                        return object.prototype = undefined, result;
                    };
                }();
                lodash.templateSettings = {
                    escape: reEscape,
                    evaluate: reEvaluate,
                    interpolate: reInterpolate,
                    variable: "",
                    imports: {
                        _: lodash
                    }
                }, lodash.prototype = baseLodash.prototype, lodash.prototype.constructor = lodash,
                LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper,
                LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper,
                Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet,
                Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear,
                ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet,
                ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet,
                MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete,
                MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet,
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas,
                Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet,
                Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
                var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0), baseFor = createBaseFor(), baseForRight = createBaseFor(!0), baseSetData = metaMap ? function(func, data) {
                    return metaMap.set(func, data), func;
                } : identity, baseSetToString = defineProperty ? function(func, string) {
                    return defineProperty(func, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: constant(string),
                        writable: !0
                    });
                } : identity, castRest = baseRest, clearTimeout = ctxClearTimeout || function(id) {
                    return root.clearTimeout(id);
                }, createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY ? function(values) {
                    return new Set(values);
                } : noop, getData = metaMap ? function(func) {
                    return metaMap.get(func);
                } : noop, getSymbols = nativeGetSymbols ? function(object) {
                    return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                        return propertyIsEnumerable.call(object, symbol);
                    }));
                } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
                    for (var result = []; object; ) arrayPush(result, getSymbols(object)), object = getPrototype(object);
                    return result;
                } : stubArray, getTag = baseGetTag;
                (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
                    var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;

                      case mapCtorString:
                        return mapTag;

                      case promiseCtorString:
                        return "[object Promise]";

                      case setCtorString:
                        return setTag;

                      case weakMapCtorString:
                        return weakMapTag;
                    }
                    return result;
                });
                var isMaskable = coreJsData ? isFunction : stubFalse, setData = shortOut(baseSetData), setTimeout = ctxSetTimeout || function(func, wait) {
                    return root.setTimeout(func, wait);
                }, setToString = shortOut(baseSetToString), stringToPath = function(func) {
                    var result = memoize(func, function(key) {
                        return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
                    }), cache = result.cache;
                    return result;
                }(function(string) {
                    var result = [];
                    return 46 === string.charCodeAt(0) && result.push(""), string.replace(rePropName, function(match, number, quote, subString) {
                        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                    }), result;
                }), difference = baseRest(function(array, values) {
                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : [];
                }), differenceBy = baseRest(function(array, values) {
                    var iteratee = last(values);
                    return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : [];
                }), differenceWith = baseRest(function(array, values) {
                    var comparator = last(values);
                    return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : [];
                }), intersection = baseRest(function(arrays) {
                    var mapped = arrayMap(arrays, castArrayLikeObject);
                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                }), intersectionBy = baseRest(function(arrays) {
                    var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                    return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                }), intersectionWith = baseRest(function(arrays) {
                    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                    return comparator = "function" == typeof comparator ? comparator : undefined, comparator && mapped.pop(),
                    mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
                }), pull = baseRest(pullAll), pullAt = flatRest(function(array, indexes) {
                    var length = null == array ? 0 : array.length, result = baseAt(array, indexes);
                    return basePullAt(array, arrayMap(indexes, function(index) {
                        return isIndex(index, length) ? +index : index;
                    }).sort(compareAscending)), result;
                }), union = baseRest(function(arrays) {
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
                }), unionBy = baseRest(function(arrays) {
                    var iteratee = last(arrays);
                    return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2));
                }), unionWith = baseRest(function(arrays) {
                    var comparator = last(arrays);
                    return comparator = "function" == typeof comparator ? comparator : undefined, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator);
                }), without = baseRest(function(array, values) {
                    return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                }), xor = baseRest(function(arrays) {
                    return baseXor(arrayFilter(arrays, isArrayLikeObject));
                }), xorBy = baseRest(function(arrays) {
                    var iteratee = last(arrays);
                    return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                }), xorWith = baseRest(function(arrays) {
                    var comparator = last(arrays);
                    return comparator = "function" == typeof comparator ? comparator : undefined, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                }), zip = baseRest(unzip), zipWith = baseRest(function(arrays) {
                    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                    return iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined,
                    unzipWith(arrays, iteratee);
                }), wrapperAt = flatRest(function(paths) {
                    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                        return baseAt(object, paths);
                    };
                    return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? (value = value.slice(start, +start + (length ? 1 : 0)),
                    value.__actions__.push({
                        func: thru,
                        args: [ interceptor ],
                        thisArg: undefined
                    }), new LodashWrapper(value, this.__chain__).thru(function(array) {
                        return length && !array.length && array.push(undefined), array;
                    })) : this.thru(interceptor);
                }), countBy = createAggregator(function(result, value, key) {
                    hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1);
                }), find = createFind(findIndex), findLast = createFind(findLastIndex), groupBy = createAggregator(function(result, value, key) {
                    hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [ value ]);
                }), invokeMap = baseRest(function(collection, path, args) {
                    var index = -1, isFunc = "function" == typeof path, result = isArrayLike(collection) ? Array(collection.length) : [];
                    return baseEach(collection, function(value) {
                        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                    }), result;
                }), keyBy = createAggregator(function(result, value, key) {
                    baseAssignValue(result, key, value);
                }), partition = createAggregator(function(result, value, key) {
                    result[key ? 0 : 1].push(value);
                }, function() {
                    return [ [], [] ];
                }), sortBy = baseRest(function(collection, iteratees) {
                    if (null == collection) return [];
                    var length = iteratees.length;
                    return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [ iteratees[0] ]),
                    baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                }), now = ctxNow || function() {
                    return root.Date.now();
                }, bind = baseRest(function(func, thisArg, partials) {
                    var bitmask = WRAP_BIND_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, getHolder(bind));
                        bitmask |= WRAP_PARTIAL_FLAG;
                    }
                    return createWrap(func, bitmask, thisArg, partials, holders);
                }), bindKey = baseRest(function(object, key, partials) {
                    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, getHolder(bindKey));
                        bitmask |= WRAP_PARTIAL_FLAG;
                    }
                    return createWrap(key, bitmask, object, partials, holders);
                }), defer = baseRest(function(func, args) {
                    return baseDelay(func, 1, args);
                }), delay = baseRest(function(func, wait, args) {
                    return baseDelay(func, toNumber(wait) || 0, args);
                });
                memoize.Cache = MapCache;
                var overArgs = castRest(function(func, transforms) {
                    transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                    var funcsLength = transforms.length;
                    return baseRest(function(args) {
                        for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; ) args[index] = transforms[index].call(this, args[index]);
                        return apply(func, this, args);
                    });
                }), partial = baseRest(function(func, partials) {
                    var holders = replaceHolders(partials, getHolder(partial));
                    return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                }), partialRight = baseRest(function(func, partials) {
                    var holders = replaceHolders(partials, getHolder(partialRight));
                    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                }), rearg = flatRest(function(func, indexes) {
                    return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                }), gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
                    return value >= other;
                }), isArguments = baseIsArguments(function() {
                    return arguments;
                }()) ? baseIsArguments : function(value) {
                    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                }, isArray = Array.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer, isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
                    return value <= other;
                }), assign = createAssigner(function(object, source) {
                    if (isPrototype(source) || isArrayLike(source)) return void copyObject(source, keys(source), object);
                    for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key]);
                }), assignIn = createAssigner(function(object, source) {
                    copyObject(source, keysIn(source), object);
                }), assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keysIn(source), object, customizer);
                }), assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keys(source), object, customizer);
                }), at = flatRest(baseAt), defaults = baseRest(function(object, sources) {
                    object = Object(object);
                    var index = -1, length = sources.length, guard = length > 2 ? sources[2] : undefined;
                    for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; ) for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
                        var key = props[propsIndex], value = object[key];
                        (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key]);
                    }
                    return object;
                }), defaultsDeep = baseRest(function(args) {
                    return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args);
                }), invert = createInverter(function(result, value, key) {
                    null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)),
                    result[value] = key;
                }, constant(identity)), invertBy = createInverter(function(result, value, key) {
                    null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)),
                    hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [ key ];
                }, getIteratee), invoke = baseRest(baseInvoke), merge = createAssigner(function(object, source, srcIndex) {
                    baseMerge(object, source, srcIndex);
                }), mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                    baseMerge(object, source, srcIndex, customizer);
                }), omit = flatRest(function(object, paths) {
                    var result = {};
                    if (null == object) return result;
                    var isDeep = !1;
                    paths = arrayMap(paths, function(path) {
                        return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path;
                    }), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
                    for (var length = paths.length; length--; ) baseUnset(result, paths[length]);
                    return result;
                }), pick = flatRest(function(object, paths) {
                    return null == object ? {} : basePick(object, paths);
                }), toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn), camelCase = createCompounder(function(result, word, index) {
                    return word = word.toLowerCase(), result + (index ? capitalize(word) : word);
                }), kebabCase = createCompounder(function(result, word, index) {
                    return result + (index ? "-" : "") + word.toLowerCase();
                }), lowerCase = createCompounder(function(result, word, index) {
                    return result + (index ? " " : "") + word.toLowerCase();
                }), lowerFirst = createCaseFirst("toLowerCase"), snakeCase = createCompounder(function(result, word, index) {
                    return result + (index ? "_" : "") + word.toLowerCase();
                }), startCase = createCompounder(function(result, word, index) {
                    return result + (index ? " " : "") + upperFirst(word);
                }), upperCase = createCompounder(function(result, word, index) {
                    return result + (index ? " " : "") + word.toUpperCase();
                }), upperFirst = createCaseFirst("toUpperCase"), attempt = baseRest(function(func, args) {
                    try {
                        return apply(func, undefined, args);
                    } catch (e) {
                        return isError(e) ? e : new Error(e);
                    }
                }), bindAll = flatRest(function(object, methodNames) {
                    return arrayEach(methodNames, function(key) {
                        key = toKey(key), baseAssignValue(object, key, bind(object[key], object));
                    }), object;
                }), flow = createFlow(), flowRight = createFlow(!0), method = baseRest(function(path, args) {
                    return function(object) {
                        return baseInvoke(object, path, args);
                    };
                }), methodOf = baseRest(function(object, args) {
                    return function(path) {
                        return baseInvoke(object, path, args);
                    };
                }), over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome), range = createRange(), rangeRight = createRange(!0), add = createMathOperation(function(augend, addend) {
                    return augend + addend;
                }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
                    return dividend / divisor;
                }, 1), floor = createRound("floor"), multiply = createMathOperation(function(multiplier, multiplicand) {
                    return multiplier * multiplicand;
                }, 1), round = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
                    return minuend - subtrahend;
                }, 0);
                return lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn,
                lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at,
                lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey,
                lodash.castArray = castArray, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact,
                lodash.concat = concat, lodash.cond = cond, lodash.conforms = conforms, lodash.constant = constant,
                lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight,
                lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep,
                lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy,
                lodash.differenceWith = differenceWith, lodash.drop = drop, lodash.dropRight = dropRight,
                lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill,
                lodash.filter = filter, lodash.flatMap = flatMap, lodash.flatMapDeep = flatMapDeep,
                lodash.flatMapDepth = flatMapDepth, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep,
                lodash.flattenDepth = flattenDepth, lodash.flip = flip, lodash.flow = flow, lodash.flowRight = flowRight,
                lodash.fromPairs = fromPairs, lodash.functions = functions, lodash.functionsIn = functionsIn,
                lodash.groupBy = groupBy, lodash.initial = initial, lodash.intersection = intersection,
                lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith,
                lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap,
                lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn,
                lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches,
                lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge,
                lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf,
                lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = nthArg, lodash.omit = omit,
                lodash.omitBy = omitBy, lodash.once = once, lodash.orderBy = orderBy, lodash.over = over,
                lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome,
                lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition,
                lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = propertyOf,
                lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = pullAllBy, lodash.pullAllWith = pullAllWith,
                lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg,
                lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.reverse = reverse,
                lodash.sampleSize = sampleSize, lodash.set = set, lodash.setWith = setWith, lodash.shuffle = shuffle,
                lodash.slice = slice, lodash.sortBy = sortBy, lodash.sortedUniq = sortedUniq, lodash.sortedUniqBy = sortedUniqBy,
                lodash.split = split, lodash.spread = spread, lodash.tail = tail, lodash.take = take,
                lodash.takeRight = takeRight, lodash.takeRightWhile = takeRightWhile, lodash.takeWhile = takeWhile,
                lodash.tap = tap, lodash.throttle = throttle, lodash.thru = thru, lodash.toArray = toArray,
                lodash.toPairs = toPairs, lodash.toPairsIn = toPairsIn, lodash.toPath = toPath,
                lodash.toPlainObject = toPlainObject, lodash.transform = transform, lodash.unary = unary,
                lodash.union = union, lodash.unionBy = unionBy, lodash.unionWith = unionWith, lodash.uniq = uniq,
                lodash.uniqBy = uniqBy, lodash.uniqWith = uniqWith, lodash.unset = unset, lodash.unzip = unzip,
                lodash.unzipWith = unzipWith, lodash.update = update, lodash.updateWith = updateWith,
                lodash.values = values, lodash.valuesIn = valuesIn, lodash.without = without, lodash.words = words,
                lodash.wrap = wrap, lodash.xor = xor, lodash.xorBy = xorBy, lodash.xorWith = xorWith,
                lodash.zip = zip, lodash.zipObject = zipObject, lodash.zipObjectDeep = zipObjectDeep,
                lodash.zipWith = zipWith, lodash.entries = toPairs, lodash.entriesIn = toPairsIn,
                lodash.extend = assignIn, lodash.extendWith = assignInWith, mixin(lodash, lodash),
                lodash.add = add, lodash.attempt = attempt, lodash.camelCase = camelCase, lodash.capitalize = capitalize,
                lodash.ceil = ceil, lodash.clamp = clamp, lodash.clone = clone, lodash.cloneDeep = cloneDeep,
                lodash.cloneDeepWith = cloneDeepWith, lodash.cloneWith = cloneWith, lodash.conformsTo = conformsTo,
                lodash.deburr = deburr, lodash.defaultTo = defaultTo, lodash.divide = divide, lodash.endsWith = endsWith,
                lodash.eq = eq, lodash.escape = escape, lodash.escapeRegExp = escapeRegExp, lodash.every = every,
                lodash.find = find, lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast,
                lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.floor = floor,
                lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn,
                lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight,
                lodash.get = get, lodash.gt = gt, lodash.gte = gte, lodash.has = has, lodash.hasIn = hasIn,
                lodash.head = head, lodash.identity = identity, lodash.includes = includes, lodash.indexOf = indexOf,
                lodash.inRange = inRange, lodash.invoke = invoke, lodash.isArguments = isArguments,
                lodash.isArray = isArray, lodash.isArrayBuffer = isArrayBuffer, lodash.isArrayLike = isArrayLike,
                lodash.isArrayLikeObject = isArrayLikeObject, lodash.isBoolean = isBoolean, lodash.isBuffer = isBuffer,
                lodash.isDate = isDate, lodash.isElement = isElement, lodash.isEmpty = isEmpty,
                lodash.isEqual = isEqual, lodash.isEqualWith = isEqualWith, lodash.isError = isError,
                lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isInteger = isInteger,
                lodash.isLength = isLength, lodash.isMap = isMap, lodash.isMatch = isMatch, lodash.isMatchWith = isMatchWith,
                lodash.isNaN = isNaN, lodash.isNative = isNative, lodash.isNil = isNil, lodash.isNull = isNull,
                lodash.isNumber = isNumber, lodash.isObject = isObject, lodash.isObjectLike = isObjectLike,
                lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isSafeInteger = isSafeInteger,
                lodash.isSet = isSet, lodash.isString = isString, lodash.isSymbol = isSymbol, lodash.isTypedArray = isTypedArray,
                lodash.isUndefined = isUndefined, lodash.isWeakMap = isWeakMap, lodash.isWeakSet = isWeakSet,
                lodash.join = join, lodash.kebabCase = kebabCase, lodash.last = last, lodash.lastIndexOf = lastIndexOf,
                lodash.lowerCase = lowerCase, lodash.lowerFirst = lowerFirst, lodash.lt = lt, lodash.lte = lte,
                lodash.max = max, lodash.maxBy = maxBy, lodash.mean = mean, lodash.meanBy = meanBy,
                lodash.min = min, lodash.minBy = minBy, lodash.stubArray = stubArray, lodash.stubFalse = stubFalse,
                lodash.stubObject = stubObject, lodash.stubString = stubString, lodash.stubTrue = stubTrue,
                lodash.multiply = multiply, lodash.nth = nth, lodash.noConflict = noConflict, lodash.noop = noop,
                lodash.now = now, lodash.pad = pad, lodash.padEnd = padEnd, lodash.padStart = padStart,
                lodash.parseInt = parseInt, lodash.random = random, lodash.reduce = reduce, lodash.reduceRight = reduceRight,
                lodash.repeat = repeat, lodash.replace = replace, lodash.result = result, lodash.round = round,
                lodash.runInContext = runInContext, lodash.sample = sample, lodash.size = size,
                lodash.snakeCase = snakeCase, lodash.some = some, lodash.sortedIndex = sortedIndex,
                lodash.sortedIndexBy = sortedIndexBy, lodash.sortedIndexOf = sortedIndexOf, lodash.sortedLastIndex = sortedLastIndex,
                lodash.sortedLastIndexBy = sortedLastIndexBy, lodash.sortedLastIndexOf = sortedLastIndexOf,
                lodash.startCase = startCase, lodash.startsWith = startsWith, lodash.subtract = subtract,
                lodash.sum = sum, lodash.sumBy = sumBy, lodash.template = template, lodash.times = times,
                lodash.toFinite = toFinite, lodash.toInteger = toInteger, lodash.toLength = toLength,
                lodash.toLower = toLower, lodash.toNumber = toNumber, lodash.toSafeInteger = toSafeInteger,
                lodash.toString = toString, lodash.toUpper = toUpper, lodash.trim = trim, lodash.trimEnd = trimEnd,
                lodash.trimStart = trimStart, lodash.truncate = truncate, lodash.unescape = unescape,
                lodash.uniqueId = uniqueId, lodash.upperCase = upperCase, lodash.upperFirst = upperFirst,
                lodash.each = forEach, lodash.eachRight = forEachRight, lodash.first = head, mixin(lodash, function() {
                    var source = {};
                    return baseForOwn(lodash, function(func, methodName) {
                        hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func);
                    }), source;
                }(), {
                    chain: !1
                }), lodash.VERSION = "4.17.19", arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
                    lodash[methodName].placeholder = lodash;
                }), arrayEach([ "drop", "take" ], function(methodName, index) {
                    LazyWrapper.prototype[methodName] = function(n) {
                        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                        var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                        return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                            size: nativeMin(n, MAX_ARRAY_LENGTH),
                            type: methodName + (result.__dir__ < 0 ? "Right" : "")
                        }), result;
                    }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
                        return this.reverse()[methodName](n).reverse();
                    };
                }), arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
                    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || 3 == type;
                    LazyWrapper.prototype[methodName] = function(iteratee) {
                        var result = this.clone();
                        return result.__iteratees__.push({
                            iteratee: getIteratee(iteratee, 3),
                            type: type
                        }), result.__filtered__ = result.__filtered__ || isFilter, result;
                    };
                }), arrayEach([ "head", "last" ], function(methodName, index) {
                    var takeName = "take" + (index ? "Right" : "");
                    LazyWrapper.prototype[methodName] = function() {
                        return this[takeName](1).value()[0];
                    };
                }), arrayEach([ "initial", "tail" ], function(methodName, index) {
                    var dropName = "drop" + (index ? "" : "Right");
                    LazyWrapper.prototype[methodName] = function() {
                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                    };
                }), LazyWrapper.prototype.compact = function() {
                    return this.filter(identity);
                }, LazyWrapper.prototype.find = function(predicate) {
                    return this.filter(predicate).head();
                }, LazyWrapper.prototype.findLast = function(predicate) {
                    return this.reverse().find(predicate);
                }, LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                    return "function" == typeof path ? new LazyWrapper(this) : this.map(function(value) {
                        return baseInvoke(value, path, args);
                    });
                }), LazyWrapper.prototype.reject = function(predicate) {
                    return this.filter(negate(getIteratee(predicate)));
                }, LazyWrapper.prototype.slice = function(start, end) {
                    start = toInteger(start);
                    var result = this;
                    return result.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)),
                    end !== undefined && (end = toInteger(end), result = end < 0 ? result.dropRight(-end) : result.take(end - start)),
                    result);
                }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
                    return this.reverse().takeWhile(predicate).reverse();
                }, LazyWrapper.prototype.toArray = function() {
                    return this.take(MAX_ARRAY_LENGTH);
                }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                    lodashFunc && (lodash.prototype[methodName] = function() {
                        var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value), interceptor = function(value) {
                            var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                            return isTaker && chainAll ? result[0] : result;
                        };
                        useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                        if (!retUnwrapped && useLazy) {
                            value = onlyLazy ? value : new LazyWrapper(this);
                            var result = func.apply(value, args);
                            return result.__actions__.push({
                                func: thru,
                                args: [ interceptor ],
                                thisArg: undefined
                            }), new LodashWrapper(result, chainAll);
                        }
                        return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor),
                        isUnwrapped ? isTaker ? result.value()[0] : result.value() : result);
                    });
                }), arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
                    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                    lodash.prototype[methodName] = function() {
                        var args = arguments;
                        if (retUnwrapped && !this.__chain__) {
                            var value = this.value();
                            return func.apply(isArray(value) ? value : [], args);
                        }
                        return this[chainName](function(value) {
                            return func.apply(isArray(value) ? value : [], args);
                        });
                    };
                }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var lodashFunc = lodash[methodName];
                    if (lodashFunc) {
                        var key = lodashFunc.name + "";
                        hasOwnProperty.call(realNames, key) || (realNames[key] = []), realNames[key].push({
                            name: methodName,
                            func: lodashFunc
                        });
                    }
                }), realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [ {
                    name: "wrapper",
                    func: undefined
                } ], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse,
                LazyWrapper.prototype.value = lazyValue, lodash.prototype.at = wrapperAt, lodash.prototype.chain = wrapperChain,
                lodash.prototype.commit = wrapperCommit, lodash.prototype.next = wrapperNext, lodash.prototype.plant = wrapperPlant,
                lodash.prototype.reverse = wrapperReverse, lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue,
                lodash.prototype.first = lodash.prototype.head, symIterator && (lodash.prototype[symIterator] = wrapperToIterator),
                lodash;
            }();
            root._ = _, (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return _;
            }.call(exports, __webpack_require__, exports, module)) !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        }).call(this);
    }).call(exports, __webpack_require__(11), __webpack_require__(108)(module));
}, function(module, exports) {
    module.exports = function(module) {
        return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [],
        module.children || (module.children = []), Object.defineProperty(module, "loaded", {
            enumerable: !0,
            get: function() {
                return module.l;
            }
        }), Object.defineProperty(module, "id", {
            enumerable: !0,
            get: function() {
                return module.i;
            }
        }), module.webpackPolyfill = 1), module;
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    var __WEBPACK_IMPORTED_MODULE_0_roslib__ = __webpack_require__(1), Body = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_roslib__),
    function() {
        function Body(robot) {
            _classCallCheck(this, Body);
            var ros = robot.ros;
            this.action = new __WEBPACK_IMPORTED_MODULE_0_roslib__.ActionClient({
                ros: ros,
                serverName: "body/joint_trajectory_action",
                actionName: "control_msgs/FollowJointTrajectoryAction",
                timeout: 10
            });
            var parameter = new __WEBPACK_IMPORTED_MODULE_0_roslib__.Param({
                ros: ros,
                name: "skills"
            }), that = this;
            parameter.get(function(parameter_) {
                that.jointNames = {}, that.jointNames.arm = [], that.jointNames.leftArm = [], that.jointNames.rightArm = [],
                parameter_.arm.joint_names.forEach(function(jointName) {
                    that.jointNames.arm.push("".concat(jointName)), that.jointNames.leftArm.push("".concat(jointName, "_left")),
                    that.jointNames.rightArm.push("".concat(jointName, "_right"));
                }), that.jointNames.torso = parameter_.torso.joint_names, that.defaultConfigurations = {},
                that.defaultConfigurations.torso = parameter_.torso.default_configurations, that.defaultConfigurations.arm = parameter_.arm.default_configurations,
                that.defaultConfigurations.leftArm = parameter_.arm.default_configurations, that.defaultConfigurations.rightArm = parameter_.arm.default_configurations;
            }), this.leftGripperAction = new __WEBPACK_IMPORTED_MODULE_0_roslib__.ActionClient({
                ros: ros,
                serverName: "left_arm/gripper/action",
                actionName: "tue_manipulation_msgs/GripperCommandAction",
                timeout: 0
            }), this.rightGripperAction = new __WEBPACK_IMPORTED_MODULE_0_roslib__.ActionClient({
                ros: ros,
                serverName: "right_arm/gripper/action",
                actionName: "tue_manipulation_msgs/GripperCommandAction",
                timeout: 0
            });
        }
        return _createClass(Body, [ {
            key: "sendGoal",
            value: function(cmd) {
                console.log("Robot body: sending goal", cmd), new __WEBPACK_IMPORTED_MODULE_0_roslib__.Goal({
                    actionClient: this.action,
                    goalMessage: {
                        trajectory: {
                            joint_names: this.jointNames[cmd.body_part],
                            points: [ {
                                positions: this.defaultConfigurations[cmd.body_part][cmd.configuration]
                            } ]
                        },
                        goal_time_tolerance: {
                            secs: 5
                        }
                    }
                }).send(10);
            }
        }, {
            key: "sendGripperGoal",
            value: function(cmd) {
                console.log("Robot body: gripper goal:", cmd);
                var actionClient;
                if ("left" === cmd.side) actionClient = this.leftGripperAction; else {
                    if ("right" !== cmd.side) return void console.error("Gripper command side must be either left or right. Right now, it is", cmd.side);
                    actionClient = this.rightGripperAction;
                }
                var direction;
                if ("open" === cmd.direction) direction = -1; else {
                    if ("close" !== cmd.direction) return void console.error("Gripper command direction must be either open or close. Right now, it is", cmd.direction);
                    direction = 1;
                }
                new __WEBPACK_IMPORTED_MODULE_0_roslib__.Goal({
                    actionClient: actionClient,
                    goalMessage: {
                        command: {
                            direction: direction,
                            max_torque: 10
                        }
                    }
                }).send(0);
            }
        } ]), Body;
    }());
    __webpack_exports__.a = Body;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0,
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps),
        Constructor;
    }
    var __WEBPACK_IMPORTED_MODULE_0_roslib__ = __webpack_require__(1), Speech = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_roslib__),
    function() {
        function Speech(robot) {
            _classCallCheck(this, Speech);
            var ros = robot.ros;
            this.speechTopic = ros.Topic({
                name: "text_to_speech/input",
                messageType: "std_msgs/String"
            });
        }
        return _createClass(Speech, [ {
            key: "speak",
            value: function(cmd) {
                console.log("Speaking:", cmd);
                var message = new __WEBPACK_IMPORTED_MODULE_0_roslib__.Message({
                    data: cmd.sentence
                });
                this.speechTopic.publish(message);
            }
        } ]), Speech;
    }());
    __webpack_exports__.a = Speech;
}, function(module, exports) {
    module.exports = '<script id="vs" type="x-shader/x-vertex">\n\n  uniform sampler2D map;\n\n  uniform float width;\n  uniform float height;\n  uniform float nearClipping, farClipping;\n\n  varying vec2 vUv;\n\n  const float XtoZ = 1.11146; // tan( 1.0144686 / 2.0 ) * 2.0;\n  const float YtoZ = 0.83359; // tan( 0.7898090 / 2.0 ) * 2.0;\n\n  void main() {\n\n    vUv = vec2( position.x / width, 1.0 - ( position.y / height ) );\n\n    vec4 color = texture2D( map, vUv );\n    float depth = ( color.r + color.g + color.b ) / 3.0;\n\n    // Projection code by @kcmic\n\n    float z = ( 1.0 - depth ) * (farClipping - nearClipping) + nearClipping;\n\n    vec4 pos = vec4(\n      ( position.x / width - 0.5 ) * z * XtoZ,\n      ( position.y / height - 0.5 ) * z * YtoZ,\n      - z + 1000.0,\n      1.0);\n\n    gl_PointSize = 2.0;\n    gl_Position = projectionMatrix * modelViewMatrix * pos;\n\n  }\n\n<\/script>\n\n<script id="fs" type="x-shader/x-fragment">\n\n  uniform sampler2D map;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 color = texture2D( map, vUv );\n    gl_FragColor = vec4( color.r, color.g, color.b, smoothstep( 8000.0, -8000.0, gl_FragCoord.z / gl_FragCoord.w ) );\n\n  }\n\n<\/script>\n\n<ng-webgl on-entity-selection="entitySelection({entity: entity, event: event})" />\n';
}, function(module, exports) {
    module.exports = '<ng-controller>\n\n  <ng-controller>\n    <tue-battery-status/>\n    <tue-ebuttons></tue-ebuttons>\n  </div>\n\n  \x3c!-- Define ebuttons --\x3e\n  <script type="text/ng-template" id="/ebutton.html">\n    <ul class="nav navbar-nav navbar-right" style="padding: 0 15px;">\n      <li>\n        \x3c!-- <button ng-repeat="ebutton in ebuttons" class="btn btn-xs btn-circle" ng-class="ebutton.color" ng-attr-title="{{ebutton.name}}"> --\x3e\n        <button ng-repeat="ebutton in ebuttons" class="btn navbar-btn btn-circle" ng-class="ebutton.color" ng-attr-title="{{ebutton.name}}">\n          <span ng-class="ebutton.icon"></span>\n        </button>\n      </li>\n    </ul>\n  <\/script>\n\n  \x3c!-- Define battery status indicator --\x3e\n  <script type="text/ng-template" id="/battery.html">\n    <ul class="nav navbar-nav navbar-right">\n      <li style="width: 100px;" ng-repeat="(key, v) in batteries">\n        <div class="progress" style="margin: 8px; min-height: 32px" >\n          <div class="progress-bar" role="progressbar" aria-valuenow="v.value" aria-valuemin="0" aria-valuemax="100" style="line-height: 32px"\n               ng-style="{\'width\': v.value + \'%\'}"\n               ng-class="\'progress-bar-\' + v.type">\n            <span><b>{{key}} {{v.value}}%</b></span>\n          </div>\n        </div>\n      </li>\n    </ul>\n  <\/script>\n</div>\n';
}, function(module, exports) {
    module.exports = '<ng-teleop-canvas on-percentage-changed="teleopBase({px: px, py: py})"/>';
}, function(module, exports) {
    module.exports = '<ng-teleop-canvas on-percentage-changed="teleopHead({px: px, py: py})"/>\n';
}, function(module, exports) {
    module.exports = '<div ng-controller="SpeechCtrl">\n<h5>Text to speech</h5>\n<form ng-submit="speak(sentence)">\n  <div class="input-group">\n    <input type="text" ng-model="sentence" class="form-control" placeholder="Enter the text and press <enter> ...">\n    <span class="input-group-btn">\n      <input type="submit" class="btn btn-primary" value="Go!" />\n    </span>\n  </div>\x3c!-- /input-group --\x3e\n</form>\n<hr />\n<h5>History</h5>\n<div class="list-group">\n  <a ng-repeat="s in speech_history track by $index" href="#" ng-click="speak(s)" class="list-group-item">{{s}}</a>\n</div>\n</div>\n';
}, function(module, exports) {
    module.exports = '<div ng-controller="JointCtrl" id="body-tab">\n    <button class="btn btn-primary" ng-click="loadConfiguration()" ng-show="joint_names === undefined">Load configuration</button>\n    <div ng-show="joint_names !== undefined">\n      <div class="panel-group" id="accordion">\n        <div class="panel panel-primary">\n          <div class="panel-heading">\n            <h4 class="panel-title">\n              <a data-toggle="collapse" data-parent="#accordion" href="#collapseArm">Arm</a>\n            </h4>\n          </div>\n          <div id="collapseArm" class="panel-collapse collapse">\n            <ul class="list-group">\n                <a href="#" class="list-group-item" ng-repeat="(key, value) in default_configurations[\'leftArm\']"\n                type="button"  ng-click="sendJointCommand({body_part: \'leftArm\', configuration: key});">\n                {{key | makeNice}}</a>\n            </ul>\n          </div>\n        </div>\n        <div class="panel panel-primary">\n          <div class="panel-heading">\n            <h4 class="panel-title">\n              <a data-toggle="collapse" data-parent="#accordion" href="#collapseGripper">Gripper</a>\n            </h4>\n          </div>\n          <div id="collapseGripper" class="panel-collapse collapse">\n            <ul class="list-group">\n              <a href="#" class="list-group-item" ng-click="sendGripperCommand({side: \'left\', direction: \'open\'});">Open left</a>\n              <a href="#" class="list-group-item" ng-click="sendGripperCommand({side: \'left\', direction: \'close\'});">Close left</a>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n';
}, function(module, exports) {
    module.exports = '<h5>Environment Descriptor</h5>\n<div ng-controller="EdCtrl">\n  <button type="button" class="btn btn-primary" ng-click="reset();">Reset</button>\n</div>\n';
}, function(module, exports) {
    module.exports = '<div class="panel panel-default">\n  <div class="panel-body nav nav-tabs" id="teleop-tabs-content">\n    <div>\n      <ul class="nav nav-tabs">\n        <li class="active">\n          <a href="#teleop-base" role="tab" data-toggle="tab">\n              <icon class="fa fa-arrows"></icon>\n          </a>\n        </li>\n        <li>\n          <a href="#teleop-head" role="tab" data-toggle="tab">\n              <icon class="fa fa-smile-o"></icon>\n          </a>\n        </li>\n        <li>\n          <a href="#teleop-body" role="tab" data-toggle="tab">\n              <icon class="fa fa-male"></icon>\n          </a>\n        </li>\n        <li>\n          <a href="#teleop-speech" role="tab" data-toggle="tab">\n              <icon class="fa fa-volume-up"></icon>\n          </a>\n        </li>\n        <li>\n          <a href="#teleop-ed" role="tab" data-toggle="tab">\n              <icon class="fa fa-globe"></icon>\n          </a>\n        </li>\n      </ul>\n    </div>\n    <div class="tab-content">\n      <div class="tab-pane active" id="teleop-base">\n        <div ng-include="\'views/tabs/teleop_tabs/base.html\'" style="width: 100%; height: 300px"></div>\n      </div>\n      <div class="tab-pane" id="teleop-head">\n        <div ng-include="\'views/tabs/teleop_tabs/head.html\'" style="width: 100%; height: 300px"></div>\n      </div>\n      <div class="tab-pane" id="teleop-body" ng-include="\'views/tabs/teleop_tabs/body.html\'">\n      </div>\n      <div class="tab-pane" id="teleop-speech" ng-include="\'views/tabs/teleop_tabs/speech.html\'">\n      </div>\n      <div class="tab-pane" id="teleop-ed" ng-include="\'views/tabs/teleop_tabs/ed.html\'">\n      </div>\n    </div>\n  </div>\n</div>\n';
}, function(module, exports) {
    module.exports = '<div class="panel panel-default">\n  <div class="panel-heading">\n    Editor\n  </div>\n  <div class="panel-body">\n    Editor body\n  </div>\n</div>';
}, function(module, exports) {
    module.exports = '<div class="panel panel-default" ng-controller="ActionsCtrl" ng-init="active=false;idle=false">\n  <div class="panel-body">\n    <h5>Generic</h5>\n    <div>\n      <button type="button" class="btn btn-primary" ng-click="trigger(\'gpsr\');" ng-disabled="active">Trigger</button>\n      <button type="button" class="btn btn-primary" ng-click="cancel();">Cancel</button>\n    </div>\n\n    \x3c!-- <div class="panel panel-primary" style="margin-top: 10px;margin-bottom: 10px;">\n        <div class="panel-heading">Current action</div>\n        <div class="panel-body" ng-model="ActionsCtrl">{{current_subtask}}</div>\n    </div> --\x3e\n    <h5>Shortcuts</h5>\n    <div>\n      <button type="button" class="btn btn-primary" ng-click="present(\'en\')" ng-disabled="active">Presentation</button>\n      <button type="button" class="btn btn-primary" ng-click="present(\'nl\')" ng-disabled="active">Presentation Dutch</button>\n    </div>\n  </div>\n</div>';
} ]);